{
  "version": 3,
  "sources": ["../../../../client/src/services/waypointHelper.js"],
  "sourcesContent": ["import GameHelper from './gameHelper'\n\nclass WaypointHelper {\n    calculateShortestRoute (game, carrier, sourceStarId, destinStarId) {\n        const player = GameHelper.getUserPlayer(game)\n        const hyperspaceDistance = GameHelper.getHyperspaceDistance(game, player, carrier)\n\n        let graph = game.galaxy.stars.map(s => {\n            return {\n                ...s,\n                cost: 0,\n                costFromStart: 0,\n                neighbors: null,\n                parent: null\n            }\n        })\n\n        const getNeighbors = (node) => graph\n            .filter(s => s._id !== node._id)\n            .filter(s => GameHelper.getDistanceBetweenLocations(s.location, node.location) <= hyperspaceDistance || GameHelper.isStarPairWormHole(s, node))\n\n        let start = graph.find(s => s._id === sourceStarId)\n        let end = graph.find(s => s._id === destinStarId)\n\n        let openSet = [start]\n        let closedSet = []\n\n        while (openSet.length) {\n            // This sort makes us look at the nodes where we can get the quickest first.\n            // This guarantees that all nodes that already have a calculated route (which may not be the quickest)\n            // will have their quickest route found. This in turn guarantees that the final fastest route can be found.\n\n            // Note from Tristanvds: Unfortunately we cannot also take into account a sorting system where we look at the\n            // distance to the end star. This kind of sorting system would favour going in a direct line towards that star\n            // instead of going for wormholes. Therefore we have to take a (computationally) slower approach by sorting\n            // based on the distance from the start.\n            openSet.sort((a, b) => a.costFromStart - b.costFromStart); // Ensure we start with the node that has the lowest total cost\n            const current = openSet.shift();\n\n            closedSet.push(current); // We're evaluating, so might as well close it.\n            \n            // If we've found the end, return the reversed path.\n            if (current._id === end._id) {\n                let temp = current;\n        \n                const path = [];\n\n                path.push(temp);\n        \n                while (temp.parent) {\n                    path.push(temp.parent);\n                    temp = temp.parent;\n                }\n        \n                return path.reverse();\n            }\n\n            // Dynamically load neighbors as its more efficient\n            if (!current.neighbors) {\n                current.neighbors = getNeighbors(current);\n            }\n\n            for (let neighbor of current.neighbors) {\n                // If the neighbor has already been checked, then no need to check again.\n                const isClosed = closedSet.find(n => n._id === neighbor._id) != null;\n\n                if (!isClosed) {\n                    neighbor.cost = GameHelper.getActualTicksBetweenLocations(game, player, carrier, current, neighbor, hyperspaceDistance)\n\n                    // Calculate what the next cost will be, we don't want to check\n                    // any paths that lead us to more cost.\n                    let nextCost = current.costFromStart + neighbor.cost;\n\n                    // But if we haven't tried this path, enqueue it.\n                    const isOpen = openSet.find(n => n._id === neighbor._id) != null;\n\n                    if (!isOpen) {\n                        openSet.push(neighbor);\n                    } else if (nextCost >= neighbor.costFromStart) {\n                        continue;\n                    }\n\n                    // Calculate the final cost from the start to the end\n                    // while updating the path taken.\n                    neighbor.costFromStart = nextCost\n                    neighbor.parent = current\n                }\n            }\n        }\n\n        return []\n    }\n}\n\nexport default new WaypointHelper()\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAuB;AAEvB,MAAM,eAAe;AAAA,EACjB,uBAAwB,MAAM,SAAS,cAAc,cAAc;AAC/D,UAAM,SAAS,kBAAAA,QAAW,cAAc,IAAI;AAC5C,UAAM,qBAAqB,kBAAAA,QAAW,sBAAsB,MAAM,QAAQ,OAAO;AAEjF,QAAI,QAAQ,KAAK,OAAO,MAAM,IAAI,OAAK;AACnC,aAAO;AAAA,QACH,GAAG;AAAA,QACH,MAAM;AAAA,QACN,eAAe;AAAA,QACf,WAAW;AAAA,QACX,QAAQ;AAAA,MACZ;AAAA,IACJ,CAAC;AAED,UAAM,eAAe,CAAC,SAAS,MAC1B,OAAO,OAAK,EAAE,QAAQ,KAAK,GAAG,EAC9B,OAAO,OAAK,kBAAAA,QAAW,4BAA4B,EAAE,UAAU,KAAK,QAAQ,KAAK,sBAAsB,kBAAAA,QAAW,mBAAmB,GAAG,IAAI,CAAC;AAElJ,QAAI,QAAQ,MAAM,KAAK,OAAK,EAAE,QAAQ,YAAY;AAClD,QAAI,MAAM,MAAM,KAAK,OAAK,EAAE,QAAQ,YAAY;AAEhD,QAAI,UAAU,CAAC,KAAK;AACpB,QAAI,YAAY,CAAC;AAEjB,WAAO,QAAQ,QAAQ;AASnB,cAAQ,KAAK,CAAC,GAAG,MAAM,EAAE,gBAAgB,EAAE,aAAa;AACxD,YAAM,UAAU,QAAQ,MAAM;AAE9B,gBAAU,KAAK,OAAO;AAGtB,UAAI,QAAQ,QAAQ,IAAI,KAAK;AACzB,YAAI,OAAO;AAEX,cAAM,OAAO,CAAC;AAEd,aAAK,KAAK,IAAI;AAEd,eAAO,KAAK,QAAQ;AAChB,eAAK,KAAK,KAAK,MAAM;AACrB,iBAAO,KAAK;AAAA,QAChB;AAEA,eAAO,KAAK,QAAQ;AAAA,MACxB;AAGA,UAAI,CAAC,QAAQ,WAAW;AACpB,gBAAQ,YAAY,aAAa,OAAO;AAAA,MAC5C;AAEA,eAAS,YAAY,QAAQ,WAAW;AAEpC,cAAM,WAAW,UAAU,KAAK,OAAK,EAAE,QAAQ,SAAS,GAAG,KAAK;AAEhE,YAAI,CAAC,UAAU;AACX,mBAAS,OAAO,kBAAAA,QAAW,+BAA+B,MAAM,QAAQ,SAAS,SAAS,UAAU,kBAAkB;AAItH,cAAI,WAAW,QAAQ,gBAAgB,SAAS;AAGhD,gBAAM,SAAS,QAAQ,KAAK,OAAK,EAAE,QAAQ,SAAS,GAAG,KAAK;AAE5D,cAAI,CAAC,QAAQ;AACT,oBAAQ,KAAK,QAAQ;AAAA,UACzB,WAAW,YAAY,SAAS,eAAe;AAC3C;AAAA,UACJ;AAIA,mBAAS,gBAAgB;AACzB,mBAAS,SAAS;AAAA,QACtB;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO,CAAC;AAAA,EACZ;AACJ;AAEA,IAAO,yBAAQ,IAAI,eAAe;",
  "names": ["GameHelper"]
}
