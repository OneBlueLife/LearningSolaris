{
  "version": 3,
  "sources": ["../../../server/services/gameJoin.ts"],
  "sourcesContent": ["const EventEmitter = require('events');\nconst moment = require('moment');\nimport { DBObjectId } from './types/DBObjectId';\nimport ValidationError from '../errors/validation';\nimport { Game } from './types/Game';\nimport { Player } from './types/Player';\nimport AchievementService from './achievement';\nimport AvatarService from './avatar';\nimport GameStateService from './gameState';\nimport GameTypeService from './gameType';\nimport PasswordService from './password';\nimport PlayerService from './player';\nimport StarService from './star';\nimport UserService from './user';\nimport ConversationService from './conversation';\nimport GamePlayerJoinedEvent from './types/events/GamePlayerJoined';\nimport { BaseGameEvent } from './types/events/BaseGameEvent';\nimport RandomService from './random';\nimport SpectatorService from './spectator';\n\nexport const GameJoinServiceEvents = {\n    onPlayerJoined: 'onPlayerJoined',\n    onGameStarted: 'onGameStarted'\n}\n\nexport default class GameJoinService extends EventEmitter {\n    userService: UserService;\n    starService: StarService;\n    playerService: PlayerService;\n    passwordService: PasswordService;\n    achievementService: AchievementService;\n    avatarService: AvatarService;\n    gameTypeService: GameTypeService;\n    gameStateService: GameStateService;\n    conversationService: ConversationService;\n    randomService: RandomService;\n    spectatorService: SpectatorService;\n\n    constructor(\n        userService: UserService,\n        starService: StarService,\n        playerService: PlayerService,\n        passwordService: PasswordService,\n        achievementService: AchievementService,\n        avatarService: AvatarService,\n        gameTypeService: GameTypeService,\n        gameStateService: GameStateService,\n        conversationService: ConversationService,\n        randomService: RandomService,\n        spectatorService: SpectatorService\n    ) {\n        super();\n        \n        this.userService = userService;\n        this.starService = starService;\n        this.playerService = playerService;\n        this.passwordService = passwordService;\n        this.achievementService = achievementService;\n        this.avatarService = avatarService;\n        this.gameTypeService = gameTypeService;\n        this.gameStateService = gameStateService;\n        this.conversationService = conversationService;\n        this.randomService = randomService;\n        this.spectatorService = spectatorService;\n    }\n\n    async join(game: Game, userId: DBObjectId, playerId: DBObjectId, alias: string, avatar: number, password: string) {\n        // The player cannot join the game if:\n        // 1. The game has finished.\n        // 2. They quit the game before the game started or they conceded defeat.\n        // 3. They are already playing in the game.\n        // 4. They are trying to join a slot that isn't open.\n        // 5. They are trying to play in a different slot if they have been afk'd.\n        // 6. The password entered is invalid.\n        // 7. The player does not own any stars.\n        // 8. The alias is already taken.\n        // 9. The alias (username) is already taken.\n\n        // Only allow join if the game hasn't finished.\n        if (game.state.endDate) {\n            throw new ValidationError('The game has already finished.');\n        }\n\n        if (game.settings.general.password) {\n            let passwordMatch = await this.passwordService.compare(password, game.settings.general.password);\n\n            if (!passwordMatch) {\n                throw new ValidationError('The password is invalid.');\n            }\n        }\n\n        // Perform a new player check if the game is for established players only.\n        // If the player is new then they cannot join.\n\n        if (this.gameTypeService.isForEstablishedPlayersOnly(game)) {\n            const isEstablishedPlayer = await this.userService.isEstablishedPlayer(userId);\n            \n            // Disallow new players from joining non-new-player-games games if they haven't completed a game yet.\n            if (!isEstablishedPlayer && !this.gameTypeService.isNewPlayerGame(game)) {\n                throw new ValidationError('You must complete a \"New Player\" game or a custom game before you can join an official game.');\n            }\n        }\n\n        // Verify that the user has purchased the avatar they selected.\n        const userAvatar = await this.avatarService.getUserAvatar(userId, avatar);\n\n        if (!userAvatar.purchased) {\n            throw new ValidationError(`You have not purchased the selected avatar.`);\n        }\n\n        // The user cannot rejoin if they quit early or conceded defeat.\n        let isQuitter = game.quitters.find(x => x.toString() === userId.toString());\n\n        if (isQuitter) {\n            throw new ValidationError('You cannot rejoin this game.');\n        }\n\n        // Disallow if they are already in the game as another player.\n        // If the player they are in the game as is afk then that's fine.\n        let existing = game.galaxy.players.find(x => x.userId && x.userId.toString() === userId.toString());\n\n        if (existing && !existing.afk) {\n            throw new ValidationError('You are already participating in this game.');\n        }\n\n        // Get the player and update it to assign the user to the player.\n        let player = game.galaxy.players.find(x => x._id.toString() === playerId.toString());\n\n        if (!player) {\n            throw new ValidationError('The player is not participating in this game.');\n        }\n\n        if (!player.isOpenSlot) {\n            throw new ValidationError(`The player slot is not open to be filled.`);\n        }\n\n        // If the user was an afk-er then they are only allowed to join\n        // their slot.\n        let isAfker = game.afkers.find(x => x.toString() === userId.toString());\n        let isRejoiningAfkSlot = isAfker && player.afk && userId && player.userId && player.userId.toString() === userId.toString();\n\n        // If they have been afk'd then they are only allowed to join their slot again.\n        if (player.afk && isAfker && userId && player.userId && player.userId.toString() !== userId.toString()) {\n            throw new ValidationError('You can only rejoin this game in your own slot.');\n        }\n\n        let stars = this.starService.listStarsOwnedByPlayer(game.galaxy.stars, player._id);\n\n        if (!stars.length) {\n            throw new ValidationError('Cannot fill this slot, the player does not own any stars.');\n        }\n\n        let aliasCheckPlayer = game.galaxy.players.find(x => x.userId && x.alias.toLowerCase() === alias.toLowerCase());\n\n        if (aliasCheckPlayer && !isRejoiningAfkSlot) {\n            throw new ValidationError(`The alias '${alias}' has already been taken by another player.`);\n        }\n\n        // Disallow if they have the same alias as a user.\n        let aliasCheckUser = await this.userService.otherUsernameExists(alias, userId);\n\n        if (aliasCheckUser) {\n            throw new ValidationError(`The alias '${alias}' is the username of another player.`);\n        }\n\n        // TODO: Factor in player type setting. i.e premium players only.\n\n        let gameIsFull = this.assignPlayerToUser(game, player, userId, alias, avatar);\n\n        if (gameIsFull) {\n            this.assignNonUserPlayersToAI(game);\n        }\n\n        await game.save();\n\n        if (player.userId && !this.gameTypeService.isTutorialGame(game)) {\n            await this.achievementService.incrementJoined(player.userId);\n        }\n\n        let playerJoinedEvent: GamePlayerJoinedEvent = {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            playerId: player._id,\n            playerAlias: player.alias\n        };\n\n        this.emit(GameJoinServiceEvents.onPlayerJoined, playerJoinedEvent);\n\n        if (gameIsFull) {\n            let e: BaseGameEvent = {\n                gameId: game._id,\n                gameTick: game.state.tick\n            };\n\n            this.emit(GameJoinServiceEvents.onGameStarted, e);\n        }\n\n        return gameIsFull; // Return whether the game is now full, the calling API endpoint can broadcast it.\n    }\n    \n    assignPlayerToUser(game: Game, player: Player, userId: DBObjectId | null, alias: string, avatar: number) {\n        if (!player.isOpenSlot) {\n            throw new ValidationError(`The player slot is not open to be filled`);\n        }\n        \n        let isAfker = userId && game.afkers.find(x => x.toString() === userId.toString()) != null;\n        let isFillingAfkSlot = this.gameStateService.isInProgress(game) && player.afk;\n        let isRejoiningOwnAfkSlot = isFillingAfkSlot && isAfker && (userId && player.userId && player.userId.toString() === userId.toString());\n        let hasFilledOtherPlayerAfkSlot = isFillingAfkSlot && !isRejoiningOwnAfkSlot;\n\n        // Assign the user to the player.\n        player.userId = userId;\n        player.alias = alias;\n        player.avatar = avatar.toString();\n        player.spectators = [];\n\n        // Reset the defeated and afk status as the user may be filling\n        // an afk slot.\n        player.hasFilledAfkSlot = hasFilledOtherPlayerAfkSlot;\n        player.isOpenSlot = false;\n        player.defeated = false;\n        player.defeatedDate = null;\n        player.missedTurns = 0;\n        player.afk = false;\n        player.hasSentTurnReminder = false;\n\n        if (!player.userId) {\n            player.ready = true;\n        }\n\n        if (userId) {\n            // Clear out any players the user may be spectating.\n            this.spectatorService.clearSpectating(game, userId);\n        }\n\n        // If the max player count is reached then start the game.\n        this.gameStateService.updateStatePlayerCount(game);\n        \n        let shouldStartGame = false;\n\n        // If the game hasn't started yet then check if the game is full\n        if (!game.state.startDate) {\n            // Start the game if all slots have been filled\n            // OR its a new player game, half or more are filled\n            // OR its a tutorial game and a player has joined\n            shouldStartGame = game.state.players === game.settings.general.playerLimit ||\n                (this.gameTypeService.isNewPlayerGame(game) && game.state.players >= game.settings.general.playerLimit / 2) ||\n                (this.gameTypeService.isTutorialGame(game) && game.state.players > 0);\n    \n            if (shouldStartGame) {\n                let startDate = moment().utc();\n    \n                if (this.gameTypeService.isRealTimeGame(game)) {\n                    // Add the start delay to the start date.\n                    startDate.add(game.settings.gameTime.startDelay, 'minute');\n                }\n    \n                game.state.paused = false;\n                game.state.startDate = startDate;\n                game.state.lastTickDate = startDate;\n    \n                for (let player of game.galaxy.players) {\n                    this.playerService.updateLastSeen(game, player, startDate);\n                }\n            }\n        } else {\n            this.playerService.updateLastSeen(game, player);\n\n            // If the player is joining another player's AFK slot, remove them\n            // from any conversation that the other player was in.\n            if (hasFilledOtherPlayerAfkSlot) {\n                this.conversationService.leaveAll(game, player._id);\n            }\n        }\n\n        return shouldStartGame;\n    }\n\n    assignNonUserPlayersToAI(game: Game) {\n        // For all AI, assign a random alias and an avatar.\n        const players = game.galaxy.players.filter(p => p.userId == null);\n\n        if (!players.length) {\n            return;\n        }\n\n        const aliases = this.avatarService.listAllAliases();\n        const avatars = this.avatarService.listAllSolarisAvatars();\n\n        for (const player of players) {\n            const aliasIndex = this.randomService.getRandomNumberBetween(0, aliases.length - 1);\n            const avatarIndex = this.randomService.getRandomNumberBetween(0, avatars.length - 1);\n\n            const alias = aliases.splice(aliasIndex, 1)[0];\n            const avatar = avatars.splice(avatarIndex, 1)[0].id.toString();\n\n            player.alias = alias;\n            player.avatar = avatar;\n            player.researchingNext = 'random';\n            player.missedTurns = 0;\n            player.hasSentTurnReminder = false;\n            player.afk = false;\n            player.defeated = false;\n            player.defeatedDate = null;\n            player.hasFilledAfkSlot = false;\n\n            if (this.gameTypeService.isTurnBasedGame(game)) {\n                player.ready = true;\n            }\n            \n            // If its a tutorial game we want to keep the slot closed.\n            player.isOpenSlot = !this.gameTypeService.isTutorialGame(game);\n        }\n    }\n\n};\n"],
  "mappings": "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",
  "names": ["ValidationError", "player"]
}
