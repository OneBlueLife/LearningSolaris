{
  "version": 3,
  "sources": ["../../../../server/services/maps/spiral.ts"],
  "sourcesContent": ["import { Location } from '../types/Location'\nimport DistanceService from \"../distance\";\nimport GameTypeService from \"../gameType\";\nimport RandomService from \"../random\";\nimport ResourceService from \"../resource\";\nimport StarService from \"../star\";\nimport StarDistanceService from \"../starDistance\";\nimport { GalaxyDimensions } from '../types/Dimensions';\nimport { GameResourceDistribution } from '../types/Game';\n\nconst simplexNoise = require('simplex-noise');\n\nexport default class SpiralMapService {\n\n    randomService: RandomService;\n    starService: StarService;\n    starDistanceService: StarDistanceService;\n    distanceService: DistanceService;\n    resourceService: ResourceService;\n    gameTypeService: GameTypeService;\n\n    constructor(\n        randomService: RandomService,\n        starService: StarService,\n        starDistanceService: StarDistanceService,\n        distanceService: DistanceService,\n        resourceService: ResourceService,\n        gameTypeService: GameTypeService) {\n        this.randomService = randomService;\n        this.starService = starService;\n        this.starDistanceService = starDistanceService;\n        this.distanceService = distanceService;\n        this.resourceService = resourceService;\n        this.gameTypeService = gameTypeService;\n    }\n\n    generateLocations(game, count: number, resourceDistribution: GameResourceDistribution): Location[] {\n        let branchCount = 4;\n\n        // Hard code branches for small games.\n        if (game.settings.general.playerLimit === 2) {\n            branchCount = 2;\n        } else if (game.settings.general.playerLimit === 3) {\n            branchCount = 3;\n        }\n\n        let locations = this.generateSpiral(game, count, branchCount);\n\n        // TODO: Temporarily removed this as it screws with player positioning.\n        // This service should be responsible for plotting where player home stars are as\n        // the current logic doesn't really work well when galaxies are stretched.\n        //this.applyQuadraticStretch(locations);\n        this.resourceService.distribute(game, locations, resourceDistribution);\n\n        this.applyNoise(locations);\n        this.applyPadding(locations);\n\n        locations = this.scaleUp(game, locations);\n\n        return locations;\n    }\n\n    generateSpiral(game, locationCount: number, branchCount: number): Location[] {\n        const locations: Location[] = [];\n\n        if (this.gameTypeService.isKingOfTheHillMode(game)) {\n            locations.push(this.starDistanceService.getGalacticCenter());\n        }\n\n        let BRANCHES = branchCount;\n        let COPIES = 2;\n\n        let DISTANCE_FACTOR = 0.15;\n        let ANGLE_DELTA = 1;\n\n        let i = 0;\n        let c_i = 0;\n\n        do {\n            c_i++;\n\n            if (c_i == COPIES) {\n                i++\n                c_i  = 0\n            }\n\n            let current_branch = i % BRANCHES\n            let distance = i / BRANCHES * DISTANCE_FACTOR\n            let angle = (current_branch / BRANCHES)  * 2 * Math.PI + distance * ANGLE_DELTA\n            let sin = Math.sin(angle)\n            let cos = Math.cos(angle)\n\n            let x = sin * distance\n            let y = cos * distance\n\n            locations.push({\n                x, y\n            });\n        } while (locations.length < locationCount);\n\n        return locations;\n    }\n\n    applyQuadraticStretch(locations: Location[]): void {\n        let RADIUS = 3\n\n        let X_BASE = 2\n        let X_EXP  = 1.2\n        let X_EXP2= 2\n        let Y_BASE = 2\n        let Y_EXP = 0.1\n        let Y_EXP2 = 2\n\n        for (let i = 0; i < locations.length; i++){\n            let location = locations[i]\n\n            let x_init =  location.x\n            let y_init =  location.y\n\n            let vector = Math.hypot(x_init, y_init);\n            let vectorScale = (RADIUS - vector) / RADIUS;\n\n            let x = x_init * Math.pow(X_BASE, X_EXP * Math.pow(vectorScale, X_EXP2));\n            let y = y_init * Math.pow(Y_BASE, Y_EXP * Math.pow(vectorScale, Y_EXP2));\n\n            location.x = x;\n            location.y = y;\n        }\n    }\n\n    applyNoise(locations: Location[]): void {\n        let seed = Math.floor(Math.random() * 10000)\n        let simplex = new simplexNoise(seed);\n        \n        let DELTA_DISTANCE = 0.01;\n        let DISTANCE_CHECKING_DIRECTIONS = 1;\n        let ITERATION_COUNT = 10;\n        let PERLIN_SCALE = 1;\n        let PERLIN_GRAVITY = 0.01;\n        let PERLIN_BROWNIAN_MOTION = 0.05;\n\n        // perlin modifications\n        for (let i = 0; i < ITERATION_COUNT; i++) {\n            for (var s_i = 0;s_i < locations.length; s_i++ ) {\n                let location = locations[s_i]\n                let d_x = 0;\n                let d_y = 0;\n                let s_x = location.x * PERLIN_SCALE\n                let s_y = location.y * PERLIN_SCALE\n\n                let val_at_loc = simplex.noise2D(s_x , s_y)\n\n                // get gradient in perlin noise\n                for (let d_i = 0; d_i < DISTANCE_CHECKING_DIRECTIONS; d_i ++) { \n                    // now we get sin and cos for our absolute vector\n                    let angle = d_i * Math.PI / DISTANCE_CHECKING_DIRECTIONS\n                    let av_x = Math.sin(angle)\n                    let av_y = Math.cos(angle)\n                    let val_at_offset = simplex.noise2D(s_x + av_x * DELTA_DISTANCE, s_y + av_y * DELTA_DISTANCE)\n\n                    d_x += (val_at_loc - val_at_offset ) * PERLIN_GRAVITY;\n                    d_y += (val_at_loc - val_at_offset ) * PERLIN_GRAVITY;\n                }\n\n                // apply force to location\n                location.x += d_x + PERLIN_BROWNIAN_MOTION * Math.random();\n                location.y += d_y + PERLIN_BROWNIAN_MOTION * Math.random();\n            }\n        }\n    }\n\n    applyPadding(locations: Location[]): void {\n        let MIN_D = 0.2,\n            REPOS = 0.01,\n            MAX_REPOS = 0.1,\n            ITER = 5;\n\n        while (ITER--){\n            for (let i1 = 0; i1 < locations.length; i1++) {\n                let locationA = locations[i1];\n\n                for (let i2 = i1 + 1 ; i2 < locations.length; i2++) {\n                    let locationB = locations[i2];\n\n                    let dx = locationA.x - locationB.x;\n                    let dy = locationA.y - locationB.y;\n\n                    let distance = Math.hypot(dx, dy);\n\n                    if (distance < MIN_D) {\n                        let sin = dy / distance;\n                        let cos = dx / distance;\n\n                        let x_repos = cos * Math.min(MAX_REPOS, REPOS / distance);\n                        let y_repos = sin * Math.min(MAX_REPOS, REPOS / distance);\n\n                        locationA.x = locationA.x + x_repos;\n                        locationA.y = locationA.y + y_repos;\n                        locationB.x = locationB.x - x_repos;\n                        locationB.y = locationB.y - y_repos;\n                    }\n                }\n            }\n        }\n    }\n\n    scaleUp(game, locations: Location[]): Location[] {\n        // Start out at the minimum possible galaxy size and increment up\n        // in steps until ALL stars are at least minimum distance away from others.\n        let C_HEIGHT = game.constants.distances.minDistanceBetweenStars;\n        let C_WIDTH = game.constants.distances.minDistanceBetweenStars;\n        let C_STEP = game.constants.distances.minDistanceBetweenStars;\n        \n        let isValidGalaxy = false;\n\n        let locs;\n\n        do {\n            locs = JSON.parse(JSON.stringify(locations)); // Copy the locations so we can do it in isolation.\n\n            let galaxy = this.getGalaxyMinMax(locs);\n\n            let x_init = galaxy.minX;\n            let y_init = galaxy.minY;\n\n            let x_delta = galaxy.maxX - galaxy.minX;\n            let y_delta = galaxy.maxY - galaxy.minY;\n\n            let scale = 0;\n\n            if (x_delta < y_delta) {\n                scale =  C_HEIGHT  / y_delta \n            } else {\n                scale = C_WIDTH / x_delta \n            }\n\n            for (let i = 0; i < locs.length; i++) {\n                let location = locs[i];\n                let size = (location.resources.economy + location.resources.industry + location.resources.science) / 3;\n\n                let x_center = (location.x - x_init) * scale - size / 2\n                let y_center = (location.y - y_init) * scale - size / 2\n                \n                location.x = x_center;\n                location.y = y_center;\n            }\n\n            C_WIDTH += C_STEP;\n            C_HEIGHT += C_STEP;\n\n            isValidGalaxy = this.isValidGalaxyCheck(game, locs);\n        } while (!isValidGalaxy);\n\n        return locs;\n    }\n\n    isValidGalaxyCheck(game, locations: Location[]): boolean {\n        // If the average distance to closest star is greater than the minimum distance allowed then the galaxy is valid.\n        let average = \n            locations.reduce((sum, l) => sum + this.distanceService.getDistanceToClosestLocation(l, locations), 0) \n                / locations.length;\n\n        return average >= game.constants.distances.minDistanceBetweenStars * 2;\n    }\n\n    getGalaxyMinMax(locations: Location[]): GalaxyDimensions {\n        let x_min = 0,\n            y_min = 0,\n            x_max = 0,\n            y_max = 0;\n\n        for (let i = 0; i < locations.length; i++) {\n            let location = locations[i]\n\n            x_min = Math.min(x_min, location.x);\n            x_max = Math.max(x_max, location.x);\n            y_min = Math.min(y_min, location.y);\n            y_max = Math.max(x_max, location.y);\n        }\n\n        return {\n            minX: x_min,\n            minY: y_min,\n            maxX: x_max,\n            maxY: y_max\n        }\n    }\n\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA,MAAM,eAAe,QAAQ,eAAe;AAE5C,MAAO,iBAA+B;AAAA,EASlC,YACI,eACA,aACA,qBACA,iBACA,iBACA,iBAAkC;AAClC,SAAK,gBAAgB;AACrB,SAAK,cAAc;AACnB,SAAK,sBAAsB;AAC3B,SAAK,kBAAkB;AACvB,SAAK,kBAAkB;AACvB,SAAK,kBAAkB;AAAA,EAC3B;AAAA,EAEA,kBAAkB,MAAM,OAAe,sBAA4D;AAC/F,QAAI,cAAc;AAGlB,QAAI,KAAK,SAAS,QAAQ,gBAAgB,GAAG;AACzC,oBAAc;AAAA,IAClB,WAAW,KAAK,SAAS,QAAQ,gBAAgB,GAAG;AAChD,oBAAc;AAAA,IAClB;AAEA,QAAI,YAAY,KAAK,eAAe,MAAM,OAAO,WAAW;AAM5D,SAAK,gBAAgB,WAAW,MAAM,WAAW,oBAAoB;AAErE,SAAK,WAAW,SAAS;AACzB,SAAK,aAAa,SAAS;AAE3B,gBAAY,KAAK,QAAQ,MAAM,SAAS;AAExC,WAAO;AAAA,EACX;AAAA,EAEA,eAAe,MAAM,eAAuB,aAAiC;AACzE,UAAM,YAAwB,CAAC;AAE/B,QAAI,KAAK,gBAAgB,oBAAoB,IAAI,GAAG;AAChD,gBAAU,KAAK,KAAK,oBAAoB,kBAAkB,CAAC;AAAA,IAC/D;AAEA,QAAI,WAAW;AACf,QAAI,SAAS;AAEb,QAAI,kBAAkB;AACtB,QAAI,cAAc;AAElB,QAAI,IAAI;AACR,QAAI,MAAM;AAEV,OAAG;AACC;AAEA,UAAI,OAAO,QAAQ;AACf;AACA,cAAO;AAAA,MACX;AAEA,UAAI,iBAAiB,IAAI;AACzB,UAAI,WAAW,IAAI,WAAW;AAC9B,UAAI,QAAS,iBAAiB,WAAa,IAAI,KAAK,KAAK,WAAW;AACpE,UAAI,MAAM,KAAK,IAAI,KAAK;AACxB,UAAI,MAAM,KAAK,IAAI,KAAK;AAExB,UAAI,IAAI,MAAM;AACd,UAAI,IAAI,MAAM;AAEd,gBAAU,KAAK;AAAA,QACX;AAAA,QAAG;AAAA,MACP,CAAC;AAAA,IACL,SAAS,UAAU,SAAS;AAE5B,WAAO;AAAA,EACX;AAAA,EAEA,sBAAsB,WAA6B;AAC/C,QAAI,SAAS;AAEb,QAAI,SAAS;AACb,QAAI,QAAS;AACb,QAAI,SAAQ;AACZ,QAAI,SAAS;AACb,QAAI,QAAQ;AACZ,QAAI,SAAS;AAEb,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAI;AACtC,UAAI,WAAW,UAAU;AAEzB,UAAI,SAAU,SAAS;AACvB,UAAI,SAAU,SAAS;AAEvB,UAAI,SAAS,KAAK,MAAM,QAAQ,MAAM;AACtC,UAAI,eAAe,SAAS,UAAU;AAEtC,UAAI,IAAI,SAAS,KAAK,IAAI,QAAQ,QAAQ,KAAK,IAAI,aAAa,MAAM,CAAC;AACvE,UAAI,IAAI,SAAS,KAAK,IAAI,QAAQ,QAAQ,KAAK,IAAI,aAAa,MAAM,CAAC;AAEvE,eAAS,IAAI;AACb,eAAS,IAAI;AAAA,IACjB;AAAA,EACJ;AAAA,EAEA,WAAW,WAA6B;AACpC,QAAI,OAAO,KAAK,MAAM,KAAK,OAAO,IAAI,GAAK;AAC3C,QAAI,UAAU,IAAI,aAAa,IAAI;AAEnC,QAAI,iBAAiB;AACrB,QAAI,+BAA+B;AACnC,QAAI,kBAAkB;AACtB,QAAI,eAAe;AACnB,QAAI,iBAAiB;AACrB,QAAI,yBAAyB;AAG7B,aAAS,IAAI,GAAG,IAAI,iBAAiB,KAAK;AACtC,eAAS,MAAM,GAAE,MAAM,UAAU,QAAQ,OAAQ;AAC7C,YAAI,WAAW,UAAU;AACzB,YAAI,MAAM;AACV,YAAI,MAAM;AACV,YAAI,MAAM,SAAS,IAAI;AACvB,YAAI,MAAM,SAAS,IAAI;AAEvB,YAAI,aAAa,QAAQ,QAAQ,KAAM,GAAG;AAG1C,iBAAS,MAAM,GAAG,MAAM,8BAA8B,OAAQ;AAE1D,cAAI,QAAQ,MAAM,KAAK,KAAK;AAC5B,cAAI,OAAO,KAAK,IAAI,KAAK;AACzB,cAAI,OAAO,KAAK,IAAI,KAAK;AACzB,cAAI,gBAAgB,QAAQ,QAAQ,MAAM,OAAO,gBAAgB,MAAM,OAAO,cAAc;AAE5F,kBAAQ,aAAa,iBAAkB;AACvC,kBAAQ,aAAa,iBAAkB;AAAA,QAC3C;AAGA,iBAAS,KAAK,MAAM,yBAAyB,KAAK,OAAO;AACzD,iBAAS,KAAK,MAAM,yBAAyB,KAAK,OAAO;AAAA,MAC7D;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,aAAa,WAA6B;AACtC,QAAI,QAAQ,KACR,QAAQ,MACR,YAAY,KACZ,OAAO;AAEX,WAAO,QAAO;AACV,eAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,YAAI,YAAY,UAAU;AAE1B,iBAAS,KAAK,KAAK,GAAI,KAAK,UAAU,QAAQ,MAAM;AAChD,cAAI,YAAY,UAAU;AAE1B,cAAI,KAAK,UAAU,IAAI,UAAU;AACjC,cAAI,KAAK,UAAU,IAAI,UAAU;AAEjC,cAAI,WAAW,KAAK,MAAM,IAAI,EAAE;AAEhC,cAAI,WAAW,OAAO;AAClB,gBAAI,MAAM,KAAK;AACf,gBAAI,MAAM,KAAK;AAEf,gBAAI,UAAU,MAAM,KAAK,IAAI,WAAW,QAAQ,QAAQ;AACxD,gBAAI,UAAU,MAAM,KAAK,IAAI,WAAW,QAAQ,QAAQ;AAExD,sBAAU,IAAI,UAAU,IAAI;AAC5B,sBAAU,IAAI,UAAU,IAAI;AAC5B,sBAAU,IAAI,UAAU,IAAI;AAC5B,sBAAU,IAAI,UAAU,IAAI;AAAA,UAChC;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,QAAQ,MAAM,WAAmC;AAG7C,QAAI,WAAW,KAAK,UAAU,UAAU;AACxC,QAAI,UAAU,KAAK,UAAU,UAAU;AACvC,QAAI,SAAS,KAAK,UAAU,UAAU;AAEtC,QAAI,gBAAgB;AAEpB,QAAI;AAEJ,OAAG;AACC,aAAO,KAAK,MAAM,KAAK,UAAU,SAAS,CAAC;AAE3C,UAAI,SAAS,KAAK,gBAAgB,IAAI;AAEtC,UAAI,SAAS,OAAO;AACpB,UAAI,SAAS,OAAO;AAEpB,UAAI,UAAU,OAAO,OAAO,OAAO;AACnC,UAAI,UAAU,OAAO,OAAO,OAAO;AAEnC,UAAI,QAAQ;AAEZ,UAAI,UAAU,SAAS;AACnB,gBAAS,WAAY;AAAA,MACzB,OAAO;AACH,gBAAQ,UAAU;AAAA,MACtB;AAEA,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAClC,YAAI,WAAW,KAAK;AACpB,YAAI,QAAQ,SAAS,UAAU,UAAU,SAAS,UAAU,WAAW,SAAS,UAAU,WAAW;AAErG,YAAI,YAAY,SAAS,IAAI,UAAU,QAAQ,OAAO;AACtD,YAAI,YAAY,SAAS,IAAI,UAAU,QAAQ,OAAO;AAEtD,iBAAS,IAAI;AACb,iBAAS,IAAI;AAAA,MACjB;AAEA,iBAAW;AACX,kBAAY;AAEZ,sBAAgB,KAAK,mBAAmB,MAAM,IAAI;AAAA,IACtD,SAAS,CAAC;AAEV,WAAO;AAAA,EACX;AAAA,EAEA,mBAAmB,MAAM,WAAgC;AAErD,QAAI,UACA,UAAU,OAAO,CAAC,KAAK,MAAM,MAAM,KAAK,gBAAgB,6BAA6B,GAAG,SAAS,GAAG,CAAC,IAC/F,UAAU;AAEpB,WAAO,WAAW,KAAK,UAAU,UAAU,0BAA0B;AAAA,EACzE;AAAA,EAEA,gBAAgB,WAAyC;AACrD,QAAI,QAAQ,GACR,QAAQ,GACR,QAAQ,GACR,QAAQ;AAEZ,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACvC,UAAI,WAAW,UAAU;AAEzB,cAAQ,KAAK,IAAI,OAAO,SAAS,CAAC;AAClC,cAAQ,KAAK,IAAI,OAAO,SAAS,CAAC;AAClC,cAAQ,KAAK,IAAI,OAAO,SAAS,CAAC;AAClC,cAAQ,KAAK,IAAI,OAAO,SAAS,CAAC;AAAA,IACtC;AAEA,WAAO;AAAA,MACH,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,IACV;AAAA,EACJ;AAEJ;AAAC;",
  "names": []
}
