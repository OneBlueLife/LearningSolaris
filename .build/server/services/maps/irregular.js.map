{
  "version": 3,
  "sources": ["../../../../server/services/maps/irregular.ts"],
  "sourcesContent": ["const randomSeeded = require('random-seed');\nconst simplexNoise = require('simplex-noise');\nimport ValidationError from '../../errors/validation';\nimport { GameResourceDistribution } from '../types/Game';\nimport { Location } from '../types/Location';\nimport DistanceService from '../distance';\nimport GameTypeService from '../gameType';\nimport RandomService from '../random';\nimport ResourceService from '../resource';\nimport StarService from '../star';\nimport StarDistanceService from '../starDistance';\n\nexport default class IrregularMapService {\n\n    randomService: RandomService;\n    starService: StarService;\n    starDistanceService: StarDistanceService;\n    distanceService: DistanceService;\n    resourceService: ResourceService;\n    gameTypeService: GameTypeService;\n\n    constructor(\n        randomService: RandomService,\n        starService: StarService,\n        starDistanceService: StarDistanceService,\n        distanceService: DistanceService,\n        resourceService: ResourceService,\n        gameTypeService: GameTypeService) {\n        this.randomService = randomService;\n        this.starService = starService;\n        this.starDistanceService = starDistanceService;\n        this.distanceService = distanceService;\n        this.resourceService = resourceService;\n        this.gameTypeService = gameTypeService;\n    }\n    \n    //TODO this is generator agnostic and could be on a base class or service\n    _moveLocationTowards(location: Location, towards: Location, minDistance: number) {\n        let dx = towards.x - location.x;\n        let dy = towards.y - location.y;\n        let dist = this.distanceService.getDistanceBetweenLocations(location, towards);\n        if (dist < minDistance) { return; }\n        let amount = 1.0-(minDistance/dist);\n        location.x += dx*amount;\n        location.y += dy*amount;\n    }\n\n    //TODO this is generator agnostic and could be on a base class or service\n    _removeLocationFromArray(array, location) {\n        let index = array.indexOf(location);\n        array.splice(index, 1);\n    }\n\n\n    //TODO this is generator agnostic and could be on a base class or service\n    _rotatedLocation(location: Location, angle: number) {\n        return {\n          x: Math.cos(angle)*location.x + Math.sin(angle)*location.y,\n          y: Math.sin(angle)*-location.x + Math.cos(angle)*location.y\n        };\n    }\n\n    \n    //TODO this is generator agnostic and could be on a base class or service\n    _displacedLocation(location1: Location, location2: Location) {\n        return {\n            x: location1.x + location2.x,\n            y: location1.y + location2.y,\n        };\n    }\n\n    // get how many rings of stars will be necessary to have at least starPerPlayerMin stars per player\n    // then try to use as many rings as possible without going over starPerPlayerMax amount of stars per player\n    _getRingCount(starsPerPlayerMin: number, starsPerPlayerMax: number) {\n      let ringCount = this._getNecessaryRingCount(starsPerPlayerMin) + 1\n      while(this._getStarCountInRings(ringCount)<starsPerPlayerMax) {\n        ringCount += 1 \n      }\n      return ringCount-1 // -1 since the current count is actually 1 above\n    }\n\n    // get how many stars per player will be generated by using ringCount number of rings\n    _getStarCountInRings(ringCount: number) {\n        let starCount = 0;\n        let ringIndex = 0;\n        let lastRingPruning = 0;\n        while(ringIndex<ringCount) {\n            starCount += lastRingPruning; // refill the last ring with the pruned stars since this ring is no longer the last one\n            starCount += 6+(ringIndex*6); // each ring on a hexagonal grid will have this amount of stars, this is not tweakable\n            // last ring(outer ring) will actually have less stars. this is to ensure a perfect hexagonal tiling withouth any stars overlapping, values are not tweakable\n            lastRingPruning = 4 + ( (ringIndex*6)/2 );\n            starCount -= lastRingPruning;\n            ringIndex += 1;\n        }\n        return starCount;\n    }\n\n    // get how many rings of stars  will be necessary to have at least starsPerPlayer stars generated per player\n    _getNecessaryRingCount(starsPerPlayer: number) {\n        let starCount = 0;\n        let ringIndex = 0;\n        let lastRingPruning = 0;\n        while(starCount<starsPerPlayer) {\n            starCount += lastRingPruning;\n            starCount += 6+(ringIndex*6);\n            lastRingPruning = 4 + ( (ringIndex*6)/2 );\n            starCount -= lastRingPruning;\n            ringIndex += 1;\n        }\n        return ringIndex;\n    }\n\n    _generateHomeLocations(pivotDistance: number, playerCount: number, rng, simplexNoiseGenerator, noiseSpread: number) {\n        const ONE_SIXTH = 1.0/6.0;\n        const TAU = 2.0*Math.PI;\n\n        let homeLocations: Location[] = [];\n        let firstLocation = { \n            x: 0.0,\n            y: 0.0\n        };\n\n        homeLocations.push(firstLocation);\n\n        while(homeLocations.length<playerCount) {\n            let position;\n            let positionIsValid = false;\n            let attempts = 0;\n            while(!positionIsValid) {\n                let baseLocation = homeLocations[rng.range(homeLocations.length)];\n                let pivot = { x: pivotDistance, y: 0.0 };\n                let pivotRotation = ONE_SIXTH*TAU * rng.range(6);\n                pivot = this._rotatedLocation(pivot, pivotRotation);\n                pivot = this._displacedLocation(baseLocation, pivot);\n                \n                position = { x: pivotDistance, y: 0.0 };\n                let rotation;\n                if(rng.random()<0.5) {\n                    rotation = pivotRotation - (ONE_SIXTH*TAU);\n                }\n                else{\n                    rotation = pivotRotation + (ONE_SIXTH*TAU);\n                }\n                position = this._rotatedLocation(position, rotation);\n                position = this._displacedLocation(position, pivot);\n                position.noiseIntensity = simplexNoiseGenerator.noise2D(position.x/noiseSpread, position.y/noiseSpread);\n\n                positionIsValid = true;\n                for( let homeLocation of homeLocations ) {\n                    if( this.distanceService.getDistanceBetweenLocations(position, homeLocation) < pivotDistance ) {\n                        positionIsValid = false;\n                        break;\n                    }\n                    if( (position.noiseIntensity>0.65 ) && (attempts<6) ) { \n                        positionIsValid = false;\n                        attempts += 1;\n                        break;\n                    }\n                }\n            }\n            homeLocations.push(position);\n        }\n        \n        return homeLocations;\n    }\n\n    _generateSupplementaryHomeLocations(pivotDistance: number, homeLocations: Location[]) {\n        const ONE_SIXTH = 1.0/6.0;\n        const TAU = 2.0*Math.PI;\n\n        let supplementaryHomeLocations: Location[] = [];\n\n        for( let homeLocation of homeLocations ) {\n            for(let i = 0; i<6; i++) {\n                let pivot = { x: pivotDistance, y: 0.0 };\n                let pivotRotation = ONE_SIXTH*TAU * i;\n                pivot = this._rotatedLocation(pivot, pivotRotation);\n                pivot = this._displacedLocation(homeLocation, pivot);\n\n                let position = { x: pivotDistance, y: 0.0 };\n                let rotation = (ONE_SIXTH*TAU) * (i+1)\n                position = this._rotatedLocation(position, rotation);\n                position = this._displacedLocation(pivot, position);\n                \n                let isValidPosiiton = true;\n                for( let homeLocation of homeLocations ) {\n                    if(this.distanceService.getDistanceBetweenLocations(homeLocation, position) < pivotDistance) {\n                        isValidPosiiton = false;\n                    }\n                }\n                for( let supplementaryHomeLocation of supplementaryHomeLocations ) {\n                    if(this.distanceService.getDistanceBetweenLocations(supplementaryHomeLocation, position) < pivotDistance) {\n                        isValidPosiiton = false;\n                    }\n                }\n                if(isValidPosiiton) {\n                    supplementaryHomeLocations.push( position );\n                }\n            }\n        }\n        return supplementaryHomeLocations;\n    }\n    \n    //populates the given `locations` array with new locations around the `baseLocation`\n    //locations are created in hexagonal rings around the base locations, respecting a triangular grid\n    _generateConcentricHexRingsLocations(baseLocation: Location, ringCount: number, distance: number, locations: Location[]) {\n        const ONE_SIXTH = 1.0/6.0;\n        const TAU = 2.0*Math.PI;\n        \n        for(let ringIndex = 0; ringIndex < ringCount; ringIndex++) {\n            for(let sliceIndex = 0; sliceIndex < 6; sliceIndex++) {\n                if( (ringIndex==(ringCount-1))&&(sliceIndex<3) ) { continue; } //only create the first 3 edges of the outer ring\n\n                let position = { x: distance+(distance*ringIndex), y: 0.0 };\n                let rotation = sliceIndex * ONE_SIXTH*TAU;\n                position = this._rotatedLocation(position, rotation);\n                position = this._displacedLocation(baseLocation, position);\n\n                if( (ringIndex!=(ringCount-1))||(sliceIndex==3)||(sliceIndex==4) ) {\n                    //only add 2 of the corner stars for the last ring\n                    locations.push(position);\n                }\n\n                for(let i = 0; i < ringIndex; i++ ) {\n                    let edgePosition = { x: distance*(i+1), y: 0.0 };\n                    let edgeRotation = (sliceIndex+2) * (ONE_SIXTH*TAU);\n                    edgePosition = this._rotatedLocation(edgePosition, edgeRotation);\n                    edgePosition = this._displacedLocation(position, edgePosition);\n                    locations.push(edgePosition);\n                }\n            }\n        }\n    }\n\n    _randomlyDislocateLocations(locations: Location[], threshold: number, rng) {\n        const ONE_SIXTH = 1.0/6.0;\n        const TAU = 2.0*Math.PI;\n        for( let location of locations ) {\n            let amount = (3.0*(threshold/4.0)) + ((rng.random()*threshold)/4.0); // 0.75 to 1.0 times the threshold\n            let rotation = rng.random()*TAU\n            let dislocation = { x: amount, y: 0.0 };\n            dislocation = this._rotatedLocation(dislocation, rotation);\n            let newLocation = this._displacedLocation(location, dislocation);\n            //cant set location directly\n            location.x = newLocation.x;\n            location.y = newLocation.y;\n        }\n    }\n\n    _pruneLocationsWithNoise(locations: Location[], desiredLocationCount: number, simplexNoiseGenerator, noiseSpread: number) {\n        for( let location of locations ) {\n            (location as any).noiseIntensity = simplexNoiseGenerator.noise2D(location.x/noiseSpread, location.y/noiseSpread);\n        }\n        locations.sort( (loc1, loc2) => {\n            return ((loc1 as any).noiseIntensity-(loc2 as any).noiseIntensity);\n        });\n        locations.splice(desiredLocationCount);\n    }\n\n    //removes locations outside the metaball composed of home locations\n    //locations have a chance of beeing removed based on the distance from the metaball\n    _pruneLocationsOutsideMetaball(locations: Location[], homeLocations: Location[], homeStarRadius: number, rng) {\n        const METABALL_FALLOFF = 8.0; //higher values reduces the spread of the metaball\n        // probably better not to remove items while iterating, so add to this array instead\n        let toRemove: Location[] = [];\n        for( let location of locations ) {\n            let metaballFieldIntensity = 0;\n            for( let homeLocation of homeLocations ) {\n                let distance = this.distanceService.getDistanceBetweenLocations(homeLocation, location);\n                distance = homeStarRadius/distance;\n                metaballFieldIntensity += Math.pow(distance, METABALL_FALLOFF);\n            }\n            let chanceToRemove = 1.0-metaballFieldIntensity;\n            if(rng.random()<chanceToRemove) {\n                toRemove.push(location);\n            }\n        }\n        for( let location of toRemove ) {\n            this._removeLocationFromArray(locations, location);\n        }\n\n    }\n\n    generateLocations(game, starCount: number, resourceDistribution: GameResourceDistribution, playerCount: number): Location[] {\n        if (this.gameTypeService.isKingOfTheHillMode(game)) {\n            throw new ValidationError(`King of the hill is not supported in irregular maps.`);\n        }\n\n        const SEED = ( Math.random()*(10**8) ).toFixed(0);\n        const SPREAD = 2.5\n        const RNG = randomSeeded.create(SEED);\n        const SIMPLEX_NOISE = new simplexNoise(SEED);\n        const NOISE_BASE_SPREAD = 32.0;\n        //const NOISE_SPREAD = NOISE_BASE_SPREAD * Math.sqrt(starCount*1.3);// try to make the noise spread with the size of the galaxy. this makes the void gaps also proportional to galaxy size. \n        //const NOISE_SPREAD = 512; //optionally could keep the voids constant in size, no matter the galaxy size\n        const TAU = 2.0*Math.PI;\n        const STARS_PER_PLAYER = starCount/playerCount;\n        const INITIAL_HYPER_RANGE = game.settings.technology.startingTechnologyLevel.hyperspace;\n        const STARTING_STAR_COUNT = game.settings.player.startingStars-1;\n        const MINIMUM_STAR_DISTANCE = game.constants.distances.minDistanceBetweenStars * 0.75; // TODO: This is a bit of a bodge to ensure that stars do not spawn too far away from players.\n\n        const NOISE_SPREAD = NOISE_BASE_SPREAD * ( (STARS_PER_PLAYER+20)/9.0 )\n       \n        //the amount of rings must produce about 30% more stars then requested. this way they can be pruned latter with noise to produce nice gap\n        const STAR_COUNT_MULTIPLYER = 1.3;\n        const RING_COUNT = this._getRingCount(STARS_PER_PLAYER, (STARS_PER_PLAYER*STAR_COUNT_MULTIPLYER));\n        const STAR_DISTANCE = MINIMUM_STAR_DISTANCE*SPREAD;\n        const STAR_DISLOCATION_THRESHOLD = MINIMUM_STAR_DISTANCE*((SPREAD-1.0)/2.0);\n        const PIVOT_DISTANCE = RING_COUNT*STAR_DISTANCE;\n\n        let locations: Location[] = [];\n        let homeLocations = this._generateHomeLocations(PIVOT_DISTANCE, playerCount, RNG, SIMPLEX_NOISE, NOISE_SPREAD);\n        let supplementaryHomeLocations = this._generateSupplementaryHomeLocations(PIVOT_DISTANCE, homeLocations);\n        let baseLocations = [];\n        let supplementaryLocations = [];\n\n        \n        for( let homeLocation of homeLocations ) {\n            this._generateConcentricHexRingsLocations( homeLocation, RING_COUNT, STAR_DISTANCE, baseLocations );\n        }\n        for( let supplementaryHomeLocation of supplementaryHomeLocations ) {\n            this._generateConcentricHexRingsLocations( supplementaryHomeLocation, RING_COUNT, STAR_DISTANCE, supplementaryLocations );\n        }\n\n        locations = locations.concat(baseLocations, supplementaryLocations);\n\n        this._pruneLocationsOutsideMetaball(locations, homeLocations, PIVOT_DISTANCE, RNG);\n        this._randomlyDislocateLocations(locations, STAR_DISLOCATION_THRESHOLD, RNG);\n        this._pruneLocationsWithNoise( locations, (starCount-playerCount), SIMPLEX_NOISE, NOISE_SPREAD );\n\n        \n        \n        //------------------------------------------------------------------------------------------\n\n        //TODO move the selecting star logic to its own function that is mapgen agnostic\n        //TODO move the pulling star logic --/--\n\n        for(let homeLocation of homeLocations) {\n            (homeLocation as any).homeStar = true;\n            (homeLocation as any).linkedLocations = [];\n        }\n\n\n        let unlinkedLocations = locations.filter( (loc) => { return true;} );\n        let startingStarsCount = STARTING_STAR_COUNT;\n\n        while(startingStarsCount--) {\n            for(let homeLocation of homeLocations) {\n                let closestUnlinkedLocation = this.distanceService.getClosestLocation(homeLocation, unlinkedLocations) as any;\n                (homeLocation as any).linkedLocations.push(closestUnlinkedLocation);\n                closestUnlinkedLocation.linked = true;\n                unlinkedLocations = unlinkedLocations.filter( (loc) => { return loc !== closestUnlinkedLocation; } );\n            }\n        }\n\n        // pull the closest stars that will be linked so they are in hyper range\n        let minimumClaimDistance = this.distanceService.getHyperspaceDistance(game, INITIAL_HYPER_RANGE)-2;//-2 to avoid floating point imprecisions\n\n        for(let homeLocation of homeLocations) {\n            let reachableLocations: Location[] = [];\n            let unreachebleLocations: Location[] = [];\n\n            reachableLocations.push(homeLocation);\n            \n            for(let location of (homeLocation as any).linkedLocations) {\n                unreachebleLocations.push(location);\n            }\n\n            while( unreachebleLocations.length > 0) {\n                //find the unreachable location that is closer to any of the reachable locations\n                for(let unreachebleLocation of unreachebleLocations) {\n                    let distanceToClosestReachable;\n                    let closestReachableLocation;\n                    let smallestDistance = Number.MAX_VALUE;\n                    \n                    for(let reachableLocation of reachableLocations) {\n                        let distance = this.distanceService.getDistanceBetweenLocations(unreachebleLocation, reachableLocation);\n                        \n                        if (distance < smallestDistance ) { \n                            smallestDistance = distance;\n                            distanceToClosestReachable = distance;\n                            closestReachableLocation = reachableLocation;\n                        }\n                    }\n\n                    (unreachebleLocation as any).distanceToClosestReachable = distanceToClosestReachable;\n                    (unreachebleLocation as any).closestReachable = closestReachableLocation;\n                }\n\n                let closestUnreachable = unreachebleLocations[0];\n\n                for (let unreachebleLocation of unreachebleLocations) {\n                    if ((unreachebleLocation as any).distanceToClosestReachable < (closestUnreachable as any).distanceToClosestReachable) {\n                        closestUnreachable = unreachebleLocation;\n                    }\n                }\n\n                this._moveLocationTowards(closestUnreachable, (closestUnreachable as any).closestReachable, minimumClaimDistance);\n                \n                // after moving closer we can change the location from the unreachable to the reachable array\n                unreachebleLocations.splice(unreachebleLocations.indexOf(closestUnreachable), 1);\n                reachableLocations.push(closestUnreachable);\n            }\n\n            //now all linked stars should be reachable\n        }\n\n        locations = locations.concat(homeLocations);\n\n        this.resourceService.distribute(game, locations, resourceDistribution);\n        \n        return locations;\n    }\n};\n\n"],
  "mappings": "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",
  "names": ["homeLocation", "ValidationError"]
}
