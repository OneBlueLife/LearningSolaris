{
  "version": 3,
  "sources": ["../../../../server/services/maps/doughnut.ts"],
  "sourcesContent": ["import ValidationError from '../../errors/validation';\nimport { GameResourceDistribution } from '../types/Game';\nimport { Location } from '../types/Location';\nimport DistanceService from '../distance';\nimport GameTypeService from '../gameType';\nimport RandomService from '../random';\nimport ResourceService from '../resource';\nimport StarService from '../star';\nimport StarDistanceService from '../starDistance';\n\nexport default class DoughnutMapService {\n\n    randomService: RandomService;\n    starService: StarService;\n    starDistanceService: StarDistanceService;\n    distanceService: DistanceService;\n    resourceService: ResourceService;\n    gameTypeService: GameTypeService;\n\n    constructor(\n        randomService: RandomService,\n        starService: StarService,\n        starDistanceService: StarDistanceService,\n        distanceService: DistanceService,\n        resourceService: ResourceService,\n        gameTypeService: GameTypeService) {\n        this.randomService = randomService;\n        this.starService = starService;\n        this.starDistanceService = starDistanceService;\n        this.distanceService = distanceService;\n        this.resourceService = resourceService;\n        this.gameTypeService = gameTypeService;\n    }\n\n    generateLocations(game, starCount: number, resourceDistribution: GameResourceDistribution): Location[] {\n        if (this.gameTypeService.isKingOfTheHillMode(game)) {\n            throw new ValidationError(`King of the hill is not supported in doughnut maps.`);\n        }\n\n        // The starDensity constant can really be a setting, once it is turned into an intuitive variable...\n        const starDensity = 1.3 * 10**-4;\n        const maxRadius = ((4 * starCount) / (3 * Math.PI * starDensity))**0.5;\n        const locations: Location[] = [];\n\n        // Generating locations for each star on the map\n        do {\n            // Try and find a suitable position for star X\n            while(true) {\n                let location = this.randomService.getRandomPositionInDoughnut(0.5*maxRadius, maxRadius);\n\n                if (!this.isLocationTooCloseToOthers(game, location, locations)) {\n                    locations.push(location)\n                    break;\n                }\n            }\n\n        } while(locations.length < starCount)\n\n        // Giving each star its resources\n        this.resourceService.distribute(game, locations, resourceDistribution);\n\n        return locations;\n    }\n\n    isLocationTooCloseToOthers(game, location: Location, locations: Location[]): boolean {\n        // Return False if there are no stars in range, True if there is a star in range\n        return locations.find(l => this.starDistanceService.isLocationTooClose(game, location, l)) != null;\n    }\n\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAA4B;AAU5B,MAAO,mBAAiC;AAAA,EASpC,YACI,eACA,aACA,qBACA,iBACA,iBACA,iBAAkC;AAClC,SAAK,gBAAgB;AACrB,SAAK,cAAc;AACnB,SAAK,sBAAsB;AAC3B,SAAK,kBAAkB;AACvB,SAAK,kBAAkB;AACvB,SAAK,kBAAkB;AAAA,EAC3B;AAAA,EAEA,kBAAkB,MAAM,WAAmB,sBAA4D;AACnG,QAAI,KAAK,gBAAgB,oBAAoB,IAAI,GAAG;AAChD,YAAM,IAAI,kBAAAA,QAAgB,qDAAqD;AAAA,IACnF;AAGA,UAAM,cAAc,MAAM,MAAI;AAC9B,UAAM,aAAc,IAAI,aAAc,IAAI,KAAK,KAAK,iBAAe;AACnE,UAAM,YAAwB,CAAC;AAG/B,OAAG;AAEC,aAAM,MAAM;AACR,YAAI,WAAW,KAAK,cAAc,4BAA4B,MAAI,WAAW,SAAS;AAEtF,YAAI,CAAC,KAAK,2BAA2B,MAAM,UAAU,SAAS,GAAG;AAC7D,oBAAU,KAAK,QAAQ;AACvB;AAAA,QACJ;AAAA,MACJ;AAAA,IAEJ,SAAQ,UAAU,SAAS;AAG3B,SAAK,gBAAgB,WAAW,MAAM,WAAW,oBAAoB;AAErE,WAAO;AAAA,EACX;AAAA,EAEA,2BAA2B,MAAM,UAAoB,WAAgC;AAEjF,WAAO,UAAU,KAAK,OAAK,KAAK,oBAAoB,mBAAmB,MAAM,UAAU,CAAC,CAAC,KAAK;AAAA,EAClG;AAEJ;AAAC;",
  "names": ["ValidationError"]
}
