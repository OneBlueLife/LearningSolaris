{
  "version": 3,
  "sources": ["../../../../server/services/maps/circularBalanced.ts"],
  "sourcesContent": ["const RNG = require('random-seed');\nimport ValidationError from '../../errors/validation';\nimport { GameResourceDistribution } from '../types/Game';\nimport { Location } from \"../types/Location\";\nimport DistanceService from \"../distance\";\nimport GameTypeService from \"../gameType\";\nimport RandomService from \"../random\";\nimport ResourceService from \"../resource\";\nimport StarService from \"../star\";\nimport StarDistanceService from \"../starDistance\";\n\nexport default class CircularBalancedMapService {\n\n    randomService: RandomService;\n    starService: StarService;\n    starDistanceService: StarDistanceService;\n    distanceService: DistanceService;\n    resourceService: ResourceService;\n    gameTypeService: GameTypeService;\n\n    constructor(\n        randomService: RandomService,\n        starService: StarService,\n        starDistanceService: StarDistanceService,\n        distanceService: DistanceService,\n        resourceService: ResourceService,\n        gameTypeService: GameTypeService) {\n        this.randomService = randomService;\n        this.starService = starService;\n        this.starDistanceService = starDistanceService;\n        this.distanceService = distanceService;\n        this.resourceService = resourceService;\n        this.gameTypeService = gameTypeService;\n    }\n\n    _generateStarPositionInSector(currentRadius: number, rng, playerCount: number) {\n        const tau = 2.0*Math.PI;\n        let angle = rng.random()*(tau/playerCount);\n        //let angle = (tau/playerCount);\n        let posx = 0;\n        let posy = currentRadius/2.0 + rng.random()*(currentRadius*2.0);\n\n        return {\n          x: Math.cos(angle)*posx + Math.sin(angle)*posy,\n          y: Math.sin(angle)*-posx + Math.cos(angle)*posy,\n          linked: false\n        };\n    }\n\n    _getRotatedLocation(location: Location, angle: number) {\n        return {\n          x: Math.cos(angle)*location.x + Math.sin(angle)*location.y,\n          y: Math.sin(angle)*-location.x + Math.cos(angle)*location.y,\n          homeStar: null,\n          distanceToClosestReachable: null,\n          closestReachable: null,\n          linkedLocations: []\n        };\n    }\n\n    _moveLocationTowards(location, towards, minDistance: number) {\n        let dx = towards.x - location.x;\n        let dy = towards.y - location.y;\n        let dist = this.distanceService.getDistanceBetweenLocations(location, towards);\n        if (dist < minDistance) { return; }\n        let amount = 1.0-(minDistance/dist);\n        location.x += dx*amount;\n        location.y += dy*amount;\n    }\n\n    generateLocations(game, starCount: number, resourceDistribution: GameResourceDistribution, playerCount: number): Location[] {\n        if (this.gameTypeService.isKingOfTheHillMode(game)) {\n            throw new ValidationError(`King of the hill is not supported in circular balanced maps.`);\n        }\n\n        const locations: any[] = [];\n        let seed = ( Math.random()*(10**8) ).toFixed(0);\n        const rng = RNG.create(seed); //TODO get seed from player\n        const tau = 2.0*Math.PI;\n        \n        let currentRadius = game.constants.distances.minDistanceBetweenStars;\n        let radiusStep = game.constants.distances.minDistanceBetweenStars;\n        let maxTries = 2;\n        let sectorAngle = tau/playerCount;\n\n        do {\n            let createdLocations = false;\n\n            // Try to find a set of locations X number of times.\n            // if a location is rejected, all locations on this set are rejected aswell\n            // otherwise, all are accepted\n            // this garantees that evey sector is identical\n            for (let i = 0; i < maxTries; i++) {\n                let candidateLocations: any[] = [];\n                let baseLocation = this._generateStarPositionInSector(currentRadius, rng, playerCount);\n                let locationRejected = false;\n\n                for (let sectorIndex = 0; sectorIndex<playerCount; sectorIndex++) {\n                  let location = this._getRotatedLocation(baseLocation, sectorIndex*sectorAngle);\n\n                  // Stars must not be too close to eachother.\n                  if ((this.isLocationTooCloseToOthers(game, location, locations)) ||\n                    (this.isLocationTooCloseToOthers(game, location, candidateLocations)) ) {\n                      locationRejected = true;\n                      break;\n                  }\n\n                  candidateLocations.push(location);\n                }\n\n                if (locationRejected) { continue; }\n\n                locations.push(...candidateLocations);\n                createdLocations = true;\n                break;\n            }\n\n            // If we didn't find a valid location, increase radius.\n            if (!createdLocations) {\n                currentRadius += radiusStep;\n            }\n        } while (locations.length < starCount);\n\n        // choose home stars\n\n        // The desired distance from the center is half way from the galaxy center and the edge.\n        const distanceFromCenter = this.starDistanceService.getMaxGalaxyDiameter(locations) / 2 / 2;\n        let playerAngle = (sectorAngle/2.0);//take a location from the middle of the sector\n        let desiredLocation = this._getRotatedLocation({x: 0.0, y: distanceFromCenter}, playerAngle);\n        let firstHomeLocation = this.distanceService.getClosestLocation(desiredLocation, locations);\n        let firstHomeLocationIndex = locations.indexOf(firstHomeLocation);\n\n        for(let i=0; i<playerCount; i++) {\n            let locationIndex = (firstHomeLocationIndex+i);\n            locations[locationIndex].homeStar = true;\n        }\n        \n        let homeLocations = locations.filter( (location) => { return location.homeStar; } );\n        let initialHyperRange = game.settings.technology.startingTechnologyLevel.hyperspace;\n        let startingStarsCount = game.settings.player.startingStars-1;\n\n        for(let homeLocation of homeLocations) {\n            homeLocation.linkedLocations = [];\n        }\n\n        let unlinkedLocations = locations.filter( (loc) => { return !loc.homeStar;} );\n\n        while(startingStarsCount--) {\n            for(let homeLocation of homeLocations) {\n                let closestUnlinkedLocation = this.distanceService.getClosestLocation(homeLocation, unlinkedLocations) as any;\n                homeLocation.linkedLocations.push(closestUnlinkedLocation);\n                closestUnlinkedLocation.linked = true;\n                unlinkedLocations = unlinkedLocations.filter( (loc) => { return loc !== closestUnlinkedLocation; } );\n            }\n        }\n\n        // pull the closest stars that will be linked so they are in hyper range\n        let minimumClaimDistance = this.distanceService.getHyperspaceDistance(game, initialHyperRange)-2;//-2 to avoid floating point imprecisions\n\n        for(let homeLocation of homeLocations) {\n            let reachableLocations: any[] = [];\n            let unreachebleLocations: any[] = [];\n\n            reachableLocations.push(homeLocation);\n            \n            for(let location of homeLocation.linkedLocations) {\n                unreachebleLocations.push(location);\n            }\n\n            while( unreachebleLocations.length > 0) {\n                //find the unreachable location that is closer to any of the reachable locations\n                for(let unreachebleLocation of unreachebleLocations) {\n                    let distanceToClosestReachable;\n                    let closestReachableLocation;\n                    let smallestDistance = Number.MAX_VALUE;\n                    \n                    for(let reachableLocation of reachableLocations) {\n                        let distance = this.distanceService.getDistanceBetweenLocations(unreachebleLocation, reachableLocation);\n                        \n                        if (distance < smallestDistance ) { \n                            smallestDistance = distance;\n                            distanceToClosestReachable = distance;\n                            closestReachableLocation = reachableLocation;\n                        }\n                    }\n\n                    unreachebleLocation.distanceToClosestReachable = distanceToClosestReachable;\n                    unreachebleLocation.closestReachable = closestReachableLocation;\n                }\n\n                let closestUnreachable = unreachebleLocations[0];\n\n                for (let unreachebleLocation of unreachebleLocations) {\n                    if (unreachebleLocation.distanceToClosestReachable! < closestUnreachable.distanceToClosestReachable!) {\n                        closestUnreachable = unreachebleLocation;\n                    }\n                }\n\n                this._moveLocationTowards(closestUnreachable, closestUnreachable.closestReachable!, minimumClaimDistance);\n                \n                // after moving closer we can change the location from the unreachable to the reachable array\n                unreachebleLocations.splice(unreachebleLocations.indexOf(closestUnreachable), 1);\n                reachableLocations.push(closestUnreachable);\n            }\n\n            //now all linked stars should be reachable\n        }\n\n        this.resourceService.distribute(game, locations, resourceDistribution);\n\n        return locations;\n    }\n\n    isLocationTooCloseToOthers(game, location: Location, locations: Location[]): boolean {\n        return locations.find(l => this.starDistanceService.isLocationTooClose(game, location, l)) != null;\n    }\n\n};\n\n"],
  "mappings": "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",
  "names": ["ValidationError"]
}
