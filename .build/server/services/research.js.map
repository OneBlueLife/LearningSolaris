{
  "version": 3,
  "sources": ["../../../server/services/research.ts"],
  "sourcesContent": ["const EventEmitter = require('events');\nimport ValidationError from '../errors/validation';\nimport Repository from './repository';\nimport { Game } from './types/Game';\nimport { Player, ResearchType, ResearchTypeNotRandom } from './types/Player';\nimport { User } from './types/User';\nimport GameTypeService from './gameType';\nimport PlayerStatisticsService from './playerStatistics';\nimport RandomService from './random';\nimport StarService from './star';\nimport TechnologyService from './technology';\nimport UserService from './user';\n\nexport const ResearchServiceEvents = {\n    onPlayerResearchCompleted: 'onPlayerResearchCompleted'\n}\n\nexport default class ResearchService extends EventEmitter {\n    gameRepo: Repository<Game>;\n    technologyService: TechnologyService;\n    randomService: RandomService;\n    playerStatisticsService: PlayerStatisticsService;\n    starService: StarService;\n    userService: UserService;\n    gameTypeService: GameTypeService;\n\n    constructor(\n        gameRepo: Repository<Game>,\n        technologyService: TechnologyService,\n        randomService: RandomService,\n        playerStatisticsService: PlayerStatisticsService,\n        starService: StarService,\n        userService: UserService,\n        gameTypeService: GameTypeService\n    ) {\n        super();\n        \n        this.gameRepo = gameRepo;\n        this.technologyService = technologyService;\n        this.randomService = randomService;\n        this.playerStatisticsService = playerStatisticsService;\n        this.starService = starService;\n        this.userService = userService;\n        this.gameTypeService = gameTypeService;\n    }\n\n    async updateResearchNow(game: Game, player: Player, preference: ResearchTypeNotRandom) {\n        if (!this.technologyService.isTechnologyEnabled(game, preference)\n            || !this.technologyService.isTechnologyResearchable(game, preference)) {\n            throw new ValidationError(`Cannot change technology, the chosen tech is not researchable.`);\n        }\n\n        player.researchingNow = preference;\n\n        await this.gameRepo.updateOne({\n            _id: game._id,\n            'galaxy.players._id': player._id\n        }, {\n            $set: {\n                'galaxy.players.$.researchingNow': preference\n            }\n        });\n\n        let ticksEta = this.calculateCurrentResearchETAInTicks(game, player);\n        let ticksNextEta = this.calculateNextResearchETAInTicks(game, player);\n        \n        return {\n            ticksEta,\n            ticksNextEta\n        };\n    }\n\n    async updateResearchNext(game: Game, player: Player, preference: ResearchType) {\n        if (preference !== 'random' &&\n            (!this.technologyService.isTechnologyEnabled(game, preference) ||\n            !this.technologyService.isTechnologyResearchable(game, preference))) {\n            throw new ValidationError(`Cannot change technology, the chosen tech is not researchable.`);\n        }\n\n        player.researchingNext = preference;\n\n        await this.gameRepo.updateOne({\n            _id: game._id,\n            'galaxy.players._id': player._id\n        }, {\n            $set: {\n                'galaxy.players.$.researchingNext': preference\n            }\n        });\n\n        let ticksEta = this.calculateCurrentResearchETAInTicks(game, player);\n        let ticksNextEta = this.calculateNextResearchETAInTicks(game, player);\n        \n        return {\n            ticksEta,\n            ticksNextEta\n        };\n    }\n\n    async conductResearch(game: Game, user: User | null, player: Player) {\n        let techKey = player.researchingNow;\n        let tech = player.research[techKey];\n\n        if (!this.technologyService.isTechnologyEnabled(game, techKey) || \n            !this.technologyService.isTechnologyResearchable(game, techKey)) {\n            return null;\n        }\n\n        let playerStars = this.starService.listStarsOwnedByPlayer(game.galaxy.stars, player._id);\n\n        let totalScience = this.playerStatisticsService.calculateTotalScience(playerStars);\n        let multiplier = game.constants.research.sciencePointMultiplier;\n        let progressIncrease = Math.floor(totalScience * multiplier);\n\n        tech.progress! += progressIncrease;\n\n        // If the player isn't being controlled by AI then increment achievements.\n        if (user && !player.defeated && !this.gameTypeService.isTutorialGame(game)) {\n            user.achievements.research[techKey] += progressIncrease;\n        }\n\n        // If the current progress is greater than the required progress\n        // then increase the level and carry over the remainder.\n        let requiredProgress = this.getRequiredResearchProgress(game, techKey, tech.level);\n\n        let levelUp = false;\n\n        while (tech.progress! >= requiredProgress) {\n            tech.level++;\n            tech.progress! -= requiredProgress;\n            \n            requiredProgress = this.getRequiredResearchProgress(game, techKey, tech.level);\n            levelUp = true\n        }\n\n        if (levelUp) {\n            this._setNextResearch(game, player);\n\n            this.emit(ResearchServiceEvents.onPlayerResearchCompleted, {\n                gameId: game._id,\n                gameTick: game.state.tick,\n                playerId: player._id,\n                technologyKey: techKey,\n                technologyLevel: tech.level,\n                technologyKeyNext: player.researchingNow,\n                technologyLevelNext: player.research[player.researchingNow].level + 1\n            });\n        }\n\n        let currentResearchTicksEta = this.calculateCurrentResearchETAInTicks(game, player);\n        let nextResearchTicksEta = this.calculateNextResearchETAInTicks(game, player);\n\n        let report = {\n            name: techKey,\n            level: tech.level,\n            progress: tech.progress,\n            levelUp,\n            currentResearchTicksEta,\n            nextResearchTicksEta\n        }\n        \n        return report;\n    }\n\n    async conductResearchAll(game: Game, gameUsers: User[]) {\n        // Add the current level of experimentation to the current \n        // tech being researched.\n        for (let i = 0; i < game.galaxy.players.length; i++) {\n            let player = game.galaxy.players[i];\n\n            let user = gameUsers.find(u => player.userId && u._id.toString() === player.userId.toString()) || null;\n            \n            await this.conductResearch(game, user, player);\n        }\n    }\n\n    getRequiredResearchProgress(game: Game, technologyKey: ResearchTypeNotRandom, technologyLevel: number) {\n        const researchCostConfig = game.settings.technology.researchCosts[technologyKey];\n        const expenseCostConfig = game.constants.star.infrastructureExpenseMultipliers[researchCostConfig];\n        const progressMultiplierConfig = expenseCostConfig * game.constants.research.progressMultiplier;\n\n        return technologyLevel * progressMultiplierConfig;\n    }\n\n    conductExperiments(game: Game, player: Player) {\n        // NOTE: Experiments do not count towards player research achievements.\n        // Check if experimentation is enabled.\n        let isExperimentationEnabled = this.technologyService.isTechnologyEnabled(game, 'experimentation');\n        \n        const noExperimentation = {\n            technology: null,\n            level: null,\n            amount: null,\n            levelUp: null,\n            researchingNext: null\n        };\n\n        if (!isExperimentationEnabled) {\n            return noExperimentation;\n        }\n\n        // NOTE: Players must own stars in order to have experiments.\n        let playerStars = this.starService.listStarsOwnedByPlayer(game.galaxy.stars, player._id);\n\n        if (!playerStars.length) {\n            return noExperimentation;\n        }\n\n        let tech = this._getRandomTechnology(game, player);\n\n        if (!tech) {\n            return noExperimentation;\n        }\n        \n        let techLevel = player.research.experimentation.level;\n        let progressMultiplier = game.constants.research.progressMultiplier;\n        let experimentationMultiplier = game.constants.research.experimentationMultiplier;\n        let researchAmount;\n\n        switch (game.settings.technology.experimentationReward) {\n            case 'standard':\n                researchAmount = Math.floor(techLevel * (progressMultiplier * experimentationMultiplier));\n                break;\n            case 'experimental':\n                let totalScience = this.playerStatisticsService.calculateTotalScience(playerStars);\n                researchAmount = Math.floor((techLevel * (progressMultiplier * experimentationMultiplier)) + (0.15 * techLevel * totalScience));\n                break;\n            default:\n                throw new Error(`Unsupported experimentation reward ${game.settings.technology.experimentationReward}`);\n        }\n        \n        tech.technology.progress! += researchAmount;\n\n        // If the current progress is greater than the required progress\n        // then increase the level and carry over the remainder.\n        let requiredProgress = this.getRequiredResearchProgress(game, tech.key, tech.technology.level);\n\n        let levelUp = false;\n        let researchingNext;\n\n        while (tech.technology.progress! >= requiredProgress) {\n            tech.technology.level++;\n            tech.technology.progress! -= requiredProgress;\n            requiredProgress = this.getRequiredResearchProgress(game, tech.key, tech.technology.level);\n            levelUp = true;\n        }\n\n        // If the technology leveled up, we need to change the research\n        // to the next desired research technology.\n        if (levelUp && tech.key === player.researchingNow) {\n            this._setNextResearch(game, player);\n            researchingNext = player.researchingNext\n        }\n\n        return {\n            technology: tech.key,\n            level: tech.technology.level,\n            amount: researchAmount,\n            levelUp,\n            researchingNext \n        };\n    }\n\n    _setNextResearch(game: Game, player: Player) {\n        if (player.researchingNext === player.researchingNow) {\n            return;\n        }\n\n        if (player.researchingNext === 'random') {\n            let randomTech = this._getRandomTechnology(game, player);\n\n            if (randomTech) {\n                player.researchingNow = randomTech.key;\n            }\n        } else {\n            player.researchingNow = player.researchingNext;\n        }\n\n        return player.researchingNow;\n    }\n\n    _getRandomTechnology(game: Game, player: Player) {\n        let techs = Object.keys(player.research).filter(k => {\n            return k.match(/^[^_\\$]/) != null;\n        }) as ResearchTypeNotRandom[];\n\n        techs = techs.filter(t => this.technologyService.isTechnologyEnabled(game, t)\n                                && this.technologyService.isTechnologyResearchable(game, t));\n\n        if (!techs.length) {\n            return null;\n        }\n\n        let researchTechsCount = techs.length;\n\n        let techKey = techs[this.randomService.getRandomNumber(researchTechsCount - 1)] as ResearchTypeNotRandom;\n        let tech = player.research[techKey];\n\n        return {\n            key: techKey,\n            technology: tech\n        };\n    }\n\n    calculateCurrentResearchETAInTicks(game: Game, player: Player) {\n        return this._calculateResearchETAInTicks(game, player, player.researchingNow);\n    }\n\n    calculateNextResearchETAInTicks(game: Game, player: Player) {\n        if (player.researchingNext === 'random') {\n          return null;\n        }\n\n        if (player.researchingNow !== player.researchingNext) {\n            let currentResearchTicksEta = this.calculateCurrentResearchETAInTicks(game, player);\n            let nextResearchTicksEta = this._calculateResearchETAInTicks(game, player, player.researchingNext);\n\n            if (currentResearchTicksEta == null || nextResearchTicksEta == null) {\n                return null;\n            }\n\n            return currentResearchTicksEta + nextResearchTicksEta;\n        }\n\n        return this.calculateDoubleIdenticalResearchETAInTicks(game, player)\n      }\n\n    _calculateResearchETAInTicks(game: Game, player: Player, researchKey: ResearchType) {\n        if (researchKey === 'random') {\n            return null;\n        }\n\n        let tech = player.research[researchKey];\n\n        let requiredProgress = this.getRequiredResearchProgress(game, researchKey, tech.level);\n        let remainingPoints = requiredProgress - tech.progress!;\n\n        return this._calculateResearchETAInTicksByRemainingPoints(game, player, remainingPoints);\n    }\n\n    calculateDoubleIdenticalResearchETAInTicks(game: Game, player: Player)  {        \n        let tech = player.research[player.researchingNow];\n        \n        let requiredProgress = this.getRequiredResearchProgress(game, player.researchingNow, tech.level) \n                             + this.getRequiredResearchProgress(game, player.researchingNow, tech.level + 1);\n        let remainingPoints = requiredProgress - tech.progress!;\n\n        return this._calculateResearchETAInTicksByRemainingPoints(game, player, remainingPoints);\n    }\n\n    _calculateResearchETAInTicksByRemainingPoints(game: Game, player: Player, remainingPoints: number) {\n        let playerStars = this.starService.listStarsOwnedByPlayer(game.galaxy.stars, player._id);\n        let totalScience = this.playerStatisticsService.calculateTotalScience(playerStars);\n        \n        // If there is no science then there cannot be an end date to the research.\n        if (totalScience === 0) {\n            return null;\n        }\n        \n        return Math.ceil(remainingPoints / totalScience);\n    }\n};\n"],
  "mappings": "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",
  "names": ["ValidationError"]
}
