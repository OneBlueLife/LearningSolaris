{
  "version": 3,
  "sources": ["../../../server/services/trade.ts"],
  "sourcesContent": ["const EventEmitter = require('events');\nconst moment = require('moment');\nimport { DBObjectId } from './types/DBObjectId';\nimport ValidationError from '../errors/validation';\nimport Repository from './repository';\nimport { Game } from './types/Game';\nimport { GameEvent } from './types/GameEvent';\nimport { Player, PlayerReputation, ResearchTypeNotRandom } from './types/Player';\nimport { TradeEvent, TradeEventTechnology, TradeTechnology } from './types/Trade';\nimport AchievementService from './achievement';\nimport GameTypeService from './gameType';\nimport DiplomacyService from './diplomacy';\nimport LedgerService, { LedgerType } from './ledger';\nimport PlayerService from './player';\nimport ReputationService from './reputation';\nimport UserService from './user';\nimport { User } from './types/User';\nimport RandomService from './random';\nimport PlayerCreditsService from './playerCredits';\nimport PlayerAfkService from './playerAfk';\n\nexport const TradeServiceEvents = {\n    onPlayerCreditsReceived: 'onPlayerCreditsReceived',\n    onPlayerCreditsSent: 'onPlayerCreditsSent',\n    onPlayerCreditsSpecialistsReceived: 'onPlayerCreditsSpecialistsReceived',\n    onPlayerCreditsSpecialistsSent: 'onPlayerCreditsSpecialistsSent',\n    onPlayerRenownReceived: 'onPlayerRenownReceived',\n    onPlayerRenownSent: 'onPlayerRenownSent',\n    onPlayerTechnologyReceived: 'onPlayerTechnologyReceived',\n    onPlayerTechnologySent: 'onPlayerTechnologySent'\n}\n\nexport default class TradeService extends EventEmitter {\n    gameRepo: Repository<Game>;\n    eventRepo: Repository<GameEvent>;\n    userService: UserService;\n    playerService: PlayerService;\n    diplomacyService: DiplomacyService;\n    ledgerService: LedgerService;\n    achievementService: AchievementService;\n    reputationService: ReputationService;\n    gameTypeService: GameTypeService;\n    randomService: RandomService;\n    playerCreditsService: PlayerCreditsService;\n    playerAfkService: PlayerAfkService;\n\n    constructor(\n        gameRepo: Repository<Game>,\n        eventRepo: Repository<GameEvent>,\n        userService: UserService,\n        playerService: PlayerService,\n        diplomacyService: DiplomacyService,\n        ledgerService: LedgerService,\n        achievementService: AchievementService,\n        reputationService: ReputationService,\n        gameTypeService: GameTypeService,\n        randomService: RandomService,\n        playerCreditsService: PlayerCreditsService,\n        playerAfkService: PlayerAfkService\n    ) {\n        super();\n\n        this.gameRepo = gameRepo;\n        this.eventRepo = eventRepo;\n        this.userService = userService;\n        this.playerService = playerService;\n        this.diplomacyService = diplomacyService;\n        this.ledgerService = ledgerService;\n        this.achievementService = achievementService;\n        this.reputationService = reputationService;\n        this.gameTypeService = gameTypeService;\n        this.randomService = randomService;\n        this.playerCreditsService = playerCreditsService;\n        this.playerAfkService = playerAfkService;\n    }\n\n    isTradingCreditsDisabled(game: Game) {\n        return game.settings.player.tradeCredits === false;\n    }\n\n    isTradingAllyRestricted(game: Game) {\n        return this.diplomacyService.isFormalAlliancesEnabled(game) && this.diplomacyService.isTradeRestricted(game);\n    }\n\n    isTradingCreditsSpecialistsDisabled(game: Game) {\n        return game.settings.player.tradeCreditsSpecialists === false;\n    }\n\n    isTradingTechnologyDisabled(game: Game) {\n        return game.settings.player.tradeCost === 0;\n    }\n\n    async sendCredits(game: Game, fromPlayer: Player, toPlayerId: DBObjectId, amount: number) {\n        if (this.isTradingCreditsDisabled(game)) {\n            throw new ValidationError(`Trading credits is disabled.`);\n        }\n\n        // TODO: Maybe this validation needs to be in the middleware?\n        if (!game.state.startDate) {\n            throw new ValidationError(`Cannot trade credits, the game has not started yet.`);\n        }\n\n        if (amount <= 0) {\n            throw new ValidationError(`Amount must be greater than 0.`);\n        }\n\n        // Get the players.\n        let toPlayer: Player = this.playerService.getById(game, toPlayerId)!;\n\n        if (fromPlayer === toPlayer) {\n            throw new ValidationError(`Cannot send credits to yourself.`);\n        }\n\n        if (this.isTradingAllyRestricted(game) &&\n            this.diplomacyService.getDiplomaticStatusToPlayer(game, fromPlayer._id, toPlayerId).actualStatus !== 'allies') {\n            throw new ValidationError(`You are only allowed to trade with allies.`);\n        }\n\n        this._tradeScanningCheck(game, fromPlayer, toPlayer);\n\n        if (fromPlayer.credits < amount) {\n            throw new ValidationError(`You do not own ${amount} credits.`);\n        }\n\n        let dbWrites = [\n            await this.playerCreditsService.addCredits(game, fromPlayer, -amount, false),\n            await this.playerCreditsService.addCredits(game, toPlayer, amount, false)\n        ];\n\n        await this.gameRepo.bulkWrite(dbWrites);\n\n        await this.ledgerService.addDebt(game, fromPlayer, toPlayer, amount, LedgerType.Credits);\n\n        if (!this.gameTypeService.isTutorialGame(game)) {\n            if (fromPlayer.userId && !fromPlayer.defeated) {\n                await this.achievementService.incrementTradeCreditsSent(fromPlayer.userId, amount);\n            }\n\n            if (toPlayer.userId && !toPlayer.defeated) {\n                await this.achievementService.incrementTradeCreditsReceived(toPlayer.userId, amount);\n            }\n        }\n\n        let reputationResult = await this.reputationService.tryIncreaseReputationCredits(game, toPlayer, fromPlayer, amount);\n\n        if (reputationResult.increased) {\n            await this.tryTradeBack(game, toPlayer, fromPlayer, reputationResult.rep.reputation);\n        }\n\n        let eventObject = {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            fromPlayer,\n            toPlayer,\n            amount,\n            reputation: reputationResult.rep.reputation,\n            date: moment().utc()\n        };\n\n        this.emit(TradeServiceEvents.onPlayerCreditsReceived, eventObject);\n        this.emit(TradeServiceEvents.onPlayerCreditsSent, eventObject);\n\n        return eventObject;\n    }\n\n    async sendCreditsSpecialists(game: Game, fromPlayer: Player, toPlayerId: DBObjectId, amount: number) {\n        if (this.isTradingCreditsSpecialistsDisabled(game)) {\n            throw new ValidationError(`Trading specialist tokens is disabled.`);\n        }\n\n        // TODO: Maybe this validation needs to be in the middleware?\n        if (!game.state.startDate) {\n            throw new ValidationError(`Cannot trade specialist tokens, the game has not started yet.`);\n        }\n\n        if (amount <= 0) {\n            throw new ValidationError(`Amount must be greater than 0.`);\n        }\n\n        // Get the players.\n        let toPlayer: Player = this.playerService.getById(game, toPlayerId)!;\n\n        if (fromPlayer === toPlayer) {\n            throw new ValidationError(`Cannot send specialist tokens to yourself.`);\n        }\n\n        if (this.isTradingAllyRestricted(game) &&\n            this.diplomacyService.getDiplomaticStatusToPlayer(game, fromPlayer._id, toPlayerId).actualStatus !== 'allies') {\n            throw new ValidationError(`You are only allowed to trade with allies.`);\n        }\n\n        this._tradeScanningCheck(game, fromPlayer, toPlayer);\n\n        if (fromPlayer.creditsSpecialists < amount) {\n            throw new ValidationError(`You do not own ${amount} specialist tokens.`);\n        }\n\n        let dbWrites = [\n            await this.playerCreditsService.addCreditsSpecialists(game, fromPlayer, -amount, false),\n            await this.playerCreditsService.addCreditsSpecialists(game, toPlayer, amount, false)\n        ];\n\n        await this.gameRepo.bulkWrite(dbWrites);\n\n        await this.ledgerService.addDebt(game, fromPlayer, toPlayer, amount, LedgerType.CreditsSpecialists);\n\n        if (!this.gameTypeService.isTutorialGame(game)) {\n            if (fromPlayer.userId && !fromPlayer.defeated) {\n                await this.achievementService.incrementTradeCreditsSpecialistsSent(fromPlayer.userId, amount);\n            }\n\n            if (toPlayer.userId && !toPlayer.defeated && toPlayer.userId) {\n                await this.achievementService.incrementTradeCreditsSpecialistsReceived(toPlayer.userId, amount);\n            }\n        }\n\n        let reputationResult = await this.reputationService.tryIncreaseReputationCreditsSpecialists(game, toPlayer, fromPlayer, amount);\n\n        if (reputationResult.increased) {\n            await this.tryTradeBack(game, toPlayer, fromPlayer, reputationResult.rep.reputation);\n        }\n\n        let eventObject = {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            fromPlayer,\n            toPlayer,\n            amount,\n            reputation: reputationResult.rep.reputation,\n            date: moment().utc()\n        };\n\n        this.emit(TradeServiceEvents.onPlayerCreditsSpecialistsReceived, eventObject);\n        this.emit(TradeServiceEvents.onPlayerCreditsSpecialistsSent, eventObject);\n\n        return eventObject;\n    }\n\n    async sendRenown(game: Game, fromPlayer: Player, toPlayerId: DBObjectId, amount: number) {\n        // TODO: Maybe this validation needs to be in the middleware?\n        if (!game.state.startDate) {\n            throw new ValidationError(`Cannot award renown, the game has not started yet.`);\n        }\n\n        if (amount <= 0) {\n            throw new ValidationError(`Amount must be greater than 0.`);\n        }\n\n        // If its a anonymous game, then do not allow renown to be sent until the game ends.\n        if (game.settings.general.anonymity === 'extra' && !game.state.endDate) {\n            throw new ValidationError(`Renown cannot be sent to players in anonymous games until the game has finished.`);\n        }\n\n        // Get the players.\n        let toPlayer: Player = this.playerService.getById(game, toPlayerId)!;\n\n        if (fromPlayer === toPlayer) {\n            throw new ValidationError(`Cannot award renown to yourself.`);\n        }\n\n        if (fromPlayer.renownToGive < amount) {\n            throw new ValidationError(`You do not have ${amount} renown to award.`);\n        }\n\n        if (!toPlayer.userId) {\n            throw new ValidationError(`Cannot award renown to an empty slot.`);\n        }\n\n        // The receiving player has to be a legit user otherwise\n        // renown should not be sent. It's possible that players can delete their accounts.\n        let toUser: User | null = await this.userService.getById(toPlayer.userId);\n\n        if (!toUser) {\n            throw new ValidationError(`There is no user associated with this player.`);\n        }\n\n        // Note: AI will never ever send renown so no need to check\n        // if players are AI controlled here.\n        await this.gameRepo.updateOne({\n            _id: game._id,\n            'galaxy.players._id': fromPlayer._id\n        }, {\n            $inc: {\n                'galaxy.players.$.renownToGive': -amount\n            }\n        });\n\n        if (!this.gameTypeService.isTutorialGame(game)) {\n            if (fromPlayer.userId) {\n                await this.achievementService.incrementRenownSent(fromPlayer.userId, amount);\n            }\n\n            if (toPlayer.userId) {\n                await this.achievementService.incrementRenownReceived(toPlayer.userId, amount);\n            }\n        }\n\n        let eventObject = {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            fromPlayer,\n            toPlayer,\n            amount,\n            date: moment().utc()\n        };\n\n        this.emit(TradeServiceEvents.onPlayerRenownReceived, eventObject);\n        this.emit(TradeServiceEvents.onPlayerRenownSent, eventObject);\n\n        return eventObject;\n    }\n\n    async sendTechnology(game: Game, fromPlayer: Player, toPlayerId: DBObjectId, technology: ResearchTypeNotRandom, techLevel: number) {\n        if (this.isTradingTechnologyDisabled(game)) {\n            throw new ValidationError(`Trading technology is disabled.`);\n        }\n\n        // Get the players.\n        let toPlayer: Player = this.playerService.getById(game, toPlayerId)!;\n\n        if (fromPlayer === toPlayer) {\n            throw new ValidationError(`Cannot trade technology with yourself.`);\n        }\n\n        if (this.isTradingAllyRestricted(game) &&\n            this.diplomacyService.getDiplomaticStatusToPlayer(game, fromPlayer._id, toPlayerId).actualStatus !== 'allies') {\n            throw new ValidationError(`You are only allowed to trade with allies.`);\n        }\n\n        this._tradeScanningCheck(game, fromPlayer, toPlayer);\n\n        let tradeTechs = this.listTradeableTechnologies(game, fromPlayer, toPlayerId);\n\n        let tradeTech = tradeTechs.find(t => t.name === technology && t.level === techLevel);\n\n        if (!tradeTech) {\n            throw new ValidationError(`The technology ${technology} cannot be traded with this player.`);\n        }\n\n        let toPlayerTech = toPlayer.research[tradeTech.name];\n\n        if (toPlayerTech.level >= tradeTech.level) {\n            throw new ValidationError(`The recipient already owns technology ${technology} level ${tradeTech.level} or greater.`);\n        }\n\n        if (fromPlayer.credits < tradeTech.cost) {\n            throw new ValidationError(`You cannot afford to trade this technology.`);\n        }\n\n        let levelDifference = tradeTech.level - toPlayerTech.level;\n\n        // toPlayerTech.level = tradeTech.level;\n        // toPlayerTech.progress = 0;\n        // fromPlayer.credits -= tradeTech.cost;\n\n        let updateResearchQuery = {};\n        updateResearchQuery['galaxy.players.$.research.' + tradeTech.name + '.level'] = tradeTech.level;\n        updateResearchQuery['galaxy.players.$.research.' + tradeTech.name + '.progress'] = 0;\n\n        let dbWrites = [\n            await this.playerCreditsService.addCredits(game, fromPlayer, -tradeTech.cost, false),\n            {\n                updateOne: {\n                    filter: {\n                        _id: game._id,\n                        'galaxy.players._id': toPlayer._id\n                    },\n                    update: updateResearchQuery\n                }\n            }\n        ];\n\n        await this.gameRepo.bulkWrite(dbWrites);\n\n        await this.ledgerService.addDebt(game, fromPlayer, toPlayer, tradeTech.cost, LedgerType.Credits);\n\n        if (!this.gameTypeService.isTutorialGame(game)) {\n            // Need to assert that the trading players aren't controlled by AI\n            // and the player user has an account.\n            if (toPlayer.userId && !toPlayer.defeated) {\n                await this.achievementService.incrementTradeTechnologyReceived(toPlayer.userId, 1);\n            }\n\n            if (fromPlayer.userId && !fromPlayer.defeated) {\n                await this.achievementService.incrementTradeTechnologySent(fromPlayer.userId, 1);\n            }\n        }\n\n        let eventTechnology: TradeEventTechnology = {\n            name: tradeTech.name,\n            level: tradeTech.level,\n            difference: levelDifference\n        };\n\n        let reputationResult = await this.reputationService.tryIncreaseReputationTechnology(game, toPlayer, fromPlayer, eventTechnology);\n\n        if (reputationResult.increased) {\n            await this.tryTradeBack(game, toPlayer, fromPlayer, reputationResult.rep.reputation);\n        }\n\n        let eventObject = {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            fromPlayer,\n            toPlayer,\n            technology: eventTechnology,\n            reputation: reputationResult.rep.reputation,\n            date: moment().utc()\n        };\n\n        this.emit(TradeServiceEvents.onPlayerTechnologyReceived, eventObject);\n        this.emit(TradeServiceEvents.onPlayerTechnologySent, eventObject);\n\n        return eventObject;\n    }\n\n    listTradeableTechnologies(game: Game, fromPlayer: Player, toPlayerId: DBObjectId) {\n        if (this.isTradingTechnologyDisabled(game)) {\n            return [];\n        }\n\n        // Get the players.\n        let toPlayer: Player = this.playerService.getById(game, toPlayerId)!;\n\n        if (fromPlayer._id.toString() === toPlayer._id.toString()) {\n            throw new ValidationError('Cannot trade with the same player');\n        }\n\n        // Get all of the technologies that the from player has that have a higher\n        // level than the to player.\n        let techKeys: ResearchTypeNotRandom[] = Object.keys(fromPlayer.research)\n            .filter(k => {\n                return k.match(/^[^_\\$]/) != null;\n            }) as ResearchTypeNotRandom[];\n\n        let tradeTechs: TradeTechnology[] = [];\n\n        for (let i = 0; i < techKeys.length; i++) {\n            let techKey = techKeys[i];\n            let techFromPlayer = fromPlayer.research[techKey];\n            let techToPlayer = toPlayer.research[techKey];\n\n            let techLevel = techFromPlayer.level\n\n            while (techLevel > techToPlayer.level) {\n                tradeTechs.push({\n                    name: techKey,\n                    level: techLevel,\n                    cost: techLevel * game.settings.player.tradeCost\n                });\n\n                techLevel--;\n            }\n        }\n\n        return tradeTechs;\n    }\n\n    _tradeScanningCheck(game: Game, fromPlayer: Player, toPlayer: Player) {\n        if (game.settings.player.tradeScanning === 'scanned') {\n            let isInRange = this.playerService.isInScanningRangeOfPlayer(game, fromPlayer, toPlayer);\n\n            if (!isInRange) {\n                throw new ValidationError(`You cannot trade with this player, they are not within scanning range.`);\n            }\n        }\n    }\n\n    async listTradeEventsBetweenPlayers(game: Game, playerId: DBObjectId, playerIds: DBObjectId[]): Promise<TradeEvent[]> {\n        let events = await this.eventRepo.find({\n            gameId: game._id,\n            playerId: playerId,\n            type: {\n                $in: [\n                    'playerCreditsReceived',\n                    'playerCreditsSpecialistsReceived',\n                    'playerRenownReceived',\n                    'playerTechnologyReceived',\n                    'playerGiftReceived',\n                    'playerCreditsSent',\n                    'playerCreditsSpecialistsSent',\n                    'playerRenownSent',\n                    'playerTechnologySent',\n                    'playerGiftSent',\n                    'playerDebtSettled',\n                    'playerDebtForgiven'\n                ]\n            },\n            $or: [\n                { 'data.fromPlayerId': { $in: playerIds } },\n                { 'data.toPlayerId': { $in: playerIds } },\n                {\n                    $and: [\n                        { 'data.debtorPlayerId': { $in: playerIds } },\n                        { 'data.creditorPlayerId': { $in: playerIds } }\n                    ]\n                }\n            ]\n        });\n\n        return events\n        .map(e => {\n            return {\n                playerId: e.playerId!,\n                type: e.type,\n                data: e.data,\n                sentDate: moment(e._id.getTimestamp()) as Date,\n                sentTick: e.tick\n            }\n        });\n    }\n\n    async tryTradeBack(game: Game, fromPlayer: Player, toPlayer: Player, reputation: PlayerReputation) {\n        // Note: Trade backs can only occur from AI to player\n        if (!this.playerAfkService.isAIControlled(game, fromPlayer, true)) {\n            return;\n        }\n\n        const TRADE_CHANCE_BASE = 50;\n        const TRADE_CHANCE_STEP = 5;\n        const TRADE_CHANCE_MIN_REPUTATION = 1;\n\n        if (reputation.score < TRADE_CHANCE_MIN_REPUTATION) {\n            return;\n        }\n\n        let tradeChance = TRADE_CHANCE_BASE + (TRADE_CHANCE_STEP * reputation.score);\n        let tradeRoll = this.randomService.getRandomNumber(100);\n        let canPerformTrade = tradeRoll <= tradeChance || true;\n\n        if (!canPerformTrade) {\n            return;\n        }\n        \n        // TODO: Consider scanning range trade setting.\n\n        // Get the differences in tech levels between the two players that the AI can afford.\n        let tradeTechs = await this.listTradeableTechnologies(game, fromPlayer, toPlayer._id);\n\n        tradeTechs = tradeTechs.filter(t => t.cost <= fromPlayer.credits);\n\n        if (!tradeTechs.length) {\n            return;\n        }\n\n        // Pick a random tech(?) and send it to the player.\n        let tradeTech = tradeTechs[this.randomService.getRandomNumber(tradeTechs.length - 1)];\n        \n        await this.sendTechnology(game, fromPlayer, toPlayer._id, tradeTech.name, tradeTech.level);\n    }\n\n};\n"],
  "mappings": "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",
  "names": ["ValidationError"]
}
