{
  "version": 3,
  "sources": ["../../../server/services/carrierMovement.ts"],
  "sourcesContent": ["import Repository from './repository';\nimport { Carrier } from './types/Carrier';\nimport { CarrierWaypoint } from './types/CarrierWaypoint';\nimport { Game } from './types/Game';\nimport { Player } from './types/Player';\nimport { Star } from './types/Star';\nimport { User } from './types/User';\nimport CarrierGiftService from './carrierGift';\nimport DiplomacyService from './diplomacy';\nimport DistanceService from './distance';\nimport SpecialistService from './specialist';\nimport StarService from './star';\n\nexport default class CarrierMovementService {\n    gameRepo: Repository<Game>;\n    distanceService: DistanceService;\n    starService: StarService;\n    specialistService: SpecialistService;\n    diplomacyService: DiplomacyService;\n    carrierGiftService: CarrierGiftService;\n\n    constructor(\n        gameRepo: Repository<Game>,\n        distanceService: DistanceService,\n        starService: StarService,\n        specialistService: SpecialistService,\n        diplomacyService: DiplomacyService,\n        carrierGiftService: CarrierGiftService\n    ) {\n        this.gameRepo = gameRepo;\n        this.distanceService = distanceService;\n        this.starService = starService;\n        this.specialistService = specialistService;\n        this.diplomacyService = diplomacyService;\n        this.carrierGiftService = carrierGiftService;\n    }\n\n    getCarrierDistancePerTick(game: Game, carrier: Carrier, warpSpeed: boolean = false, instantSpeed: boolean | null = false) {\n        if (instantSpeed) {\n            return null;\n        }\n\n        let distanceModifier = warpSpeed ? game.constants.distances.warpSpeedMultiplier : 1;\n\n        if (carrier.specialistId) {\n            let specialist = this.specialistService.getByIdCarrier(carrier.specialistId);\n\n            if (specialist && specialist.modifiers.local) {\n                distanceModifier *= (specialist.modifiers.local.speed || 1);\n            }\n        }\n\n        return game.settings.specialGalaxy.carrierSpeed * distanceModifier;\n    }\n\n    moveCarrierToCurrentWaypoint(carrier: Carrier, destinationStar: Star, distancePerTick: number) {\n        let nextLocation = this.distanceService.getNextLocationTowardsLocation(carrier.location, destinationStar.location, distancePerTick);\n\n        carrier.location = nextLocation;\n    }\n\n    async arriveAtStar(game: Game, gameUsers: User[], carrier: Carrier, destinationStar: Star) {\n        // Remove the current waypoint as we have arrived at the destination.\n        let currentWaypoint = carrier.waypoints.splice(0, 1)[0];\n\n        let report = {\n            waypoint: currentWaypoint,\n            combatRequiredStar: false\n        };\n\n        carrier.orbiting = destinationStar._id;\n        carrier.location = destinationStar.location;\n\n        // If the carrier waypoints are looped then append the\n        // carrier waypoint back onto the waypoint stack.\n        if (carrier.waypointsLooped) {\n            carrier.waypoints.push(currentWaypoint);\n        }\n\n        // If the star is unclaimed, then claim it.\n        // TODO: Move this logic out of this function so that carrier movement will correctly\n        // take into account multiple players arriving at an unclaimed star at the same time.\n        if (destinationStar.ownedByPlayerId == null) {\n            await this.starService.claimUnownedStar(game, gameUsers, destinationStar, carrier);\n        }\n\n        // Reignite dead stars if applicable\n        // Note: Black holes cannot be reignited.\n        if (!carrier.isGift && this.starService.isDeadStar(destinationStar) && this.specialistService.getReigniteDeadStar(carrier)) {\n            let reigniteSpecialistNaturalResources = this.specialistService.getReigniteDeadStarNaturalResources(carrier);\n\n            // Double resourches for binary stars.\n            let modifier = destinationStar.isBinaryStar ? 2 : 1\n            let reigniteNaturalResources = {\n                economy: reigniteSpecialistNaturalResources.economy * modifier,\n                industry: reigniteSpecialistNaturalResources.industry * modifier,\n                science: reigniteSpecialistNaturalResources.science * modifier\n            };\n            \n            this.starService.reigniteDeadStar(game, destinationStar, reigniteNaturalResources);\n\n            carrier.specialistId = null;\n        }\n\n        // If the star is owned by another player, then perform combat.\n        if (destinationStar.ownedByPlayerId!.toString() !== carrier.ownedByPlayerId!.toString()) {\n            // If the carrier is a gift, then transfer the carrier ownership to the star owning player.\n            // Otherwise, perform combat.\n            if (carrier.isGift) {\n                await this.carrierGiftService.transferGift(game, gameUsers, destinationStar, carrier);\n            } else if (this.diplomacyService.isFormalAlliancesEnabled(game)) {\n                let isAllied = this.diplomacyService.isDiplomaticStatusBetweenPlayersAllied(game, [carrier.ownedByPlayerId!, destinationStar.ownedByPlayerId!]);\n\n                report.combatRequiredStar = !isAllied;\n            } else {\n                report.combatRequiredStar = true;\n            }\n        } else {\n            // Make sure the carrier gift is reset if the star is owned by the same player.\n            carrier.isGift = false;\n        }\n\n        return report;\n    }\n\n    async moveCarrier(game: Game, gameUsers: User[], carrierInTransit: Carrier) {\n        let waypoint: CarrierWaypoint = carrierInTransit.waypoints[0];\n\n        if (waypoint.delayTicks) {\n            throw new Error(`Cannot move carrier, the waypoint has a delay.`);\n        }\n\n        if (this.isLaunching(carrierInTransit)) {\n            waypoint.source = carrierInTransit.orbiting!; // Make damn sure the waypoint source is correct.\n\n            // If the destination star is not the current one, then launch the carrier into space.\n            if (carrierInTransit.orbiting!.toString() !== waypoint.destination.toString()) {\n                carrierInTransit.orbiting = null;\n            }\n        }\n\n        let sourceStar = game.galaxy.stars.find(s => s._id.toString() === waypoint.source.toString())!;\n        let destinationStar = game.galaxy.stars.find(s => s._id.toString() === waypoint.destination.toString())!;\n        let carrierOwner = game.galaxy.players.find(p => p._id.toString() === carrierInTransit.ownedByPlayerId!.toString())!;\n        let warpSpeed = this.canTravelAtWarpSpeed(game, carrierOwner, carrierInTransit, sourceStar, destinationStar);\n        let instantSpeed = this.starService.isStarPairWormHole(sourceStar, destinationStar);\n        let distancePerTick = this.getCarrierDistancePerTick(game, carrierInTransit, warpSpeed, instantSpeed); // Null signifies instant travel\n\n        let carrierMovementReport = {\n            carrier: carrierInTransit,\n            sourceStar,\n            destinationStar,\n            carrierOwner,\n            warpSpeed,\n            instantSpeed,\n            distancePerTick,\n            waypoint,\n            combatRequiredStar: false,\n            arrivedAtStar: false\n        };\n        \n        if (instantSpeed || (distancePerTick && (carrierInTransit.distanceToDestination || 0) <= distancePerTick)) {\n            let starArrivalReport = await this.arriveAtStar(game, gameUsers, carrierInTransit, destinationStar);\n            \n            carrierMovementReport.waypoint = starArrivalReport.waypoint;\n            carrierMovementReport.combatRequiredStar = starArrivalReport.combatRequiredStar;\n            carrierMovementReport.arrivedAtStar = true;\n        }\n        // Otherwise, move X distance in the direction of the star.\n        else {\n            this.moveCarrierToCurrentWaypoint(carrierInTransit, destinationStar, distancePerTick!);\n        }\n\n        return carrierMovementReport;\n    }\n\n    getNextLocationToWaypoint(game: Game, carrier: Carrier) {\n        let waypoint = carrier.waypoints[0];\n        let sourceStar = game.galaxy.stars.find(s => s._id.toString() === waypoint.source.toString())!;\n        let destinationStar = game.galaxy.stars.find(s => s._id.toString() === waypoint.destination.toString())!;\n        let carrierOwner = game.galaxy.players.find(p => p._id.toString() === carrier.ownedByPlayerId!.toString())!;\n\n        let warpSpeed = false;\n        let instantSpeed: boolean | null = false;\n        \n        if (sourceStar) {\n            warpSpeed = this.canTravelAtWarpSpeed(game, carrierOwner, carrier, sourceStar, destinationStar);\n            instantSpeed = this.starService.isStarPairWormHole(sourceStar, destinationStar);\n        }\n\n        let nextLocation;\n        let distancePerTick;\n        let distanceToDestination = this.distanceService.getDistanceBetweenLocations(carrier.location, destinationStar.location);\n\n\n        if (instantSpeed) {\n            distancePerTick = distanceToDestination;\n            nextLocation = destinationStar.location;\n        } else {\n            distancePerTick = this.getCarrierDistancePerTick(game, carrier, warpSpeed, instantSpeed)!;\n\n            if (distancePerTick >= distanceToDestination) {\n                distancePerTick = distanceToDestination;\n                nextLocation = destinationStar.location;\n            } else{\n                nextLocation = this.distanceService.getNextLocationTowardsLocation(carrier.location, destinationStar.location, distancePerTick);\n            }\n        }\n\n        return {\n            location: nextLocation,\n            distance: distancePerTick,\n            warpSpeed,\n            instantSpeed,\n            sourceStar,\n            destinationStar\n        };\n    }\n\n    canTravelAtWarpSpeed(game: Game, player: Player, carrier: Carrier, sourceStar: Star, destinationStar: Star) {\n        // Double check for destroyed stars.\n        if (sourceStar == null || destinationStar == null) {\n            return false;\n        }\n\n        // If both stars have warp gates and they are both owned by players...\n        if (sourceStar.warpGate && destinationStar.warpGate && sourceStar.ownedByPlayerId && destinationStar.ownedByPlayerId) {\n            // If both stars are owned by the player or by allies then carriers can always move at warp.\n            let sourceAllied = sourceStar.ownedByPlayerId.toString() === carrier.ownedByPlayerId!.toString() || (this.diplomacyService.isFormalAlliancesEnabled(game) && this.diplomacyService.isDiplomaticStatusToPlayersAllied(game, sourceStar.ownedByPlayerId, [carrier.ownedByPlayerId!]));\n            let desinationAllied = destinationStar.ownedByPlayerId.toString() === carrier.ownedByPlayerId!.toString() || (this.diplomacyService.isFormalAlliancesEnabled(game) && this.diplomacyService.isDiplomaticStatusToPlayersAllied(game, destinationStar.ownedByPlayerId, [carrier.ownedByPlayerId!]));\n\n            // If both stars are owned by the player then carriers can always move at warp.\n            if (sourceAllied && desinationAllied) {\n                return true;\n            }\n\n            // If one of the stars are not owned by the current player then we need to check for\n            // warp scramblers.\n\n            // But if the carrier has the warp stabilizer specialist then it can travel at warp speed no matter\n            // which player it belongs to or whether the stars it is travelling to or from have locked warp gates.\n            if (carrier.specialistId) {\n                let carrierSpecialist = this.specialistService.getByIdCarrier(carrier.specialistId);\n\n                if (carrierSpecialist && carrierSpecialist.modifiers.special && carrierSpecialist.modifiers.special.unlockWarpGates) {\n                    return true;\n                }\n            }\n\n            // If either star has a warp scrambler present then carriers cannot move at warp.\n            // Note that we only need to check for scramblers on stars that do not belong to the player.\n            if (!sourceAllied && sourceStar.specialistId) {\n                let specialist = this.specialistService.getByIdStar(sourceStar.specialistId);\n\n                if (specialist && specialist.modifiers.special && specialist.modifiers.special.lockWarpGates) {\n                    return false;\n                }\n            }\n\n            if (!desinationAllied && destinationStar.specialistId) {\n                let specialist = this.specialistService.getByIdStar(destinationStar.specialistId);\n\n                if (specialist && specialist.modifiers.special && specialist.modifiers.special.lockWarpGates) {\n                    return false;\n                }\n            }\n\n            // If none of the stars have scramblers then warp speed ahead.\n            return true;\n        }\n\n        return false;\n    }\n\n    isInTransit(carrier: Carrier) {\n        return !carrier.orbiting;\n    }\n\n    isInTransitTo(carrier: Carrier, star: Star) {\n        return this.isInTransit(carrier) && carrier.waypoints[0].destination.toString() === star._id.toString();\n    }\n\n    isLaunching(carrier: Carrier) {\n        return carrier.orbiting && carrier.waypoints.length && carrier.waypoints[0].delayTicks === 0;\n    }\n\n    getCarriersEnRouteToStar(game: Game, star: Star) {\n        return game.galaxy.carriers.filter(c => \n            c.waypoints && c.waypoints.length && c.waypoints.find(w => w.destination.toString() === star._id.toString()) != null\n        );\n    }\n\n    isLostInSpace(game: Game, carrier: Carrier) {\n        // If not in transit then it obviously isn't lost in space\n        if (!this.isInTransit(carrier)) {\n            return false;\n        }\n\n        // If the carrier has a waypoint then check if the\n        // current destination exists.\n        if (carrier.waypoints.length) {\n            return game.galaxy.stars.find(s => s._id.toString() === carrier.waypoints[0].destination.toString()) == null;\n        }\n\n        // If there are no waypoints and they are in transit then must be lost, otherwise all good.\n        return carrier.waypoints.length === 0;\n    }\n\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA,MAAO,uBAAqC;AAAA,EAQxC,YACI,UACA,iBACA,aACA,mBACA,kBACA,oBACF;AACE,SAAK,WAAW;AAChB,SAAK,kBAAkB;AACvB,SAAK,cAAc;AACnB,SAAK,oBAAoB;AACzB,SAAK,mBAAmB;AACxB,SAAK,qBAAqB;AAAA,EAC9B;AAAA,EAEA,0BAA0B,MAAY,SAAkB,YAAqB,OAAO,eAA+B,OAAO;AACtH,QAAI,cAAc;AACd,aAAO;AAAA,IACX;AAEA,QAAI,mBAAmB,YAAY,KAAK,UAAU,UAAU,sBAAsB;AAElF,QAAI,QAAQ,cAAc;AACtB,UAAI,aAAa,KAAK,kBAAkB,eAAe,QAAQ,YAAY;AAE3E,UAAI,cAAc,WAAW,UAAU,OAAO;AAC1C,4BAAqB,WAAW,UAAU,MAAM,SAAS;AAAA,MAC7D;AAAA,IACJ;AAEA,WAAO,KAAK,SAAS,cAAc,eAAe;AAAA,EACtD;AAAA,EAEA,6BAA6B,SAAkB,iBAAuB,iBAAyB;AAC3F,QAAI,eAAe,KAAK,gBAAgB,+BAA+B,QAAQ,UAAU,gBAAgB,UAAU,eAAe;AAElI,YAAQ,WAAW;AAAA,EACvB;AAAA,EAEA,MAAM,aAAa,MAAY,WAAmB,SAAkB,iBAAuB;AAEvF,QAAI,kBAAkB,QAAQ,UAAU,OAAO,GAAG,CAAC,EAAE;AAErD,QAAI,SAAS;AAAA,MACT,UAAU;AAAA,MACV,oBAAoB;AAAA,IACxB;AAEA,YAAQ,WAAW,gBAAgB;AACnC,YAAQ,WAAW,gBAAgB;AAInC,QAAI,QAAQ,iBAAiB;AACzB,cAAQ,UAAU,KAAK,eAAe;AAAA,IAC1C;AAKA,QAAI,gBAAgB,mBAAmB,MAAM;AACzC,YAAM,KAAK,YAAY,iBAAiB,MAAM,WAAW,iBAAiB,OAAO;AAAA,IACrF;AAIA,QAAI,CAAC,QAAQ,UAAU,KAAK,YAAY,WAAW,eAAe,KAAK,KAAK,kBAAkB,oBAAoB,OAAO,GAAG;AACxH,UAAI,qCAAqC,KAAK,kBAAkB,oCAAoC,OAAO;AAG3G,UAAI,WAAW,gBAAgB,eAAe,IAAI;AAClD,UAAI,2BAA2B;AAAA,QAC3B,SAAS,mCAAmC,UAAU;AAAA,QACtD,UAAU,mCAAmC,WAAW;AAAA,QACxD,SAAS,mCAAmC,UAAU;AAAA,MAC1D;AAEA,WAAK,YAAY,iBAAiB,MAAM,iBAAiB,wBAAwB;AAEjF,cAAQ,eAAe;AAAA,IAC3B;AAGA,QAAI,gBAAgB,gBAAiB,SAAS,MAAM,QAAQ,gBAAiB,SAAS,GAAG;AAGrF,UAAI,QAAQ,QAAQ;AAChB,cAAM,KAAK,mBAAmB,aAAa,MAAM,WAAW,iBAAiB,OAAO;AAAA,MACxF,WAAW,KAAK,iBAAiB,yBAAyB,IAAI,GAAG;AAC7D,YAAI,WAAW,KAAK,iBAAiB,uCAAuC,MAAM,CAAC,QAAQ,iBAAkB,gBAAgB,eAAgB,CAAC;AAE9I,eAAO,qBAAqB,CAAC;AAAA,MACjC,OAAO;AACH,eAAO,qBAAqB;AAAA,MAChC;AAAA,IACJ,OAAO;AAEH,cAAQ,SAAS;AAAA,IACrB;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,YAAY,MAAY,WAAmB,kBAA2B;AACxE,QAAI,WAA4B,iBAAiB,UAAU;AAE3D,QAAI,SAAS,YAAY;AACrB,YAAM,IAAI,MAAM,gDAAgD;AAAA,IACpE;AAEA,QAAI,KAAK,YAAY,gBAAgB,GAAG;AACpC,eAAS,SAAS,iBAAiB;AAGnC,UAAI,iBAAiB,SAAU,SAAS,MAAM,SAAS,YAAY,SAAS,GAAG;AAC3E,yBAAiB,WAAW;AAAA,MAChC;AAAA,IACJ;AAEA,QAAI,aAAa,KAAK,OAAO,MAAM,KAAK,OAAK,EAAE,IAAI,SAAS,MAAM,SAAS,OAAO,SAAS,CAAC;AAC5F,QAAI,kBAAkB,KAAK,OAAO,MAAM,KAAK,OAAK,EAAE,IAAI,SAAS,MAAM,SAAS,YAAY,SAAS,CAAC;AACtG,QAAI,eAAe,KAAK,OAAO,QAAQ,KAAK,OAAK,EAAE,IAAI,SAAS,MAAM,iBAAiB,gBAAiB,SAAS,CAAC;AAClH,QAAI,YAAY,KAAK,qBAAqB,MAAM,cAAc,kBAAkB,YAAY,eAAe;AAC3G,QAAI,eAAe,KAAK,YAAY,mBAAmB,YAAY,eAAe;AAClF,QAAI,kBAAkB,KAAK,0BAA0B,MAAM,kBAAkB,WAAW,YAAY;AAEpG,QAAI,wBAAwB;AAAA,MACxB,SAAS;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,oBAAoB;AAAA,MACpB,eAAe;AAAA,IACnB;AAEA,QAAI,gBAAiB,oBAAoB,iBAAiB,yBAAyB,MAAM,iBAAkB;AACvG,UAAI,oBAAoB,MAAM,KAAK,aAAa,MAAM,WAAW,kBAAkB,eAAe;AAElG,4BAAsB,WAAW,kBAAkB;AACnD,4BAAsB,qBAAqB,kBAAkB;AAC7D,4BAAsB,gBAAgB;AAAA,IAC1C,OAEK;AACD,WAAK,6BAA6B,kBAAkB,iBAAiB,eAAgB;AAAA,IACzF;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,0BAA0B,MAAY,SAAkB;AACpD,QAAI,WAAW,QAAQ,UAAU;AACjC,QAAI,aAAa,KAAK,OAAO,MAAM,KAAK,OAAK,EAAE,IAAI,SAAS,MAAM,SAAS,OAAO,SAAS,CAAC;AAC5F,QAAI,kBAAkB,KAAK,OAAO,MAAM,KAAK,OAAK,EAAE,IAAI,SAAS,MAAM,SAAS,YAAY,SAAS,CAAC;AACtG,QAAI,eAAe,KAAK,OAAO,QAAQ,KAAK,OAAK,EAAE,IAAI,SAAS,MAAM,QAAQ,gBAAiB,SAAS,CAAC;AAEzG,QAAI,YAAY;AAChB,QAAI,eAA+B;AAEnC,QAAI,YAAY;AACZ,kBAAY,KAAK,qBAAqB,MAAM,cAAc,SAAS,YAAY,eAAe;AAC9F,qBAAe,KAAK,YAAY,mBAAmB,YAAY,eAAe;AAAA,IAClF;AAEA,QAAI;AACJ,QAAI;AACJ,QAAI,wBAAwB,KAAK,gBAAgB,4BAA4B,QAAQ,UAAU,gBAAgB,QAAQ;AAGvH,QAAI,cAAc;AACd,wBAAkB;AAClB,qBAAe,gBAAgB;AAAA,IACnC,OAAO;AACH,wBAAkB,KAAK,0BAA0B,MAAM,SAAS,WAAW,YAAY;AAEvF,UAAI,mBAAmB,uBAAuB;AAC1C,0BAAkB;AAClB,uBAAe,gBAAgB;AAAA,MACnC,OAAM;AACF,uBAAe,KAAK,gBAAgB,+BAA+B,QAAQ,UAAU,gBAAgB,UAAU,eAAe;AAAA,MAClI;AAAA,IACJ;AAEA,WAAO;AAAA,MACH,UAAU;AAAA,MACV,UAAU;AAAA,MACV;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,qBAAqB,MAAY,QAAgB,SAAkB,YAAkB,iBAAuB;AAExG,QAAI,cAAc,QAAQ,mBAAmB,MAAM;AAC/C,aAAO;AAAA,IACX;AAGA,QAAI,WAAW,YAAY,gBAAgB,YAAY,WAAW,mBAAmB,gBAAgB,iBAAiB;AAElH,UAAI,eAAe,WAAW,gBAAgB,SAAS,MAAM,QAAQ,gBAAiB,SAAS,KAAM,KAAK,iBAAiB,yBAAyB,IAAI,KAAK,KAAK,iBAAiB,kCAAkC,MAAM,WAAW,iBAAiB,CAAC,QAAQ,eAAgB,CAAC;AACjR,UAAI,mBAAmB,gBAAgB,gBAAgB,SAAS,MAAM,QAAQ,gBAAiB,SAAS,KAAM,KAAK,iBAAiB,yBAAyB,IAAI,KAAK,KAAK,iBAAiB,kCAAkC,MAAM,gBAAgB,iBAAiB,CAAC,QAAQ,eAAgB,CAAC;AAG/R,UAAI,gBAAgB,kBAAkB;AAClC,eAAO;AAAA,MACX;AAOA,UAAI,QAAQ,cAAc;AACtB,YAAI,oBAAoB,KAAK,kBAAkB,eAAe,QAAQ,YAAY;AAElF,YAAI,qBAAqB,kBAAkB,UAAU,WAAW,kBAAkB,UAAU,QAAQ,iBAAiB;AACjH,iBAAO;AAAA,QACX;AAAA,MACJ;AAIA,UAAI,CAAC,gBAAgB,WAAW,cAAc;AAC1C,YAAI,aAAa,KAAK,kBAAkB,YAAY,WAAW,YAAY;AAE3E,YAAI,cAAc,WAAW,UAAU,WAAW,WAAW,UAAU,QAAQ,eAAe;AAC1F,iBAAO;AAAA,QACX;AAAA,MACJ;AAEA,UAAI,CAAC,oBAAoB,gBAAgB,cAAc;AACnD,YAAI,aAAa,KAAK,kBAAkB,YAAY,gBAAgB,YAAY;AAEhF,YAAI,cAAc,WAAW,UAAU,WAAW,WAAW,UAAU,QAAQ,eAAe;AAC1F,iBAAO;AAAA,QACX;AAAA,MACJ;AAGA,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,YAAY,SAAkB;AAC1B,WAAO,CAAC,QAAQ;AAAA,EACpB;AAAA,EAEA,cAAc,SAAkB,MAAY;AACxC,WAAO,KAAK,YAAY,OAAO,KAAK,QAAQ,UAAU,GAAG,YAAY,SAAS,MAAM,KAAK,IAAI,SAAS;AAAA,EAC1G;AAAA,EAEA,YAAY,SAAkB;AAC1B,WAAO,QAAQ,YAAY,QAAQ,UAAU,UAAU,QAAQ,UAAU,GAAG,eAAe;AAAA,EAC/F;AAAA,EAEA,yBAAyB,MAAY,MAAY;AAC7C,WAAO,KAAK,OAAO,SAAS;AAAA,MAAO,OAC/B,EAAE,aAAa,EAAE,UAAU,UAAU,EAAE,UAAU,KAAK,OAAK,EAAE,YAAY,SAAS,MAAM,KAAK,IAAI,SAAS,CAAC,KAAK;AAAA,IACpH;AAAA,EACJ;AAAA,EAEA,cAAc,MAAY,SAAkB;AAExC,QAAI,CAAC,KAAK,YAAY,OAAO,GAAG;AAC5B,aAAO;AAAA,IACX;AAIA,QAAI,QAAQ,UAAU,QAAQ;AAC1B,aAAO,KAAK,OAAO,MAAM,KAAK,OAAK,EAAE,IAAI,SAAS,MAAM,QAAQ,UAAU,GAAG,YAAY,SAAS,CAAC,KAAK;AAAA,IAC5G;AAGA,WAAO,QAAQ,UAAU,WAAW;AAAA,EACxC;AAEJ;AAAC;",
  "names": []
}
