{
  "version": 3,
  "sources": ["../../../server/services/ledger.ts"],
  "sourcesContent": ["import { DBObjectId } from \"./types/DBObjectId\";\nimport Repository from \"./repository\";\nimport { Game } from \"./types/Game\";\nimport { Player, PlayerLedgerDebt } from \"./types/Player\";\nimport PlayerService from \"./player\";\nimport PlayerCreditsService from \"./playerCredits\";\nimport ValidationError from \"../errors/validation\";\n\nconst EventEmitter = require('events');\n\nexport enum LedgerType {\n    Credits = 'credits',\n    CreditsSpecialists = 'creditsSpecialists'\n}\n\nexport const LedgerServiceEvents = {\n    onDebtAdded: 'onDebtAdded',\n    onDebtSettled: 'onDebtSettled',\n    onDebtForgiven: 'onDebtForgiven'\n}\n\nexport default class LedgerService extends EventEmitter {\n    gameRepo: Repository<Game>;\n    playerService: PlayerService;\n    playerCreditsService: PlayerCreditsService;\n\n    constructor(\n        gameRepo: Repository<Game>,\n        playerService: PlayerService,\n        playerCreditsService: PlayerCreditsService\n    ) {\n        super();\n\n        this.gameRepo = gameRepo;\n        this.playerService = playerService;\n        this.playerCreditsService = playerCreditsService;\n    }\n\n    getLedger(player: Player, type: LedgerType) {\n        return player.ledger[type];\n    }\n\n    getLedgerForPlayer(player: Player, playerId: DBObjectId, type: LedgerType) {\n        let fullLedger = this.getLedger(player, type);\n\n        // Get the ledger between the two players.\n        let playerLedger: PlayerLedgerDebt = fullLedger.find(l => l.playerId.toString() === playerId.toString())!;\n        let isNew: boolean = false;\n\n        // If no ledger exists, create one.\n        if (!playerLedger) {\n            playerLedger = {\n                playerId,\n                debt: 0,\n            };\n\n            player.ledger[type].push(playerLedger);\n            isNew = true;\n        }\n\n        playerLedger = fullLedger.find(l => l.playerId.toString() === playerId.toString())!;\n\n        return {\n            ledger: playerLedger,\n            isNew\n        };\n    }\n\n    async addDebt(game: Game, creditor: Player, debtor: Player, debt: number, type: LedgerType) {\n        // Get both of the ledgers between the two players.\n        let ledgerCreditor = this.getLedgerForPlayer(creditor, debtor._id, type);\n        let ledgerDebtor = this.getLedgerForPlayer(debtor, creditor._id, type);\n\n        ledgerCreditor.ledger.debt += debt;   // Player B now has debt to player A\n        ledgerDebtor.ledger.debt -= debt;   // Player A has paid off some of the debt to player B\n\n        await this._updateLedger(game, creditor, ledgerCreditor.ledger, ledgerCreditor.isNew, type);\n        await this._updateLedger(game, debtor, ledgerDebtor.ledger, ledgerDebtor.isNew, type);\n        \n        this.emit(LedgerServiceEvents.onDebtAdded, {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            debtor: debtor._id,\n            creditor: creditor._id,\n            amount: debt,\n            ledgerType: type\n        });\n\n        return ledgerCreditor;\n    }\n\n    async settleDebt(game: Game, debtor: Player, playerBId: DBObjectId, type: LedgerType) {\n        let creditor = this.playerService.getById(game, playerBId)!;\n\n        // Get both of the ledgers between the two players.\n        let ledgerDebtor = this.getLedgerForPlayer(debtor, playerBId, type);\n        let ledgerCreditor = this.getLedgerForPlayer(creditor, debtor._id, type);\n\n        if (ledgerDebtor.ledger.debt > 0) {\n            throw new ValidationError('You do not owe the player anything.');\n        }\n\n        let debtAmount = Math.abs(ledgerDebtor.ledger.debt);\n        let debtorCredits = type === LedgerType.Credits ? debtor.credits : debtor.creditsSpecialists\n\n        // If the debtor cannot fully settle the debt then only\n        // pay what they can (their total credits)\n        if (debtorCredits < debtAmount) {\n            debtAmount = debtorCredits;\n        }\n\n        ledgerDebtor.ledger.debt += debtAmount;\n        ledgerCreditor.ledger.debt -= debtAmount;\n\n        if (type === LedgerType.Credits) {\n            await this.playerCreditsService.addCredits(game, debtor, -debtAmount);\n            await this.playerCreditsService.addCredits(game, creditor, debtAmount);\n        } else if (type === LedgerType.CreditsSpecialists) {\n            await this.playerCreditsService.addCreditsSpecialists(game, debtor, -debtAmount);\n            await this.playerCreditsService.addCreditsSpecialists(game, creditor, debtAmount);\n        } else {\n            throw new Error(`Unsupported ledger type: ${type}`);\n        }\n\n        await this._updateLedger(game, debtor, ledgerDebtor.ledger, ledgerDebtor.isNew, type);\n        await this._updateLedger(game, creditor, ledgerCreditor.ledger, ledgerCreditor.isNew, type);\n\n        this.emit(LedgerServiceEvents.onDebtSettled, {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            debtor: debtor._id,\n            creditor: creditor._id,\n            amount: debtAmount,\n            ledgerType: type\n        });\n\n        return ledgerDebtor;\n    }\n\n    async forgiveDebt(game: Game, creditor: Player, playerBId: DBObjectId, type: LedgerType) {\n        let debtor = this.playerService.getById(game, playerBId)!;\n\n        // Get both of the ledgers between the two players.\n        let ledgerCreditor = this.getLedgerForPlayer(creditor, playerBId, type);\n        let ledgerDebtor = this.getLedgerForPlayer(debtor, creditor._id, type);\n\n        if (ledgerCreditor.ledger.debt <= 0) {\n            throw new ValidationError('The player does not owe you anything.');\n        }\n\n        let debtAmount = ledgerCreditor.ledger.debt;\n\n        ledgerDebtor.ledger.debt += debtAmount; // Player B no longer has debt to player A\n        ledgerCreditor.ledger.debt = 0;             // Forgive Player B's debt.\n\n        await this._updateLedger(game, creditor, ledgerCreditor.ledger, ledgerCreditor.isNew, type);\n        await this._updateLedger(game, debtor, ledgerDebtor.ledger, ledgerDebtor.isNew, type);\n\n        this.emit(LedgerServiceEvents.onDebtForgiven, {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            debtor: debtor._id,\n            creditor: creditor._id,\n            amount: debtAmount,\n            ledgerType: type\n        });\n\n        return ledgerCreditor;\n    }\n\n    async _updateLedger(game: Game, player: Player, ledger: PlayerLedgerDebt, isNew: boolean, type: LedgerType) {\n        let dbWrites: any[] = [];\n\n        if (isNew) {\n            const updateObject = {\n                $push: {}\n            };\n\n            // Funky string manipulation\n            updateObject.$push[`galaxy.players.$[p].ledger.${type}`] = {\n                playerId: ledger.playerId,\n                debt: ledger.debt\n            };\n\n            dbWrites.push({\n                updateOne: {\n                    filter: {\n                        _id: game._id,\n                        'galaxy.players._id': player._id\n                    },\n                    update: updateObject,\n                    arrayFilters: [\n                        { 'p._id': player._id }\n                    ]\n                }\n            });\n        } else {\n            const updateObject = {};\n\n            // Funky string manipulation\n            updateObject[`galaxy.players.$[p].ledger.${type}.$[l].debt`] = ledger.debt;\n\n            dbWrites.push({\n                updateOne: {\n                    filter: {\n                        _id: game._id\n                    },\n                    update: updateObject,\n                    arrayFilters: [\n                        { 'p._id': player._id },\n                        { 'l.playerId': ledger.playerId }\n                    ]\n                }\n            });\n        }\n\n        await this.gameRepo.bulkWrite(dbWrites);\n    }\n\n};\n"],
  "mappings": "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",
  "names": ["LedgerType", "ValidationError"]
}
