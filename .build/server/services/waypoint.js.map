{
  "version": 3,
  "sources": ["../../../server/services/waypoint.ts"],
  "sourcesContent": ["import { DBObjectId } from './types/DBObjectId';\nimport ValidationError from '../errors/validation';\nimport Repository from './repository';\nimport { Carrier } from './types/Carrier';\nimport { CarrierWaypoint, CarrierWaypointActionType, CarrierWaypointBase } from './types/CarrierWaypoint';\nimport { Game } from './types/Game';\nimport { Player } from './types/Player';\nimport { Star } from './types/Star';\nimport CarrierService from './carrier';\nimport DistanceService from './distance';\nimport GameService from './game';\nimport PlayerService from './player';\nimport StarService from './star';\nimport StarDistanceService from './starDistance';\nimport TechnologyService from './technology';\nimport { CarrierActionWaypoint } from './types/GameTick';\nimport CarrierMovementService from './carrierMovement';\n\nconst mongoose = require('mongoose');\n\nexport default class WaypointService {\n    gameRepo: Repository<Game>;\n    carrierService: CarrierService;\n    starService: StarService;\n    distanceService: DistanceService;\n    starDistanceService: StarDistanceService;\n    technologyService: TechnologyService;\n    gameService: GameService;\n    playerService: PlayerService;\n    carrierMovementService: CarrierMovementService;\n\n    constructor(\n        gameRepo: Repository<Game>,\n        carrierService: CarrierService,\n        starService: StarService,\n        distanceService: DistanceService,\n        starDistanceService: StarDistanceService,\n        technologyService: TechnologyService,\n        gameService: GameService,\n        playerService: PlayerService,\n        carrierMovementService: CarrierMovementService\n    ) {\n        this.gameRepo = gameRepo;\n        this.carrierService = carrierService;\n        this.starService = starService;\n        this.distanceService = distanceService;\n        this.starDistanceService = starDistanceService;\n        this.technologyService = technologyService;\n        this.gameService = gameService;\n        this.playerService = playerService;\n        this.carrierMovementService = carrierMovementService;\n    }\n\n    async saveWaypoints(game: Game, player: Player, carrierId: DBObjectId, waypoints: CarrierWaypointBase[], looped: boolean) {\n        let carrier = this.carrierService.getById(game, carrierId);\n\n        if (!carrier) {\n            throw new ValidationError(`Could not find carrier with id ${carrierId}`);\n        }\n        \n        return await this.saveWaypointsForCarrier(game, player, carrier, waypoints, looped);\n    }\n\n    async saveWaypointsForCarrier(game: Game, player: Player, carrier: Carrier, waypoints: CarrierWaypointBase[], looped: boolean, writeToDB: boolean = true) {\n        if (looped == null) {\n            looped = false;\n        }\n        \n        if (carrier.ownedByPlayerId!.toString() !== player._id.toString()) {\n            throw new ValidationError('The player does not own this carrier.');\n        }\n\n        if (waypoints.length > 30) {\n            throw new ValidationError('Cannot plot more than 30 waypoints.');\n        }\n\n        // If the carrier is currently in transit then double check that the first waypoint\n        // matches the source and destination.\n        if (!carrier.orbiting) {\n            let currentWaypoint = carrier.waypoints[0];\n            let newFirstWaypoint = waypoints[0];\n\n            if (!newFirstWaypoint \n                || currentWaypoint.source.toString() !== newFirstWaypoint.source.toString()\n                || currentWaypoint.destination.toString() !== newFirstWaypoint.destination.toString()) {\n                    throw new ValidationError('The first waypoint course cannot be changed mid-flight.');\n                }\n\n            if (+newFirstWaypoint.delayTicks) {\n                throw new ValidationError('The first waypoint cannot have delay ticks if mid-flight.');\n            }\n        }\n\n        // Validate new waypoints.\n        for (let i = 0; i < waypoints.length; i++) {\n            let waypoint = waypoints[i];\n\n            let sourceStar = this.starService.getById(game, waypoint.source);\n            let destinationStar = this.starService.getById(game, waypoint.destination);\n\n            let sourceStarName = sourceStar == null ? 'Unknown' : sourceStar.name; // Could be travelling from a destroyed star.\n\n            // Make sure the user isn't being a dumbass.\n            waypoint.actionShips = waypoint.actionShips || 0;\n            waypoint.action = waypoint.action || 'nothing';\n\n            if (waypoint.actionShips == null || (waypoint.actionShips as any) == '' || +waypoint.actionShips < 0) {\n                waypoint.actionShips = 0;\n            }\n\n            // Make damn sure there is a delay ticks defined.\n            waypoint.delayTicks = waypoint.delayTicks || 0;\n            \n            if (waypoint.delayTicks == null || (waypoint.delayTicks as any) == '' || +waypoint.delayTicks < 0) {\n                waypoint.delayTicks = 0;\n            }\n\n            // Make sure delay ticks isn't a decimal.\n            if (+waypoint.delayTicks % 1 != 0) {\n                throw new ValidationError(`The waypoint ${sourceStarName} -> ${destinationStar.name} delay cannot be a decimal.`);\n            }\n\n            // Make sure the user isn't being a dumbass.\n            if (+waypoint.delayTicks < 0) {\n                waypoint.delayTicks = 0;\n            }\n\n            // Validate waypoint hyperspace range if:\n            // The waypoint is not the first waypoint in the array.\n            // The carrier isn't in transit to the first waypoint.\n            if (\n                (i > 0 || (i === 0 && !this.carrierMovementService.isInTransit(carrier))) &&                    // Is one of the next waypoints OR is the first waypoint and isn't in transit\n                (sourceStar && (!this._waypointRouteIsBetweenWormHoles(game, waypoint) && !this._waypointRouteIsWithinHyperspaceRange(game, carrier, waypoint)))     // Validation of whether the waypoint is within hyperspace range\n            ) {\n                throw new ValidationError(`The waypoint ${sourceStarName} -> ${destinationStar.name} exceeds hyperspace range.`);\n            }\n        }\n        \n        carrier.waypoints = waypoints.map(w => {\n            return {\n                _id: new mongoose.Types.ObjectId(),\n                source: w.source,\n                destination: w.destination,\n                action: w.action,\n                actionShips: w.actionShips,\n                delayTicks: w.delayTicks\n            }\n        });\n\n        // If the waypoints are not a valid loop then throw an error.\n        if (looped && !this.canLoop(game, player, carrier)) {\n            throw new ValidationError(`The carrier waypoints cannot be looped.`);\n        }\n\n        carrier.waypointsLooped = looped;\n\n        // Update the DB.\n        if (writeToDB) {\n            await this.gameRepo.updateOne({\n                _id: game._id,\n                'galaxy.carriers._id': carrier._id\n            }, {\n                $set: {\n                    'galaxy.carriers.$.waypoints': waypoints,\n                    'galaxy.carriers.$.waypointsLooped': looped,\n                }\n            });\n        }\n\n        // Send back the eta ticks of the waypoints so that\n        // the UI can be updated.\n        const reportCarrier = Boolean(carrier.toObject) ? carrier.toObject() : carrier;\n\n        this.populateCarrierWaypointEta(game, reportCarrier);\n\n        return {\n            ticksEta: reportCarrier.ticksEta,\n            ticksEtaTotal: reportCarrier.ticksEtaTotal,\n            waypoints: reportCarrier.waypoints\n        };\n    }\n\n    _waypointRouteIsWithinHyperspaceRange(game: Game, carrier: Carrier, waypoint: CarrierWaypointBase) {\n        let sourceStar = this.starService.getById(game, waypoint.source);\n        let destinationStar = this.starService.getById(game, waypoint.destination);\n\n        // Stars may have been destroyed.\n        if (sourceStar == null || destinationStar == null) {\n            return false;\n        }\n\n        // If the stars are a wormhole pair then they are always considered to be in hyperspace range.\n        if (this.starService.isStarPairWormHole(sourceStar, destinationStar)) {\n            return true;\n        }\n\n        let effectiveTechs = this.technologyService.getCarrierEffectiveTechnologyLevels(game, carrier, true);\n        let hyperspaceDistance = this.distanceService.getHyperspaceDistance(game, effectiveTechs.hyperspace);\n\n        let distanceBetweenStars = this.starDistanceService.getDistanceBetweenStars(sourceStar, destinationStar);\n\n        return distanceBetweenStars <= hyperspaceDistance;\n    }\n\n    _waypointRouteIsBetweenWormHoles(game: Game, waypoint: CarrierWaypointBase) {\n        let sourceStar = this.starService.getById(game, waypoint.source);\n        let destinationStar = this.starService.getById(game, waypoint.destination);\n\n        // Stars may have been destroyed.\n        if (sourceStar == null || destinationStar == null) {\n            return false;\n        }\n\n        return this.starService.isStarPairWormHole(sourceStar, destinationStar);\n    }\n\n    async cullWaypointsByHyperspaceRangeDB(game: Game, carrier: Carrier) {\n        let cullResult = this.cullWaypointsByHyperspaceRange(game, carrier);\n\n        if (cullResult) {\n            await this.gameRepo.updateOne({\n                _id: game._id,\n                'galaxy.carriers._id': carrier._id\n            }, {\n                $set: {\n                    'galaxy.carriers.$.waypoints': cullResult.waypoints,\n                    'galaxy.carriers.$.waypointsLooped': cullResult.waypointsLooped,\n                }\n            });\n        }\n\n        return cullResult;\n    }\n\n    cullWaypointsByHyperspaceRange(game: Game, carrier: Carrier) {\n        if (!carrier.waypoints.length) {\n            return;\n        }\n        \n        let player = this.playerService.getById(game, carrier.ownedByPlayerId!)!;\n\n        // Iterate through all waypoints the carrier has one by one and\n        // if any of them are not valid then remove it and all subsequent waypoints.\n        let waypointsCulled = false;\n\n        // If in transit, then cull starting from the 2nd waypoint.\n        let startingWaypointIndex = this.carrierMovementService.isInTransit(carrier) ? 1 : 0;\n\n        for (let i = startingWaypointIndex; i < carrier.waypoints.length; i++) {\n            let waypoint = carrier.waypoints[i];\n\n            if (!this._waypointRouteIsWithinHyperspaceRange(game, carrier, waypoint)) {\n                waypointsCulled = true;\n\n                carrier.waypoints.splice(i);\n\n                if (carrier.waypointsLooped) {\n                    carrier.waypointsLooped = this.canLoop(game, player, carrier);\n                }\n\n                break;\n            }\n        }\n\n        if (waypointsCulled) {\n            return {\n                waypoints: carrier.waypoints,\n                waypointsLooped: carrier.waypointsLooped\n            };\n        }\n\n        return null;\n    }\n\n    cullAllWaypointsByHyperspaceRange(game: Game) {\n        for (let carrier of game.galaxy.carriers) {\n            this.cullWaypointsByHyperspaceRange(game, carrier);\n        }\n    }\n\n    async loopWaypoints(game: Game, player: Player, carrierId: DBObjectId, loop: boolean) {\n        let carrier = this.carrierService.getById(game, carrierId);\n        \n        if (carrier.ownedByPlayerId!.toString() !== player._id.toString()) {\n            throw new ValidationError('The player does not own this carrier.');\n        }\n        \n        if (carrier.isGift) {\n            throw new ValidationError('Cannot loop waypoints of a carrier that is a gift.');\n        }\n\n        if (loop) {\n            if (carrier.waypoints.length < 1) {\n                throw new ValidationError('The carrier must have 2 or more waypoints to loop');\n            }\n\n            if (!this.canLoop(game, player, carrier)) {\n                throw new ValidationError('The last waypoint star is out of hyperspace range of the first waypoint star.');\n            }\n        }\n        \n        // Update the DB.\n        await this.gameRepo.updateOne({\n            _id: game._id,\n            'galaxy.carriers._id': carrier._id\n        }, {\n            $set: {\n                'galaxy.carriers.$.waypointsLooped': loop,\n            }\n        })\n    }\n\n    canLoop(game: Game, player: Player, carrier: Carrier) {\n        if (carrier.waypoints.length < 2 || carrier.isGift) {\n            return false;\n        }\n\n        let effectiveTechs = this.technologyService.getCarrierEffectiveTechnologyLevels(game, carrier, true);\n\n        // Check whether the last waypoint is in range of the first waypoint.\n        let firstWaypoint = carrier.waypoints[0];\n        let lastWaypoint = carrier.waypoints[carrier.waypoints.length - 1];\n\n        let firstWaypointStar = this.starService.getById(game, firstWaypoint.destination);\n        let lastWaypointStar = this.starService.getById(game, lastWaypoint.destination);\n\n        if (firstWaypointStar == null || lastWaypointStar == null) {\n            return false;\n        }\n\n        if (this.starService.isStarPairWormHole(firstWaypointStar, lastWaypointStar)) {\n            return true;\n        }\n\n        let distanceBetweenStars = this.starDistanceService.getDistanceBetweenStars(firstWaypointStar, lastWaypointStar);\n        let hyperspaceDistance = this.distanceService.getHyperspaceDistance(game, effectiveTechs.hyperspace);\n\n        return distanceBetweenStars <= hyperspaceDistance\n    }\n\n    calculateWaypointTicks(game: Game, carrier: Carrier, waypoint: CarrierWaypoint) {\n        const delayTicks = waypoint.delayTicks || 0;\n\n        let carrierOwner = game.galaxy.players.find(p => p._id.toString() === carrier.ownedByPlayerId!.toString())!;\n\n        // if the waypoint is going to the same star then it is at least 1\n        // tick, plus any delay ticks.\n        if (waypoint.source.toString() === waypoint.destination.toString()) {\n            return 1 + delayTicks;\n        }\n\n        let sourceStar = this.starService.getById(game, waypoint.source);\n        let destinationStar = this.starService.getById(game, waypoint.destination);\n\n        // If the carrier can travel instantly then it'll take 1 tick + any delay.\n        let instantSpeed = sourceStar && this.starService.isStarPairWormHole(sourceStar, destinationStar);\n\n        if (instantSpeed) {\n            return 1 + delayTicks;\n        }\n\n        let source = sourceStar == null ? carrier.location : sourceStar.location;\n        let destination = destinationStar.location;\n\n        // If the carrier is already en-route, then the number of ticks will be relative\n        // to where the carrier is currently positioned.\n        if (!carrier.orbiting && carrier.waypoints[0]._id.toString() === waypoint._id.toString()) {\n            source = carrier.location;\n        }\n        \n        let distance = this.distanceService.getDistanceBetweenLocations(source, destination);\n        let warpSpeed = this.carrierMovementService.canTravelAtWarpSpeed(game, carrierOwner, carrier, sourceStar, destinationStar);\n\n        // Calculate how far the carrier will move per tick.\n        let tickDistance = this.carrierMovementService.getCarrierDistancePerTick(game, carrier, warpSpeed, instantSpeed);\n        let ticks = 1;\n\n        if (tickDistance) {\n            ticks = Math.ceil(distance / tickDistance);\n        }\n\n        ticks += delayTicks; // Add any delay ticks the waypoint has.\n\n        return ticks;\n    }\n\n    calculateWaypointTicksEta(game: Game, carrier: Carrier, waypoint: CarrierWaypoint) {\n        let totalTicks = 0;\n\n        for (let i = 0; i < carrier.waypoints.length; i++) {\n            let cwaypoint = carrier.waypoints[i];\n            \n            totalTicks += this.calculateWaypointTicks(game, carrier, cwaypoint);\n\n            if (cwaypoint._id.toString() === waypoint._id.toString()) {\n                break;\n            }\n        }\n\n        return totalTicks;\n    }\n\n    performWaypointAction(carrier: Carrier, star: Star, waypoint: CarrierWaypoint) {\n        if (carrier.ownedByPlayerId!.toString() !== star.ownedByPlayerId!.toString()) {\n            throw new Error('Cannot perform waypoint action, the carrier and star are owned by different players.')\n        }\n\n        switch (waypoint.action) {\n            case 'dropAll':\n                this._performWaypointActionDropAll(carrier, star, waypoint);\n                break;\n            case 'drop':\n                this._performWaypointActionDrop(carrier, star, waypoint);\n                break;\n            case 'dropPercentage':\n                this._performWaypointActionDropPercentage(carrier, star, waypoint);\n                break;\n            case 'dropAllBut':\n                this._performWaypointActionDropAllBut(carrier, star, waypoint);\n                break;\n            case 'collectAll':\n                this._performWaypointActionCollectAll(carrier, star, waypoint);\n                break;\n            case 'collect':\n                this._performWaypointActionCollect(carrier, star, waypoint);\n                break;\n            case 'collectPercentage':\n                this._performWaypointActionCollectPercentage(carrier, star, waypoint);\n                break;\n            case 'collectAllBut':\n                this._performWaypointActionCollectAllBut(carrier, star, waypoint);\n                break;\n            case 'garrison':\n                this._performWaypointActionGarrison(carrier, star, waypoint);\n                break;\n        }\n    }\n\n    populateCarrierWaypointEta(game: Game, carrier: Carrier) {\n        carrier.waypoints.forEach(w => {\n            w.ticks = this.calculateWaypointTicks(game, carrier, w);\n            w.ticksEta = this.calculateWaypointTicksEta(game, carrier, w);\n        });\n\n        if (carrier.waypoints.length) {\n            carrier.ticksEta = carrier.waypoints[0].ticksEta;\n            carrier.ticksEtaTotal = carrier.waypoints[carrier.waypoints.length - 1].ticksEta;\n        } else {\n            carrier.ticksEta = null;\n            carrier.ticksEtaTotal = null;\n        }\n    }\n\n    _performWaypointActionDropAll(carrier: Carrier, star: Star, waypoint: CarrierWaypoint) {\n        star.shipsActual! += (carrier.ships! - 1)\n        star.ships = Math.floor(star.shipsActual!);\n        carrier.ships = 1;\n    }\n\n    _performWaypointActionCollectAll(carrier: Carrier, star: Star, waypoint: CarrierWaypoint) {\n        carrier.ships! += star.ships!;\n        star.shipsActual! -= star.ships!;\n        star.ships = Math.floor(star.shipsActual!);\n    }\n\n    _performWaypointActionDrop(carrier: Carrier, star: Star, waypoint: CarrierWaypoint) {\n        // If the carrier has more ships than needs to be dropped, then drop\n        // however many are configured in the waypoint.\n        if (carrier.ships! - 1 >= waypoint.actionShips) {\n            star.shipsActual! += waypoint.actionShips;\n            star.ships = Math.floor(star.shipsActual!);\n            carrier.ships! -= waypoint.actionShips;\n        }\n        else {\n            // If there aren't enough ships, then do a drop all.\n            this._performWaypointActionDropAll(carrier, star, waypoint);\n        }\n    }\n    \n    performWaypointActionsDrops(game: Game, waypoints: CarrierActionWaypoint[]) {\n        this._performFilteredWaypointActions(game, waypoints, ['dropAll', 'drop', 'dropAllBut', 'dropPercentage']);\n    }\n\n    _performWaypointActionCollect(carrier: Carrier, star: Star, waypoint: CarrierWaypoint) {\n        // If the star has more ships than needs to be collected, then collect\n        // however many are configured in the waypoint.\n        if (star.ships! >= waypoint.actionShips) {\n            star.shipsActual! -= waypoint.actionShips;\n            star.ships = Math.floor(star.shipsActual!);\n            carrier.ships! += waypoint.actionShips;\n        }\n        else {\n            // If there aren't enough ships, then do a collect all.\n            this._performWaypointActionCollectAll(carrier, star, waypoint);\n        }\n    }\n\n    performWaypointActionsCollects(game: Game, waypoints: CarrierActionWaypoint[]) {\n        this._performFilteredWaypointActions(game, waypoints, ['collectAll', 'collect', 'collectAllBut', 'collectPercentage']);\n    }\n\n    _performWaypointActionDropPercentage(carrier: Carrier, star: Star, waypoint: CarrierWaypoint) {\n        const toDrop = Math.floor(carrier.ships! * (waypoint.actionShips * 0.01))\n\n        if (toDrop >= 1 && carrier.ships! - toDrop >= 1) {\n            star.shipsActual! += toDrop\n            star.ships = Math.floor(star.shipsActual!)\n            carrier.ships! -= toDrop\n        }\n    }\n\n    _performWaypointActionDropAllBut(carrier: Carrier, star: Star, waypoint: CarrierWaypoint) {\n        // Calculate the difference between how many ships we currently have\n        // and how many need to remain after.\n        let difference = carrier.ships! - waypoint.actionShips;\n\n        // If we have more than enough ships to transfer, then transfer\n        // the desired amount. Otherwise do not drop anything.\n        if (difference > 0 && difference <= carrier.ships! - 1) {\n            star.shipsActual! += difference;\n            star.ships = Math.floor(star.shipsActual!);\n            carrier.ships! -= difference;\n        }\n    }\n\n    _performWaypointActionCollectPercentage(carrier: Carrier, star: Star, waypoint: CarrierWaypoint) {\n        const toTransfer = Math.floor(star.ships! * (waypoint.actionShips * 0.01))\n\n        if (toTransfer >= 1 && star.ships! - toTransfer >= 0) {\n            star.shipsActual! -= toTransfer\n            star.ships = Math.floor(star.shipsActual!)\n            carrier.ships! += toTransfer\n        }\n    }\n\n    _performWaypointActionCollectAllBut(carrier: Carrier, star: Star, waypoint: CarrierWaypoint) {\n        // Calculate the difference between how many ships we currently have\n        // and how many need to remain after.\n        let difference = star.ships! - waypoint.actionShips;\n\n        // If we have more than enough ships to transfer, then transfer\n        // the desired amount. Otherwise do not drop anything.\n        if (difference > 0 && difference <= star.ships!) {\n            star.shipsActual! -= difference;\n            star.ships = Math.floor(star.shipsActual!);\n            carrier.ships! += difference;\n        }\n    }\n\n    _performWaypointActionGarrison(carrier: Carrier, star: Star, waypoint: CarrierWaypoint) {\n        // Calculate how many ships need to be dropped or collected\n        // in order to garrison the star.\n        let difference = star.ships! - waypoint.actionShips;\n\n        // If the difference is above 0 then move ships\n        // from the star to the carrier, otherwise do the opposite.\n        if (difference > 0) {\n            let allowed = Math.abs(Math.min(difference, star.ships!));\n\n            star.shipsActual! -= allowed;\n            carrier.ships! += allowed;\n        } else {\n            let allowed = Math.min(Math.abs(difference), carrier.ships! - 1);\n\n            star.shipsActual! += allowed;\n            carrier.ships! -= allowed;\n        }\n\n        star.ships = Math.floor(star.shipsActual!);\n    }\n\n    performWaypointActionsGarrisons(game: Game, waypoints: CarrierActionWaypoint[]) {\n        this._performFilteredWaypointActions(game, waypoints, ['garrison']);\n    }\n\n    _performFilteredWaypointActions(game: Game, waypoints: CarrierActionWaypoint[], waypointTypes: CarrierWaypointActionType[]) {\n        let actionWaypoints = waypoints.filter(w => \n            waypointTypes.indexOf(w.waypoint.action) > -1\n            && w.carrier.ownedByPlayerId!.toString() === w.star.ownedByPlayerId!.toString() // The carrier must be owned by the player who owns the star.\n        );\n\n        for (let actionWaypoint of actionWaypoints) {\n            this.performWaypointAction(actionWaypoint.carrier, actionWaypoint.star, actionWaypoint.waypoint);\n        }\n    }\n\n    sanitiseAllCarrierWaypointsByScanningRange(game: Game) {\n        const scanningRanges = game.galaxy.players\n            .map(p => {\n                return {\n                    player: p,\n                    stars: this.starService.filterStarsByScanningRange(game, [p._id])\n                }\n            });\n\n        game.galaxy.carriers\n            .filter(c => c.waypoints.length)\n            .map(c => {\n                let scanningRangePlayer = scanningRanges.find(s => s.player._id.toString() === c.ownedByPlayerId!.toString())!;\n\n                return {\n                    carrier: c,\n                    owner: scanningRangePlayer.player,\n                    ownerScannedStars: scanningRangePlayer.stars\n                }\n            })\n            .forEach(x => this.sanitiseCarrierWaypointsByScanningRange(game, x.carrier, x.owner, x.ownerScannedStars));\n    }\n\n    sanitiseCarrierWaypointsByScanningRange(game: Game, carrier: Carrier, owner: Player, ownerScannedStars: Star[]) {\n        // Verify that waypoints are still valid.\n        // For example, if a star is captured then it may no longer be in scanning range\n        // so any waypoints to it should be removed unless already in transit.\n\n        if (!carrier.waypoints.length) {\n            return;\n        }\n\n        let startIndex = this.carrierMovementService.isInTransit(carrier) ? 1 : 0;\n\n        for (let i = startIndex; i < carrier.waypoints.length; i++) {\n            let waypoint = carrier.waypoints[i];\n\n            // If the destination is not within scanning range of the player, remove it and all subsequent waypoints.\n            let inRange = ownerScannedStars.find(s => s._id.toString() === waypoint.destination.toString()) != null;\n\n            if (!inRange) {\n                carrier.waypoints.splice(i);\n\n                if (carrier.waypointsLooped) {\n                    carrier.waypointsLooped = this.canLoop(game, owner, carrier);\n                }\n\n                break;\n            }\n        }\n    }\n\n};\n"],
  "mappings": "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",
  "names": ["ValidationError"]
}
