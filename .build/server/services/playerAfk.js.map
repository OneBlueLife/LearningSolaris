{
  "version": 3,
  "sources": ["../../../server/services/playerAfk.ts"],
  "sourcesContent": ["const moment = require('moment');\nconst EventEmitter = require('events');\nimport Repository from './repository';\nimport { Game } from './types/Game';\nimport { Player } from './types/Player';\nimport CarrierService from './carrier';\nimport GameTypeService from './gameType';\nimport StarService from './star';\nimport GameStateService from './gameState';\nimport PlayerService from './player';\n\nexport default class PlayerAfkService extends EventEmitter {\n    gameRepo: Repository<Game>;\n    playerService: PlayerService;\n    starService: StarService;\n    carrierService: CarrierService;\n    gameTypeService: GameTypeService;\n    gameStateService: GameStateService;\n\n    constructor(\n        gameRepo: Repository<Game>,\n        playerService: PlayerService,\n        starService: StarService,\n        carrierService: CarrierService,\n        gameTypeService: GameTypeService,\n        gameStateService: GameStateService\n    ) {\n        super();\n\n        this.gameRepo = gameRepo;\n        this.playerService = playerService;\n        this.starService = starService;\n        this.carrierService = carrierService;\n        this.gameTypeService = gameTypeService;\n        this.gameStateService = gameStateService;\n    }\n\n    performDefeatedOrAfkCheck(game: Game, player: Player) {\n        if (player.defeated) {\n            throw new Error(`Cannot perform a defeated check on an already defeated player.`);\n        }\n\n        if (!player.afk) {\n            // Check if the player has been AFK.\n            let isAfk = this.isAfk(game, player);\n    \n            if (isAfk) {\n                this.playerService.setPlayerAsAfk(game, player);\n            }\n        }\n\n        // Check if the player has been defeated by conquest.\n        if (!player.defeated) {\n            let stars = this.starService.listStarsOwnedByPlayer(game.galaxy.stars, player._id);\n\n            // If there are no stars and there are no carriers then the player is defeated.\n            if (stars.length === 0) {\n                let carriers = this.carrierService.listCarriersOwnedByPlayer(game.galaxy.carriers, player._id); // Note: This logic looks a bit weird, but its more performant.\n\n                if (carriers.length === 0) {\n                    this.playerService.setPlayerAsDefeated(game, player, false);\n                }\n            }\n\n            // For capital star elimination games, if the player doesn't own their original home star then they are defeated.\n            if (this.gameTypeService.isCapitalStarEliminationMode(game) && !this.playerService.ownsOriginalHomeStar(game, player)) {\n                this.playerService.setPlayerAsDefeated(game, player, false);\n            }\n        }\n    }\n\n    isAIControlled(game: Game, player: Player, includePseudoAfk: boolean) {\n        // Defeated players or players not controlled by a user are controlled by AI.\n        if (player.defeated || !player.userId) {\n            return true;\n        }\n\n        // Pseudo AFK players are players who haven't been online for a while but haven't yet reached the AFK timeout,\n        // we want these players to be controlled by AI until they come online or are kicked.\n        if (includePseudoAfk) {\n            return this.isPsuedoAfk(game, player);\n        }\n        \n        return false;\n    }\n\n    isPsuedoAfk(game: Game, player: Player) {\n        if (!this.gameStateService.isStarted(game)) {\n            return false;\n        }\n        \n        let startDate = moment(game.state.startDate).utc();\n        let startDatePlus12h = moment(game.state.startDate).add(12, 'hours');\n        let now = moment().utc();\n\n        // We want to give players at least a 12h from the start of the game.\n        if (now < startDatePlus12h) {\n            return false;\n        }\n\n        // If the player hasn't been seen since the start of the game then let the AI take over.\n        if (player.lastSeen == null || moment(player.lastSeen).utc() <= startDate) {\n            return true;\n        }\n        \n        return false;\n    }\n\n    isAfk(game: Game, player: Player) {\n        if (player.afk) {\n            return true;\n        }\n\n        // The player is afk if:\n        // 1. They haven't been seen for X days.\n        // 2. They missed the turn limit in a turn based game.\n        // 3. They missed X cycles in a real time game (minimum of 12 hours)\n\n        // If the player is AI controlled, then they are not AFK.\n        // Note: Don't include pseudo afk, only legit actual afk players.\n        if (this.isAIControlled(game, player, false)) {\n            return false;\n        }\n\n        let lastSeenMoreThanXDaysAgo = moment(player.lastSeen).utc() <= moment().utc().subtract(game.settings.gameTime.afk.lastSeenTimeout, 'days');\n\n        if (lastSeenMoreThanXDaysAgo) {\n            return true;\n        }\n\n        if (this.gameTypeService.isTurnBasedGame(game)) {\n            return player.missedTurns >= game.settings.gameTime.afk.turnTimeout;\n        }\n\n        let secondsXCycles = game.settings.galaxy.productionTicks * game.settings.gameTime.speed * game.settings.gameTime.afk.cycleTimeout;\n        let secondsToAfk = Math.max(secondsXCycles, 43200); // Minimum of 12 hours.\n        let lastSeenMoreThanXSecondsAgo = moment(player.lastSeen).utc() <= moment().utc().subtract(secondsToAfk, 'seconds');\n\n        return lastSeenMoreThanXSecondsAgo;\n    }\n\n}\n"],
  "mappings": "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",
  "names": []
}
