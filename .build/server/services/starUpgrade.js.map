{
  "version": 3,
  "sources": ["../../../server/services/starUpgrade.ts"],
  "sourcesContent": ["import {Carrier} from \"./types/Carrier\";\n\nconst EventEmitter = require('events');\nimport { DBObjectId } from './types/DBObjectId';\nimport ValidationError from '../errors/validation';\nimport Repository from './repository';\nimport { BulkUpgradeReport, InfrastructureUpgradeCosts, InfrastructureUpgradeReport } from './types/InfrastructureUpgrade';\nimport { Game, GameInfrastructureExpenseMultiplier } from './types/Game';\nimport { Player } from './types/Player';\nimport { InfrastructureType, NaturalResources, Star, TerraformedResources } from './types/Star';\nimport AchievementService from './achievement';\nimport CarrierService from './carrier';\nimport GameTypeService from './gameType';\nimport ResearchService from './research';\nimport StarService from './star';\nimport TechnologyService from './technology';\nimport PlayerCreditsService from './playerCredits';\nimport ShipService from \"./ship\";\nconst Heap = require('qheap');\n\nexport const StarUpgradeServiceEvents = {\n    onPlayerInfrastructureBulkUpgraded: 'onPlayerInfrastructureBulkUpgraded'\n};\n\nexport default class StarUpgradeService extends EventEmitter {\n    gameRepo: Repository<Game>;\n    starService: StarService;\n    carrierService: CarrierService;\n    achievementService: AchievementService;\n    researchService: ResearchService;\n    technologyService: TechnologyService;\n    playerCreditsService: PlayerCreditsService;\n    gameTypeService: GameTypeService;\n    shipService: ShipService;\n\n    constructor(\n        gameRepo: Repository<Game>,\n        starService: StarService,\n        carrierService: CarrierService,\n        achievementService: AchievementService,\n        researchService: ResearchService,\n        technologyService: TechnologyService,\n        playerCreditsService: PlayerCreditsService,\n        gameTypeService: GameTypeService,\n        shipService: ShipService\n    ) {\n        super();\n\n        this.gameRepo = gameRepo;\n        this.starService = starService;\n        this.carrierService = carrierService;\n        this.achievementService = achievementService;\n        this.researchService = researchService;\n        this.technologyService = technologyService;\n        this.playerCreditsService = playerCreditsService;\n        this.gameTypeService = gameTypeService;\n        this.shipService = shipService;\n    }\n\n    async buildWarpGate(game: Game, player: Player, starId: DBObjectId) {\n        // Get the star.\n        let star = this.starService.getById(game, starId);\n\n        // Check whether the star is owned by the player.\n        if (star.ownedByPlayerId == null || star.ownedByPlayerId.toString() !== player._id.toString()) {\n            throw new ValidationError(`Cannot upgrade, the star is not owned by the current player.`);\n        }\n\n        if (star.warpGate) {\n            throw new ValidationError(`The star already has a warp gate.`);\n        }\n\n        if (game.settings.specialGalaxy.warpgateCost === 'none') {\n            throw new ValidationError('The game settings has disabled the building of warp gates.');\n        }\n\n        if (this.starService.isDeadStar(star)) {\n            throw new ValidationError('Cannot build a warp gate on a dead star.');\n        }\n\n        let effectiveTechs = this.technologyService.getStarEffectiveTechnologyLevels(game, star);\n\n        const expenseConfig = game.constants.star.infrastructureExpenseMultipliers[game.settings.specialGalaxy.warpgateCost];\n        const terraformedResources = this.starService.calculateTerraformedResources(star, effectiveTechs.terraforming);\n        const averageTerraformedResources = this.calculateAverageTerraformedResources(terraformedResources);\n        const cost = this.calculateWarpGateCost(game, expenseConfig, averageTerraformedResources)!;\n\n        if (player.credits < cost) {\n            throw new ValidationError(`The player does not own enough credits to afford to upgrade.`);\n        }\n\n        star.warpGate = true;\n        player.credits -= cost;\n\n        // Update the DB.\n        await this.gameRepo.bulkWrite([\n            await this._getDeductPlayerCreditsDBWrite(game, player, cost),\n            this._getSetStarWarpGateDBWrite(game, star, true)\n        ]);\n\n        if (player.userId && !player.defeated && !this.gameTypeService.isTutorialGame(game)) {\n            await this.achievementService.incrementWarpGatesBuilt(player.userId);\n        }\n\n        return {\n            starId: star._id,\n            cost\n        };\n    }\n\n    async destroyWarpGate(game: Game, player: Player, starId: DBObjectId) {\n        // Get the star.\n        let star = this.starService.getById(game, starId);\n\n        // Check whether the star is owned by the player\n        if (star.ownedByPlayerId == null || star.ownedByPlayerId.toString() !== player._id.toString()) {\n            throw new ValidationError(`Cannot destroy warp gate, the star is not owned by the current player.`);\n        }\n\n        if (!star.warpGate) {\n            throw new ValidationError(`The star does not have a warp gate to destroy.`);\n        }\n\n        // Update the DB.\n        await this.gameRepo.bulkWrite([\n            this._getSetStarWarpGateDBWrite(game, star, false)\n        ]);\n\n        if (player.userId && !player.defeated && !this.gameTypeService.isTutorialGame(game)) {\n            await this.achievementService.incrementWarpGatesDestroyed(player.userId);\n        }\n    }\n\n    async buildCarrier(game: Game, player: Player, starId: DBObjectId, ships: number, writeToDB: boolean = true): Promise<{carrier: Carrier, starShips: number}> {\n        ships = ships || 1;\n\n        if (ships < 1) {\n            throw new ValidationError(`Carrier must have 1 or more ships.`);\n        }\n\n        // Get the star.\n        let star = this.starService.getById(game, starId);\n\n        // Check whether the star is owned by the player.\n        if (star.ownedByPlayerId == null || star.ownedByPlayerId.toString() !== player._id.toString()) {\n            throw new ValidationError(`Cannot build carrier, the star is not owned by the current player.`);\n        }\n\n        if (this.starService.isDeadStar(star)) {\n            throw new ValidationError('Cannot build a carrier on a dead star.');\n        }\n\n        const expenseConfig = game.constants.star.infrastructureExpenseMultipliers[game.settings.specialGalaxy.carrierCost];\n        const cost = this.calculateCarrierCost(game, expenseConfig);\n\n        if (player.credits < cost) {\n            throw new ValidationError(`The player does not own enough credits to afford to build a carrier.`);\n        }\n\n        if (Math.floor(star.shipsActual!) < ships) {\n            throw new ValidationError(`The star does not have enough ships garrisoned (${ships}) to build the carrier.`);\n        }\n\n        // Create a carrier at the star.\n        let carrier = this.carrierService.createAtStar(star, game.galaxy.carriers, ships);\n\n        game.galaxy.carriers.push(carrier);\n\n        // Deduct the cost of the carrier from the player's credits.\n        player.credits -= cost;\n\n        // Update the DB.\n        if (writeToDB) {\n            await this.gameRepo.bulkWrite([\n                await this._getDeductPlayerCreditsDBWrite(game, player, cost),\n                {\n                    updateOne: {\n                        filter: {\n                            _id: game._id,\n                            'galaxy.stars._id': star._id\n                        },\n                        update: {\n                            'galaxy.stars.$.shipsActual': star.shipsActual,\n                            'galaxy.stars.$.ships': star.ships\n                        }\n                    }\n                },\n                {\n                    updateOne: {\n                        filter: {\n                            _id: game._id\n                        },\n                        update: {\n                            $push: {\n                                'galaxy.carriers': carrier\n                            }\n                        }\n                    }\n                }\n            ]);\n        }\n\n        if (player.userId && !player.defeated && !this.gameTypeService.isTutorialGame(game)) {\n            await this.achievementService.incrementCarriersBuilt(player.userId);\n        }\n\n        carrier.effectiveTechs = this.technologyService.getCarrierEffectiveTechnologyLevels(game, carrier, true);\n\n        return {\n            carrier,\n            starShips: star.ships || 0\n        };\n    }\n\n    _calculateUpgradeInfrastructureCost(game: Game, star: Star, expenseConfigKey: GameInfrastructureExpenseMultiplier, economyType: InfrastructureType, calculateCostCallback) {\n        if (this.starService.isDeadStar(star)) {\n            return null;\n        }\n\n        let effectiveTechs = this.technologyService.getStarEffectiveTechnologyLevels(game, star);\n\n        // Calculate how much the upgrade will cost.\n        const expenseConfig = game.constants.star.infrastructureExpenseMultipliers[expenseConfigKey];\n        const terraformedResources = this.starService.calculateTerraformedResource(star.naturalResources[economyType], effectiveTechs.terraforming);\n\n        const cost = calculateCostCallback(game, expenseConfig, star.infrastructure[economyType], terraformedResources);\n\n        return cost;\n    }\n\n    async _upgradeInfrastructureUpdateDB(game: Game, player: Player, star: Star, cost: number, economyType: InfrastructureType) {\n        let dbWrites: any[] = [\n            await this._getDeductPlayerCreditsDBWrite(game, player, cost)\n        ];\n\n        switch (economyType) {\n            case 'economy':\n                dbWrites.push({\n                    updateOne: {\n                        filter: {\n                            _id: game._id,\n                            'galaxy.stars._id': star._id\n                        },\n                        update: {\n                            $inc: {\n                                'galaxy.stars.$.infrastructure.economy': 1\n                            }\n                        }\n                    }\n                });\n                break;\n            case 'industry':\n                dbWrites.push({\n                    updateOne: {\n                        filter: {\n                            _id: game._id,\n                            'galaxy.stars._id': star._id\n                        },\n                        update: {\n                            $inc: {\n                                'galaxy.stars.$.infrastructure.industry': 1\n                            }\n                        }\n                    }\n                });\n                break;\n            case 'science':\n                dbWrites.push({\n                    updateOne: {\n                        filter: {\n                            _id: game._id,\n                            'galaxy.stars._id': star._id\n                        },\n                        update: {\n                            $inc: {\n                                'galaxy.stars.$.infrastructure.science': 1\n                            }\n                        }\n                    }\n                });\n                break;\n        }\n\n        // Update the DB.\n        await this.gameRepo.bulkWrite(dbWrites);\n\n        if (player.userId && !player.defeated && !this.gameTypeService.isTutorialGame(game)) {\n            await this.achievementService.incrementInfrastructureBuilt(economyType, player.userId);\n        }\n    }\n\n    async _upgradeInfrastructure(game: Game, player: Player, starId: DBObjectId, expenseConfigKey: GameInfrastructureExpenseMultiplier, economyType: InfrastructureType, calculateCostCallback, writeToDB: boolean = true): Promise<InfrastructureUpgradeReport> {\n        if (expenseConfigKey === 'none') {\n            throw new ValidationError(`Cannot upgrade ${economyType} as it has been disabled.`);\n        }\n\n        // Get the star.\n        let star = this.starService.getById(game, starId);\n\n        if (star.ownedByPlayerId == null || star.ownedByPlayerId.toString() !== player._id.toString()) {\n            throw new ValidationError(`Cannot upgrade ${economyType}, the star is not owned by the current player.`);\n        }\n\n        if (this.starService.isDeadStar(star)) {\n            throw new ValidationError('Cannot build infrastructure on a dead star.');\n        }\n\n        let cost = this._calculateUpgradeInfrastructureCost(game, star, expenseConfigKey, economyType, calculateCostCallback);\n\n        if (writeToDB && player.credits < cost) {\n            throw new ValidationError(`The player does not own enough credits to afford to upgrade.`);\n        }\n\n        // Upgrade infrastructure.\n        star.infrastructure[economyType]!++;\n\n        if (writeToDB) {\n            player.credits -= cost;\n\n            await this._upgradeInfrastructureUpdateDB(game, player, star, cost, economyType);\n        }\n\n        let nextCost = this._calculateUpgradeInfrastructureCost(game, star, expenseConfigKey, economyType, calculateCostCallback);\n\n        // Return a report of what just went down.\n        return {\n            playerId: player._id,\n            starId: star._id,\n            starName: star.name,\n            infrastructure: star.infrastructure[economyType]!,\n            cost,\n            nextCost\n        };\n    }\n\n    async upgradeEconomy(game: Game, player: Player, starId: DBObjectId, writeToDB: boolean = true) {\n        return await this._upgradeInfrastructure(game, player, starId, game.settings.player.developmentCost.economy, 'economy', this.calculateEconomyCost.bind(this), writeToDB);\n    }\n\n    async upgradeIndustry(game: Game, player: Player, starId: DBObjectId, writeToDB: boolean = true) {\n        let report = await this._upgradeInfrastructure(game, player, starId, game.settings.player.developmentCost.industry, 'industry', this.calculateIndustryCost.bind(this), writeToDB);\n\n        // Append the new manufacturing speed to the report.\n        let star = this.starService.getById(game, starId);\n        let effectiveTechs = this.technologyService.getStarEffectiveTechnologyLevels(game, star);\n\n        report.manufacturing = this.shipService.calculateStarShipsByTicks(effectiveTechs.manufacturing, report.infrastructure, 1, game.settings.galaxy.productionTicks);\n\n        return report;\n    }\n\n    async upgradeScience(game: Game, player: Player, starId: DBObjectId, writeToDB: boolean = true) {\n        let report = await this._upgradeInfrastructure(game, player, starId, game.settings.player.developmentCost.science, 'science', this.calculateScienceCost.bind(this), writeToDB);\n\n        report.currentResearchTicksEta = this.researchService.calculateCurrentResearchETAInTicks(game, player);\n        report.nextResearchTicksEta = this.researchService.calculateNextResearchETAInTicks(game, player);\n\n        return report;\n    }\n\n    _getStarsWithNextUpgradeCost(game: Game, player: Player, infrastructureType: InfrastructureType, includeIgnored: boolean = true) {\n        let expenseConfig: number | null;\n        let calculateCostFunction;\n        let upgradeFunction;\n\n        switch (infrastructureType) {\n            case 'economy':\n                calculateCostFunction = this.calculateEconomyCost.bind(this);\n                upgradeFunction = this.upgradeEconomy.bind(this);\n                expenseConfig = game.constants.star.infrastructureExpenseMultipliers[game.settings.player.developmentCost.economy] || null;\n                break;\n            case 'industry':\n                calculateCostFunction = this.calculateIndustryCost.bind(this);\n                upgradeFunction = this.upgradeIndustry.bind(this);\n                expenseConfig = game.constants.star.infrastructureExpenseMultipliers[game.settings.player.developmentCost.industry] || null;\n                break;\n            case 'science':\n                calculateCostFunction = this.calculateScienceCost.bind(this);\n                upgradeFunction = this.upgradeScience.bind(this);\n                expenseConfig = game.constants.star.infrastructureExpenseMultipliers[game.settings.player.developmentCost.science] || null;\n                break;\n        }\n\n        if (!calculateCostFunction) {\n            throw new ValidationError(`Unknown infrastructure type ${infrastructureType}`)\n        }\n\n        // Get all of the player stars and what the next upgrade cost will be.\n        return this.starService.listStarsOwnedByPlayer(game.galaxy.stars, player._id)\n            .filter(s => {\n                if (this.starService.isDeadStar(s)) {\n                    return false;\n                }\n\n                if (includeIgnored) {\n                    return true;\n                }\n\n                return !s.ignoreBulkUpgrade![infrastructureType];\n            })\n            .map(s => {\n                const effectiveTechs = this.technologyService.getStarEffectiveTechnologyLevels(game, s);\n                const terraformedResources = this.starService.calculateTerraformedResource(s.naturalResources[infrastructureType], effectiveTechs.terraforming);\n\n                return {\n                    star: s,\n                    terraformedResources,\n                    infrastructureCost: calculateCostFunction(game, expenseConfig, s.infrastructure[infrastructureType], terraformedResources),\n                    upgrade: upgradeFunction\n                }\n            });\n    }\n\n    async upgradeBulk(game: Game, player: Player, upgradeStrategy: string, infrastructureType: InfrastructureType, amount: number, writeToDB: boolean = true) {\n        if (!amount || amount <= 0) {\n            throw new ValidationError(`Invalid upgrade amount given`);\n        }\n\n        const upgradeSummary = await this.generateUpgradeBulkReport(game, player, upgradeStrategy, infrastructureType, amount);\n\n        // Check that the amount the player wants to spend isn't more than the amount he has\n        if (player.credits < upgradeSummary.cost) {\n            throw new ValidationError(`The player does not own enough credits to afford to bulk upgrade.`);\n        }\n\n        // Double check that the bulk upgrade report actually upgraded something.\n        if (upgradeSummary.cost <= 0) {\n            return upgradeSummary;\n        }\n\n        if (writeToDB) {\n            // Generate the DB writes for all the stars to upgrade, including deducting the credits\n            // for the player and also updating the player's achievement statistics.\n            let dbWrites: any[] = [\n                await this._getDeductPlayerCreditsDBWrite(game, player, upgradeSummary.cost)\n            ];\n\n            for (let star of upgradeSummary.stars) {\n                switch (infrastructureType) {\n                    case 'economy':\n                        dbWrites.push({\n                            updateOne: {\n                                filter: {\n                                    _id: game._id,\n                                    'galaxy.stars._id': star.starId\n                                },\n                                update: {\n                                    $set: {\n                                        'galaxy.stars.$.infrastructure.economy': star.infrastructure\n                                    }\n                                }\n                            }\n                        });\n                        break;\n                    case 'industry':\n                        dbWrites.push({\n                            updateOne: {\n                                filter: {\n                                    _id: game._id,\n                                    'galaxy.stars._id': star.starId\n                                },\n                                update: {\n                                    $set: {\n                                        'galaxy.stars.$.infrastructure.industry': star.infrastructure\n                                    }\n                                }\n                            }\n                        });\n                        break;\n                    case 'science':\n                        dbWrites.push({\n                            updateOne: {\n                                filter: {\n                                    _id: game._id,\n                                    'galaxy.stars._id': star.starId\n                                },\n                                update: {\n                                    $set: {\n                                        'galaxy.stars.$.infrastructure.science': star.infrastructure\n                                    }\n                                }\n                            }\n                        });\n                        break;\n                }\n            }\n\n            // Update the DB.\n            await this.gameRepo.bulkWrite(dbWrites);\n        }\n\n        // Check for AI control.\n        if (player.userId && !player.defeated && !this.gameTypeService.isTutorialGame(game)) {\n            await this.achievementService.incrementInfrastructureBuilt(infrastructureType, player.userId, upgradeSummary.upgraded);\n        }\n\n        player.credits -= upgradeSummary.cost;\n\n        this.emit(StarUpgradeServiceEvents.onPlayerInfrastructureBulkUpgraded, {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            player,\n            upgradeSummary\n        });\n\n        if (infrastructureType === 'science') {\n            upgradeSummary.currentResearchTicksEta = this.researchService.calculateCurrentResearchETAInTicks(game, player);\n            upgradeSummary.nextResearchTicksEta = this.researchService.calculateNextResearchETAInTicks(game, player);\n        }\n\n        return upgradeSummary;\n    }\n\n    async generateUpgradeBulkReport(game: Game, player: Player, upgradeStrategy: string, infrastructureType: InfrastructureType, amount: number): Promise<BulkUpgradeReport> {\n        if (!amount || amount <= 0) {\n            throw new ValidationError(`Invalid upgrade amount given`);\n        }\n\n        // Get all of the player stars and what the next upgrade cost will be.\n        if (upgradeStrategy === 'totalCredits') {\n            return await this.generateUpgradeBulkReportTotalCredits(game, player, infrastructureType, amount)\n        } else if (upgradeStrategy === 'infrastructureAmount') {\n            return await this.generateUpgradeBulkReportInfrastructureAmount(game, player, infrastructureType, amount)\n        } else if (upgradeStrategy === 'belowPrice') {\n            return await this.generateUpgradeBulkReportBelowPrice(game, player, infrastructureType, amount)\n        }\n\n        throw new Error(`Unsupported upgrade strategy: ${upgradeStrategy}`);\n    }\n\n    _createUpgradeQueue(size: number) {\n        return new Heap({\n            comparBefore: (s1, s2) => s1.infrastructureCost < s2.infrastructureCost,\n            compar: (s1, s2) => s1.infrastructureCost - s2.infrastructureCost,\n            freeSpace: false,\n            size\n        })\n    }\n\n    async _upgradeStarAndSummary(game: Game, player: Player, upgradeSummary: BulkUpgradeReport, upgradeStar, infrastructureType: InfrastructureType) {\n        let summaryStar = upgradeSummary.stars.find(x => x.starId.toString() === upgradeStar.star._id.toString());\n\n        if (!summaryStar) {\n            summaryStar = {\n                starId: upgradeStar.star._id,\n                starName: upgradeStar.star.name,\n                naturalResources: upgradeStar.star.naturalResources,\n                infrastructureCurrent: upgradeStar.star.infrastructure[infrastructureType],\n                infrastructureCostTotal: 0,\n                infrastructure: infrastructureType\n            }\n\n            upgradeSummary.stars.push(summaryStar);\n        }\n\n        const upgradeReport = await upgradeStar.upgrade(game, player, upgradeStar.star._id, false);\n\n        upgradeSummary.upgraded++;\n        upgradeSummary.cost += upgradeReport.cost;\n        summaryStar.infrastructureCostTotal += upgradeReport.cost;\n\n        // Update the stars next infrastructure cost so next time\n        // we loop we will have the most up to date info.\n        upgradeStar.infrastructureCost = upgradeReport.nextCost;\n        summaryStar.infrastructureCost = upgradeReport.nextCost;\n\n        if (upgradeReport.manufacturing != null) {\n            summaryStar.manufacturing = upgradeReport.manufacturing;\n        }\n\n        summaryStar.infrastructure = upgradeStar.star.infrastructure[infrastructureType];\n\n        return upgradeReport.cost;\n    }\n\n    async generateUpgradeBulkReportBelowPrice(game: Game, player: Player, infrastructureType: InfrastructureType, amount: number): Promise<BulkUpgradeReport> {\n        const ignoredCount = this.starService.listStarsOwnedByPlayerBulkIgnored(game.galaxy.stars, player._id, infrastructureType).length;\n        const stars = this._getStarsWithNextUpgradeCost(game, player, infrastructureType, false);\n\n        const upgradeSummary = {\n            budget: amount,\n            stars: [],\n            cost: 0,\n            upgraded: 0,\n            infrastructureType,\n            ignoredCount\n        };\n\n        const affordableStars = stars.filter(s => s.infrastructureCost <= amount);\n        const upgradeQueue = this._createUpgradeQueue(stars.length);\n        affordableStars.forEach(star => {\n            upgradeQueue.insert(star)\n        });\n\n        // Make sure we are not spending enormous amounts of time on this\n        while (upgradeSummary.upgraded <= 200) {\n            const nextStar = upgradeQueue.dequeue();\n            if (!nextStar) {\n                break;\n            }\n\n            await this._upgradeStarAndSummary(game, player, upgradeSummary, nextStar, infrastructureType);\n\n            if (nextStar.infrastructureCost <= amount) {\n                upgradeQueue.insert(nextStar);\n            }\n        }\n\n        return upgradeSummary\n    }\n\n    async generateUpgradeBulkReportInfrastructureAmount(game: Game, player: Player, infrastructureType: InfrastructureType, amount: number): Promise<BulkUpgradeReport> {\n        //Enforce some max size constraint\n        amount = Math.min(amount, 200);\n        const ignoredCount = this.starService.listStarsOwnedByPlayerBulkIgnored(game.galaxy.stars, player._id, infrastructureType).length;\n        const stars = this._getStarsWithNextUpgradeCost(game, player, infrastructureType, false);\n\n        const upgradeSummary = {\n            budget: amount,\n            stars: [],\n            cost: 0,\n            upgraded: 0,\n            infrastructureType,\n            ignoredCount\n        };\n\n        const upgradeQueue = this._createUpgradeQueue(stars.length);\n        stars.forEach(star => {\n            upgradeQueue.insert(star);\n        });\n\n        for (let i = 0; i < amount; i++) {\n            let upgradeStar = upgradeQueue.dequeue();\n\n            // If no stars can be upgraded then break out here.\n            if (!upgradeStar) {\n                break;\n            }\n\n            await this._upgradeStarAndSummary(game, player, upgradeSummary, upgradeStar, infrastructureType);\n\n            upgradeQueue.insert(upgradeStar)\n        }\n\n        return upgradeSummary;\n    }\n\n    async generateUpgradeBulkReportTotalCredits(game: Game, player: Player, infrastructureType: InfrastructureType, budget: number): Promise<BulkUpgradeReport> {\n        let ignoredCount = this.starService.listStarsOwnedByPlayerBulkIgnored(game.galaxy.stars, player._id, infrastructureType).length;\n        let stars = this._getStarsWithNextUpgradeCost(game, player, infrastructureType, false);\n\n        budget = Math.min(budget, player.credits + 10000); // Prevent players from generating reports for stupid amounts of credits\n\n        let upgradeSummary = {\n            budget,\n            stars: [],\n            cost: 0,\n            upgraded: 0,\n            infrastructureType,\n            ignoredCount\n        };\n\n        const upgradeStars = this._createUpgradeQueue(stars.length);\n        stars.forEach(star => {\n            upgradeStars.insert(star)\n        });\n\n        while (budget > 0) {\n            // Get the next star that can be upgraded, cheapest first.\n            let upgradeStar = upgradeStars.dequeue();\n\n            // If no stars can be upgraded then break out here.\n            if (!upgradeStar || upgradeStar.infrastructureCost > budget) {\n                break;\n            }\n\n            budget -= await this._upgradeStarAndSummary(game, player, upgradeSummary, upgradeStar, infrastructureType);\n            upgradeStars.insert(upgradeStar)\n        }\n\n        return upgradeSummary;\n    }\n\n\n\n    calculateAverageTerraformedResources(terraformedResources: TerraformedResources){\n        return Math.floor((terraformedResources.economy + terraformedResources.industry + terraformedResources.science) / 3);\n    }\n\n    calculateWarpGateCost(game: Game, expenseConfig: number, terraformedResources: number) {\n        return this._calculateInfrastructureCost(game.constants.star.infrastructureCostMultipliers.warpGate, expenseConfig, 0, terraformedResources);\n    }\n\n    calculateEconomyCost(game: Game, expenseConfig: number | null, current: number, terraformedResources: number) {\n        return this._calculateInfrastructureCost(game.constants.star.infrastructureCostMultipliers.economy, expenseConfig, current, terraformedResources);\n    }\n\n    calculateIndustryCost(game: Game, expenseConfig: number | null, current: number, terraformedResources: number) {\n        return this._calculateInfrastructureCost(game.constants.star.infrastructureCostMultipliers.industry, expenseConfig, current, terraformedResources);\n    }\n\n    calculateScienceCost(game: Game, expenseConfig: number | null, current: number, terraformedResources: number) {\n        return this._calculateInfrastructureCost(game.constants.star.infrastructureCostMultipliers.science, expenseConfig, current, terraformedResources);\n    }\n\n    _calculateInfrastructureCost(baseCost: number, expenseConfig: number | null, current: number, terraformedResources: number) {\n        if (expenseConfig == null) {\n            return null;\n        }\n        \n        return Math.max(1, Math.floor((baseCost * expenseConfig * (current + 1)) / (terraformedResources / 100)));\n    }\n\n    calculateCarrierCost(game: Game, expenseConfig: number) {\n        return (expenseConfig * game.constants.star.infrastructureCostMultipliers.carrier) + 5;\n    }\n\n    setUpgradeCosts(game: Game, star: Star, terraformedResources: TerraformedResources) {\n        const economyExpenseConfig = game.constants.star.infrastructureExpenseMultipliers[game.settings.player.developmentCost.economy];\n        const industryExpenseConfig = game.constants.star.infrastructureExpenseMultipliers[game.settings.player.developmentCost.industry];\n        const scienceExpenseConfig = game.constants.star.infrastructureExpenseMultipliers[game.settings.player.developmentCost.science];\n        const warpGateExpenseConfig = game.constants.star.infrastructureExpenseMultipliers[game.settings.specialGalaxy.warpgateCost];\n        const carrierExpenseConfig = game.constants.star.infrastructureExpenseMultipliers[game.settings.specialGalaxy.carrierCost];\n\n        // Calculate upgrade costs for the star.\n        const upgradeCosts: InfrastructureUpgradeCosts = {\n            economy: null,\n            industry: null,\n            science: null,\n            warpGate: null,\n            carriers: null\n        };\n\n        if (!this.starService.isDeadStar(star)) {\n            let averageTerraformedResources = this.calculateAverageTerraformedResources(terraformedResources);\n\n            upgradeCosts.economy = this.calculateEconomyCost(game, economyExpenseConfig, star.infrastructure.economy!, terraformedResources.economy);\n            upgradeCosts.industry = this.calculateIndustryCost(game, industryExpenseConfig, star.infrastructure.industry!, terraformedResources.industry);\n            upgradeCosts.science = this.calculateScienceCost(game, scienceExpenseConfig, star.infrastructure.science!, terraformedResources.science);\n            upgradeCosts.warpGate = this.calculateWarpGateCost(game, warpGateExpenseConfig, averageTerraformedResources); // Note: Warpgates in split resources use the average of all infrastructure.\n            upgradeCosts.carriers = this.calculateCarrierCost(game, carrierExpenseConfig);\n        }\n\n        // TODO: Do not assign to star object?\n        star.upgradeCosts = upgradeCosts;\n\n        return upgradeCosts;\n    }\n\n    async _getDeductPlayerCreditsDBWrite(game: Game, player: Player, cost: number) {\n        return await this.playerCreditsService.addCredits(game, player, -cost, false);\n    }\n\n    _getSetStarWarpGateDBWrite(game: Game, star: Star, warpGate: boolean) {\n        return {\n            updateOne: {\n                filter: {\n                    _id: game._id,\n                    'galaxy.stars._id': star._id\n                },\n                update: {\n                    'galaxy.stars.$.warpGate': warpGate\n                }\n            }\n        }\n    }\n};\n"],
  "mappings": "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",
  "names": ["ValidationError"]
}
