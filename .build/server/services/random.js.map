{
  "version": 3,
  "sources": ["../../../server/services/random.ts"],
  "sourcesContent": ["import { Location } from \"./types/Location\";\n\nexport default class RandomService {\n\n    getRandomNumber(max: number) {\n        return Math.floor(Math.random() * max);\n    }\n\n    // Note that the max is INCLUSIVE\n    getRandomNumberBetween(min: number, max: number): number {\n        return Math.floor(Math.random() * (max - min + 1) + min);\n    }\n\n    getRandomNumberBetweenEXP(min: number, max: number, P1: number = 0.5): number {\n        // P1 is the chance that the result is below half. So if the end result is between 0 and 1, like a Math.random,\n        // P1 describes the chance of the number being between 0 and 0.5, this makes P2 the chance of it being between 0.5 and 1\n        let P2 = 1 - P1;\n        if (P1 <= 0) {\n            return max;\n        } else if (P1 >= 1) {\n            return min;\n        }\n        let t = Math.random()\n        let exp = Math.log(P2) / Math.log(0.5)\n        // t**exp is still a value between 0 and 1, however the odds on each range is not the same, for example, if exp = 2, the odds on t**exp > 0.5 are 75%,\n        return Math.floor(t**exp * (max - min + 1) + min);\n    }\n\n    getRandomAngle(): number {\n        return Math.random() * Math.PI * 2;\n    }\n\n    getRandomRadius(maxRadius: number, offset: number): number {\n        return maxRadius * Math.random()**offset;\n    }\n\n    getRandomRadiusInRange(minRadius: number, maxRadius: number): number {\n        return (Math.random()*(maxRadius**2 - minRadius**2) + minRadius**2)**0.5;\n    }\n\n    getRandomPositionInCircle(maxRadius: number, offset: number = 0.5): Location {\n        let angle = this.getRandomAngle();\n        let radius = this.getRandomRadius(maxRadius, offset);\n\n        return {\n            x: Math.cos(angle) * radius,\n            y: Math.sin(angle) * radius\n        };\n    }\n\n    getRandomPositionInCircleFromOrigin(originX: number, originY: number, radius: number): Location {\n        let position = this.getRandomPositionInCircle(radius);\n\n        position.x += originX;\n        position.y += originY;\n\n        return position;\n    }\n\n    getRandomPositionInDoughnut(minRadius: number, maxRadius: number): Location {\n        let angle = this.getRandomAngle();\n        let radius = this.getRandomRadiusInRange(minRadius, maxRadius)\n    \n        return {\n            x: Math.cos(angle) * radius,\n            y: Math.sin(angle) * radius\n        };\n    }\n\n    generateStarNaturalResources(radius: number, x: number, y: number, minResources: number, maxResources: number, fuzzy: boolean = false): number {\n        const RS_BASE = 2;\n        const RS_EXPONENT = 5.8;\n\n        let vector = Math.hypot(x, y);\n        \n        //How far from the outside (%) is the point\n        let vectorScale = (radius - vector) / radius;\n\n        let resourceRange = maxResources - minResources;\n\n        let naturalResources = minResources + (resourceRange * vectorScale);\n\n        // TODO: This is a better approach however appears to be incorrect. Seems to be returning\n        // the reverse of what is intended. i.e Center of the galaxy returns max resources instead of min.\n        // let naturalResources = minResources + (resourceRange * Math.pow(RS_BASE, -RS_EXPONENT * Math.pow(vectorScale, 2)));\n\n        if (fuzzy) {\n            const FUZZY_LIMIT = 10;\n\n            let floorFuzzyNR = Math.max(minResources, naturalResources - FUZZY_LIMIT);\n            let ceilFuzzyNR = Math.min(maxResources, naturalResources + FUZZY_LIMIT);\n\n            naturalResources = this.getRandomNumberBetween(floorFuzzyNR, ceilFuzzyNR);\n        }\n\n        // Double check.\n        naturalResources = Math.max(minResources, naturalResources);\n        naturalResources = Math.min(maxResources, naturalResources);\n\n        return naturalResources;\n    }\n\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,MAAO,cAA4B;AAAA,EAE/B,gBAAgB,KAAa;AACzB,WAAO,KAAK,MAAM,KAAK,OAAO,IAAI,GAAG;AAAA,EACzC;AAAA,EAGA,uBAAuB,KAAa,KAAqB;AACrD,WAAO,KAAK,MAAM,KAAK,OAAO,KAAK,MAAM,MAAM,KAAK,GAAG;AAAA,EAC3D;AAAA,EAEA,0BAA0B,KAAa,KAAa,KAAa,KAAa;AAG1E,QAAI,KAAK,IAAI;AACb,QAAI,MAAM,GAAG;AACT,aAAO;AAAA,IACX,WAAW,MAAM,GAAG;AAChB,aAAO;AAAA,IACX;AACA,QAAI,IAAI,KAAK,OAAO;AACpB,QAAI,MAAM,KAAK,IAAI,EAAE,IAAI,KAAK,IAAI,GAAG;AAErC,WAAO,KAAK,MAAM,KAAG,OAAO,MAAM,MAAM,KAAK,GAAG;AAAA,EACpD;AAAA,EAEA,iBAAyB;AACrB,WAAO,KAAK,OAAO,IAAI,KAAK,KAAK;AAAA,EACrC;AAAA,EAEA,gBAAgB,WAAmB,QAAwB;AACvD,WAAO,YAAY,KAAK,OAAO,KAAG;AAAA,EACtC;AAAA,EAEA,uBAAuB,WAAmB,WAA2B;AACjE,YAAQ,KAAK,OAAO,KAAG,aAAW,IAAI,aAAW,KAAK,aAAW,MAAI;AAAA,EACzE;AAAA,EAEA,0BAA0B,WAAmB,SAAiB,KAAe;AACzE,QAAI,QAAQ,KAAK,eAAe;AAChC,QAAI,SAAS,KAAK,gBAAgB,WAAW,MAAM;AAEnD,WAAO;AAAA,MACH,GAAG,KAAK,IAAI,KAAK,IAAI;AAAA,MACrB,GAAG,KAAK,IAAI,KAAK,IAAI;AAAA,IACzB;AAAA,EACJ;AAAA,EAEA,oCAAoC,SAAiB,SAAiB,QAA0B;AAC5F,QAAI,WAAW,KAAK,0BAA0B,MAAM;AAEpD,aAAS,KAAK;AACd,aAAS,KAAK;AAEd,WAAO;AAAA,EACX;AAAA,EAEA,4BAA4B,WAAmB,WAA6B;AACxE,QAAI,QAAQ,KAAK,eAAe;AAChC,QAAI,SAAS,KAAK,uBAAuB,WAAW,SAAS;AAE7D,WAAO;AAAA,MACH,GAAG,KAAK,IAAI,KAAK,IAAI;AAAA,MACrB,GAAG,KAAK,IAAI,KAAK,IAAI;AAAA,IACzB;AAAA,EACJ;AAAA,EAEA,6BAA6B,QAAgB,GAAW,GAAW,cAAsB,cAAsB,QAAiB,OAAe;AAC3I,UAAM,UAAU;AAChB,UAAM,cAAc;AAEpB,QAAI,SAAS,KAAK,MAAM,GAAG,CAAC;AAG5B,QAAI,eAAe,SAAS,UAAU;AAEtC,QAAI,gBAAgB,eAAe;AAEnC,QAAI,mBAAmB,eAAgB,gBAAgB;AAMvD,QAAI,OAAO;AACP,YAAM,cAAc;AAEpB,UAAI,eAAe,KAAK,IAAI,cAAc,mBAAmB,WAAW;AACxE,UAAI,cAAc,KAAK,IAAI,cAAc,mBAAmB,WAAW;AAEvE,yBAAmB,KAAK,uBAAuB,cAAc,WAAW;AAAA,IAC5E;AAGA,uBAAmB,KAAK,IAAI,cAAc,gBAAgB;AAC1D,uBAAmB,KAAK,IAAI,cAAc,gBAAgB;AAE1D,WAAO;AAAA,EACX;AAEJ;AAAC;",
  "names": []
}
