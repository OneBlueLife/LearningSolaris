{
  "version": 3,
  "sources": ["../../../server/services/game.ts"],
  "sourcesContent": ["const EventEmitter = require('events');\nimport { DBObjectId } from './types/DBObjectId';\nimport ValidationError from '../errors/validation';\nimport Repository from './repository';\nimport { Game } from './types/Game';\nimport { Player } from './types/Player';\nimport AchievementService from './achievement';\nimport AvatarService from './avatar';\nimport CarrierService from './carrier';\nimport GameStateService from './gameState';\nimport GameTypeService from './gameType';\nimport PasswordService from './password';\nimport PlayerService from './player';\nimport StarService from './star';\nimport UserService from './user';\nimport ConversationService from './conversation';\nimport PlayerReadyService from './playerReady';\nimport GamePlayerQuitEvent from './types/events/GamePlayerQuit';\nimport GamePlayerDefeatedEvent from './types/events/GamePlayerDefeated';\n\nexport const GameServiceEvents = {\n    onPlayerQuit: 'onPlayerQuit',\n    onPlayerDefeated: 'onPlayerDefeated',\n    onGameDeleted: 'onGameDeleted'\n}\n\nexport default class GameService extends EventEmitter {\n    gameRepo: Repository<Game>;\n    userService: UserService;\n    starService: StarService;\n    carrierService: CarrierService;\n    playerService: PlayerService;\n    passwordService: PasswordService;\n    achievementService: AchievementService;\n    avatarService: AvatarService;\n    gameTypeService: GameTypeService;\n    gameStateService: GameStateService;\n    conversationService: ConversationService;\n    playerReadyService: PlayerReadyService;\n\n    constructor(\n        gameRepo: Repository<Game>,\n        userService: UserService,\n        starService: StarService,\n        carrierService: CarrierService,\n        playerService: PlayerService,\n        passwordService: PasswordService,\n        achievementService: AchievementService,\n        avatarService: AvatarService,\n        gameTypeService: GameTypeService,\n        gameStateService: GameStateService,\n        conversationService: ConversationService,\n        playerReadyService: PlayerReadyService\n    ) {\n        super();\n        \n        this.gameRepo = gameRepo;\n        this.userService = userService;\n        this.starService = starService;\n        this.carrierService = carrierService;\n        this.playerService = playerService;\n        this.passwordService = passwordService;\n        this.achievementService = achievementService;\n        this.avatarService = avatarService;\n        this.gameTypeService = gameTypeService;\n        this.gameStateService = gameStateService;\n        this.conversationService = conversationService;\n        this.playerReadyService = playerReadyService;\n    }\n\n    async getByIdAll(id: DBObjectId): Promise<Game | null> {\n        return await this.gameRepo.findByIdAsModel(id);\n    }\n\n    async getByIdAllLean(id: DBObjectId): Promise<Game | null> {\n        return await this.gameRepo.findById(id);\n    }\n\n    async getById(id: DBObjectId, select?: any): Promise<Game | null> {\n        return await this.gameRepo.findByIdAsModel(id, select);\n    }\n\n    async getByNameStateSettingsLean(name: string) {\n        return await this.gameRepo.find({\n            'settings.general.name': name\n        }, {\n            state: 1,\n            settings: 1\n        });\n    }\n\n    async getByIdSettingsLean(id: DBObjectId) {\n        return await this.gameRepo.findById(id, {\n            'settings': 1\n        });\n    }\n\n    async getByIdLean(id: DBObjectId, select): Promise<Game | null> {\n        return await this.gameRepo.findById(id, select);\n    }\n\n    async getByIdGalaxyLean(id: DBObjectId): Promise<Game | null> {\n        return await this.getByIdLean(id, {\n            settings: 1,\n            state: 1,\n            galaxy: 1,\n            constants: 1,\n            spectators: 1\n        });\n    }\n\n    async getGameStateTick(id: DBObjectId) {\n        let game = await this.getByIdLean(id, {\n            'state.tick': 1\n        });\n\n        if (!game) {\n            return null;\n        }\n\n        return game.state.tick;\n    }\n\n    async getGameSettings(id: DBObjectId) {\n        let game = await this.getByIdLean(id, {\n            'settings': 1\n        });\n\n        return game?.settings;\n    }\n\n    async quit(game: Game, player: Player) {    \n        if (game.state.startDate) {\n            throw new ValidationError('Cannot quit a game that has started.');\n        }\n\n        if (game.state.endDate) {\n            throw new ValidationError('Cannot quit a game that has finished.');\n        }\n\n        // If its a tutorial game then straight up delete it.\n        if (this.gameTypeService.isTutorialGame(game)) {\n            await this.delete(game);\n\n            return null;\n        }\n        \n        let alias = player.alias;\n\n        if (player.userId && !this.gameTypeService.isNewPlayerGame(game)) {\n            game.quitters.push(player.userId); // Keep a log of players who have quit the game early so they cannot rejoin later.\n        }\n\n        if (player.userId && !this.gameTypeService.isTutorialGame(game)) {\n            await this.achievementService.incrementQuit(player.userId);\n        }\n\n        // Reset everything the player may have done to their empire.\n        // This is to prevent the next player joining this slot from being screwed over.\n        this.playerService.resetPlayerForGameStart(game, player);\n\n        this.gameStateService.updateStatePlayerCount(game);\n        \n        await game.save();\n\n        let e: GamePlayerQuitEvent = {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            playerId: player._id,\n            playerAlias: alias\n        };\n\n        this.emit(GameServiceEvents.onPlayerQuit, e);\n\n        return player;\n    }\n\n    async concedeDefeat(game: Game, player: Player, openSlot: boolean) {\n        if (player.defeated) {\n            throw new ValidationError('The player has already been defeated.');\n        }\n\n        if (!game.state.startDate) {\n            throw new ValidationError('Cannot concede defeat in a game that has not yet started.');\n        }\n\n        if (game.state.endDate) {\n            throw new ValidationError('Cannot concede defeat in a game that has finished.');\n        }\n\n        // If its a tutorial game then straight up delete it.\n        if (this.gameTypeService.isTutorialGame(game)) {\n            return this.delete(game);\n        }\n\n        game.quitters.push(player.userId!); // We need to track this to ensure that they don't try to rejoin in another open slot.\n\n        this.playerService.setPlayerAsDefeated(game, player, openSlot);\n\n        game.state.players--; // Deduct number of active players from the game.\n\n        // NOTE: The game will check for a winner on each tick so no need to \n        // repeat that here.\n\n        // TODO: This is temporary. The advanced AI will be able to handle this.\n        // In the meantime, if we're still using normal AI we should clear looped carriers.\n        // TODO: Remove when basic AI is removed.\n        if (game.settings.general.advancedAI === 'disabled') {\n            this.carrierService.clearPlayerCarrierWaypointsLooped(game, player);\n        }\n\n        if (player.userId && !this.gameTypeService.isTutorialGame(game)) {\n            await this.achievementService.incrementDefeated(player.userId, 1);\n        }\n\n        await game.save();\n\n        let e: GamePlayerDefeatedEvent = {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            playerId: player._id,\n            playerAlias: player.alias,\n            openSlot\n        };\n\n        this.emit(GameServiceEvents.onPlayerDefeated, e);\n    }\n\n    async delete(game: Game, deletedByUserId?: DBObjectId) {\n        // If being deleted by a legit user then do some validation.\n        if (deletedByUserId && game.state.startDate) {\n            throw new ValidationError('Cannot delete games that are in progress or completed.');\n        }\n\n        if (deletedByUserId && game.settings.general.createdByUserId && game.settings.general.createdByUserId.toString() !== deletedByUserId.toString()) {\n            throw new ValidationError('Cannot delete this game, you did not create it.');\n        }\n\n        // If the game hasn't started yet, re-adjust user achievements of players\n        // who joined the game.\n        if (game.state.startDate == null && !this.gameTypeService.isTutorialGame(game)) {\n            // Deduct \"joined\" count for all players who already joined the game.\n            for (let player of game.galaxy.players) {\n                if (player.userId) {\n                    await this.achievementService.incrementJoined(player.userId, -1);\n                }\n            }\n        }\n\n        await this.gameRepo.deleteOne({ \n            _id: game._id \n        });\n\n        this.emit(GameServiceEvents.onGameDeleted, {\n            gameId: game._id\n        });\n\n        // TODO: Cleanup any orphaned docs\n    }\n\n    async getPlayerUser(game: Game, playerId: DBObjectId) {\n        if (this.gameTypeService.isAnonymousGame(game)) {\n            return null;\n        }\n        \n        let player = game.galaxy.players.find(p => p._id.toString() === playerId.toString())!;\n\n        return await this.userService.getInfoByIdLean(player.userId!, {\n            'achievements.level': 1,\n            'achievements.rank': 1,\n            'achievements.renown': 1,\n            'achievements.victories': 1,\n            'achievements.eloRating': 1,\n            roles: 1\n        });\n    }\n\n    // TODO: Move to a gameLockService\n    async lock(gameId: DBObjectId, locked: boolean = true) {\n        await this.gameRepo.updateOne({\n            _id: gameId\n        }, {\n            $set: {\n                'state.locked': locked\n            }\n        });\n    }\n\n    // TODO: Move to a gameLockService\n    async lockAll(locked: boolean = true) {\n        await this.gameRepo.updateMany({\n            'state.locked': { $ne: locked }\n        }, {\n            $set: {\n                'state.locked': locked\n            }\n        });\n    }\n\n    listAllUndefeatedPlayers(game: Game) {\n        if (this.gameTypeService.isTutorialGame(game)) {\n            return game.galaxy.players.filter(p => p.userId);\n        }\n\n        return game.galaxy.players.filter(p => !p.defeated);\n    }\n\n    isAllUndefeatedPlayersReady(game: Game) {\n        let undefeatedPlayers = this.listAllUndefeatedPlayers(game);\n\n        return undefeatedPlayers.filter(x => x.ready).length === undefeatedPlayers.length;\n    }\n\n    isAllUndefeatedPlayersReadyToQuit(game: Game) {\n        let undefeatedPlayers = this.listAllUndefeatedPlayers(game);\n\n        return undefeatedPlayers.filter(x => x.readyToQuit).length === undefeatedPlayers.length;\n    }\n\n    async forceEndGame(game: Game) {\n        let undefeatedPlayers = this.listAllUndefeatedPlayers(game);\n\n        for (let player of undefeatedPlayers) {\n            await this.playerReadyService.declareReadyToQuit(game, player, true);\n        }\n    }\n    \n    // TODO: Should be in a player service?\n    async quitAllActiveGames(userId: DBObjectId) {\n        let allGames = await this.gameRepo.findAsModels({\n            'galaxy.players': {\n                $elemMatch: { \n                    userId,             // User is in game\n                    defeated: false     // User has not been defeated\n                }\n            },\n            $and: [\n                { 'state.endDate': { $eq: null } } // The game hasn't ended.\n            ]\n        });\n\n        // Find all games that are pending start and quit.\n        // Find all games that are active and admit defeat.\n        for (let game of allGames) {\n            let player = this.playerService.getByUserId(game, userId)!;\n\n            if (this.gameStateService.isInProgress(game)) {\n                await this.concedeDefeat(game, player, false);\n            }\n            else {\n                await this.quit(game, player);\n            }\n        }\n    }\n\n    async markAsCleaned(gameId: DBObjectId) {\n        await this.gameRepo.updateOne({\n            _id: gameId\n        }, {\n            $set: {\n                'state.cleaned': true,\n                'settings.general.timeMachine': 'disabled'\n            }\n        });\n    }\n\n};\n"],
  "mappings": "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",
  "names": ["ValidationError"]
}
