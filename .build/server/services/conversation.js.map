{
  "version": 3,
  "sources": ["../../../server/services/conversation.ts"],
  "sourcesContent": ["const moment = require('moment');\nimport { DBObjectId } from './types/DBObjectId';\nimport ValidationError from '../errors/validation';\nimport Repository from './repository';\nimport { Conversation } from './types/Conversation';\nimport { ConversationMessage, ConversationMessageSentResult } from './types/ConversationMessage';\nimport { Game } from './types/Game';\nimport { Player } from './types/Player';\nimport TradeService from './trade';\nimport ConversationMessageSentEvent from './types/events/ConversationMessageSent';\nimport DiplomacyService from './diplomacy';\nconst mongoose = require('mongoose');\nconst EventEmitter = require('events');\n\nfunction arrayIsEqual(a, b): boolean {\n    if (a.length !== b.length) return false;\n\n    const uniqueValues = new Set([...a, ...b]);\n\n    for (const v of uniqueValues) {\n        const aCount = a.filter(e => e === v).length;\n        const bCount = b.filter(e => e === v).length;\n\n        if (aCount !== bCount) return false;\n    }\n\n    return true;\n}\n\nfunction getNewConversation(game: Game, playerId: DBObjectId | null, name: string, participantIds: DBObjectId[]): Conversation {\n    if (name == null || !name.length || name.length > 100) {\n        throw new ValidationError(`Name is required and must not exceed 100 characters.`);\n    }\n\n    // TODO: Check if a convo already exists with this name?\n\n    // Append the current player ID to the participants if it isn't there already.\n    if (playerId && !participantIds.find(x => x.toString() === playerId.toString())) {\n        participantIds.unshift(playerId);\n    }\n\n    if (participantIds.length < 2) {\n        throw new ValidationError(`There must be at least 2 participants including yourself.`);\n    }\n\n    // Validate that another conversation doesn't already exist with the same participants.\n    let existingConvo = game.conversations\n        .filter(c => c.participants.length === participantIds.length)\n        .find(c => arrayIsEqual(c.participants.map(p => p.toString()), participantIds));\n\n    if (existingConvo) {\n        throw new ValidationError(`A conversation already exists with the selected participants named [${existingConvo.name}].`);\n    }\n\n    let convoId = new mongoose.Types.ObjectId();\n\n    let newConvo: Conversation = {\n        _id: convoId,\n        name,\n        createdBy: playerId,\n        participants: participantIds,\n        mutedBy: [],\n        messages: []\n    };\n\n    return newConvo;\n}\n\nexport const ConversationServiceEvents = {\n    onConversationCreated: 'onConversationCreated',\n    onConversationInvited: 'onConversationInvited',\n    onConversationMessageSent: 'onConversationMessageSent',\n    onConversationLeft: 'onConversationLeft'\n}\n\nexport default class ConversationService extends EventEmitter {\n    gameRepo: Repository<Game>;\n    tradeService: TradeService;\n    diplomacyService: DiplomacyService;\n\n    constructor(\n        gameRepo: Repository<Game>,\n        tradeService: TradeService,\n        diplomacyService: DiplomacyService\n    ) {\n        super();\n\n        this.gameRepo = gameRepo;\n        this.tradeService = tradeService;\n        this.diplomacyService = diplomacyService;\n    }\n\n    async create(game: Game, playerId: DBObjectId, name: string, participantIds: DBObjectId[]): Promise<Conversation> {\n        let newConvo = getNewConversation(game, playerId, name, participantIds);\n\n        // Create the convo.\n        await this.gameRepo.updateOne({\n            _id: game._id\n        }, {\n            $push: {\n                conversations: newConvo\n            }\n        });\n\n        this.emit(ConversationServiceEvents.onConversationCreated, {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            convo: newConvo,\n            playerId\n        });\n\n        for (let i = 1; i < newConvo.participants.length; i++) {\n            this.emit(ConversationServiceEvents.onConversationInvited, {\n                gameId: game._id,\n                gameTick: game.state.tick,\n                convo: newConvo,\n                playerId: newConvo.participants[i]\n            });\n        }\n\n        return newConvo;\n    }\n\n    createConversationAllPlayers(game: Game): void {\n        let name = game.settings.general.name;\n        let participantIds: DBObjectId[] = game.galaxy.players.map(p => p._id);\n\n        let newConvo = getNewConversation(game, null, name, participantIds);\n        \n        let newMessage: ConversationMessage = {\n            fromPlayerId: null,\n            fromPlayerAlias: \"Solaris\",\n            message: \"Welcome to \" + name + \"!\\n\\nThis is the global chat. Any messages sent here will be delivered to all players in the game!\\n\\nGood Luck, Commanders!\",\n            sentDate: moment().utc(),\n            sentTick: game.state.tick,\n            pinned: false,\n            readBy: [],\n        };\n        newConvo.messages.push(newMessage);\n        \n        game.conversations.push(newConvo);\n\n    }\n\n    async list(game: Game, playerId: DBObjectId) {\n        // List all conversations the player is participating in\n        // and the last message that was sent\n        // and the count of unread messages\n        let convos = game.conversations.filter(c => c.participants.find(p => p.toString() === playerId.toString()));\n\n        return convos.map(c => {\n            const msgs: ConversationMessage[] = c.messages as ConversationMessage[];\n\n            // Only return the last message\n            const lastMessage = msgs.slice(-1)[0] || null;\n\n            // Calculate how many messages in this conversation the player has NOT read.\n            const unreadCount = msgs.filter(m => m.readBy.find(r => r.toString() === playerId.toString()) == null).length;\n            const isMuted = c.mutedBy!.find(m => m.toString() === playerId.toString()) != null;\n\n            return {\n                _id: c._id,\n                participants: c.participants,\n                createdBy: c.createdBy,\n                name: c.name,\n                lastMessage,\n                unreadCount,\n                isMuted\n            }\n        });\n    }\n\n    // Gets the summary of a single chat (if exists) between two players\n    async privateChatSummary(game: Game, playerIdA: DBObjectId, playerIdB: DBObjectId) {\n        let convos = await this.list(game, playerIdA)\n\n        // Find the chat with the other participant\n        let convo = convos\n            .filter(c => c.participants.length === 2)\n            .find(c => {\n                return c.participants.find(a => a.toString() === playerIdA.toString())\n                    && c.participants.find(b => b.toString() === playerIdB.toString())\n            });\n\n        return convo || null;\n    }\n\n    _getConversationForPlayer(game: Game, conversationId: DBObjectId, playerId: DBObjectId) {\n        // Get the conversation that the player has requested in full.\n        let convo = game.conversations.find(c => c._id.toString() === conversationId.toString());\n\n        if (convo == null) {\n            throw new ValidationError(`The conversation requested does not exist.`);\n        }\n\n        if (convo.participants.find(p => p.toString() === playerId.toString() == null)) {\n            throw new ValidationError(`You are not participating in this conversation.`);\n        }\n\n        return convo;\n    }\n\n    async detail(game: Game, playerId: DBObjectId, conversationId: DBObjectId) {\n        let convo = this._getConversationForPlayer(game, conversationId, playerId);\n\n        convo.isMuted = convo.mutedBy!.find(m => m.toString() === playerId.toString()) != null;\n        delete convo.mutedBy;\n\n        convo.messages.forEach(m => {\n            m.type = 'message'; // Append the type of message as we may add trade events.\n        });\n\n        // If there are only two participants, then include any trade events that occurred\n        // between the players.\n        if (convo.participants.length === 2) {\n            const playerIdA = playerId\n            const playerIdB = convo.participants.filter(p => p.toString() !== playerIdA.toString())[0]\n\n            // TODO: This needs to be refactored like the diplomacy service diplo events function as to not pass in an array of participants\n            // because it doesnt make sense to do so, instead just pass in player A and player B.\n            let tradeEvents = await this.tradeService.listTradeEventsBetweenPlayers(game, playerId, convo.participants);\n\n            convo.messages = convo.messages.concat(tradeEvents);\n\n            let diploEvents = await this.diplomacyService.listDiplomacyEventsBetweenPlayers(game, playerIdA, playerIdB)\n\n            convo.messages = convo.messages.concat(diploEvents)\n        }\n\n        // Sort by sent date ascending.\n        convo.messages = convo.messages.sort((a, b) => moment(a.sentDate).valueOf() - moment(b.sentDate).valueOf());\n        \n        return convo;\n    }\n\n    async send(game: Game, player: Player, conversationId: DBObjectId, message: string): Promise<ConversationMessageSentResult> {\n        message = message.trim()\n\n        if (message === '') {\n            throw new ValidationError(`Message must not be empty.`);\n        }\n\n        // Get the conversation that the player has requested in full.\n        let convo = game.conversations.find(c => c._id.toString() === conversationId.toString());\n\n        if (convo == null) {\n            throw new ValidationError(`The conversation requested does not exist.`);\n        }\n\n        if (convo.participants.find(p => p.toString() === player._id.toString() == null)) {\n            throw new ValidationError(`You are not participating in this conversation.`);\n        }\n\n        let newMessage: ConversationMessage = {\n            _id: mongoose.Types.ObjectId(),\n            fromPlayerId: player._id,\n            fromPlayerAlias: player.alias!,\n            message,\n            sentDate: moment().utc(),\n            sentTick: game.state.tick,\n            pinned: false,\n            readBy: convo.mutedBy!\n        };\n\n        if (!newMessage.readBy.find(r => r.toString() === player._id.toString())) {\n            newMessage.readBy.push(player._id);\n        }\n\n        // Push a new message into the conversation messages array.\n        await this.gameRepo.updateOne({\n            _id: game._id,\n            'conversations._id': conversationId\n        }, {\n            $push: {\n                'conversations.$.messages': newMessage\n            }\n        });\n\n        const toPlayerIds = convo.participants.filter(p => p.toString() !== player._id.toString());\n\n        const sentMessageResult: ConversationMessageSentResult = {\n            ...newMessage,\n            conversationId,\n            type: 'message',\n            toPlayerIds\n        }\n        \n        let e: ConversationMessageSentEvent = {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            conversation: convo,\n            sentMessageResult\n        };\n\n        this.emit(ConversationServiceEvents.onConversationMessageSent, e);\n\n        return sentMessageResult;\n    }\n\n    async markConversationAsRead(game: Game, playerId: DBObjectId, conversationId: DBObjectId) {\n        let convo = this._getConversationForPlayer(game, conversationId, playerId);\n\n        // Note: This is the best way as it may save a DB call\n        // if there are no unread messages.\n        let unreadMessages = (convo.messages as ConversationMessage[])\n            .filter(m => m.readBy.find(r => r.toString() === playerId.toString()) == null)\n            .map(m => m._id);\n\n        if (unreadMessages.length) {\n            await this.gameRepo.updateOne({\n                _id: game._id,\n                'conversations._id': conversationId,\n                'conversations.messages._id': {\n                    $in: unreadMessages\n                }\n            },\n            {\n                $addToSet: {\n                    'conversations.$.messages.$[].readBy': playerId\n                }\n            });\n        }\n\n        return convo;\n    }\n\n    async leave(game: Game, playerId: DBObjectId, conversationId: DBObjectId) {\n        let convo = this._getConversationForPlayer(game, conversationId, playerId);\n\n        if (convo.createdBy == null) {\n            throw new ValidationError(`Cannot leave this conversation.`);\n        }\n\n        await this.gameRepo.updateOne({\n            _id: game._id,\n            'conversations._id': conversationId\n        }, {\n            $pull: {\n                'conversations.$.participants': playerId\n            }\n        });\n\n        // TODO: Delete the conversation if no longer any participants?\n\n        this.emit(ConversationServiceEvents.onConversationLeft, {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            convo,\n            playerId\n        });\n\n        return convo;\n    }\n\n    leaveAll(game: Game, playerId: DBObjectId) {\n        let convos = game.conversations.filter(c => c.createdBy && c.participants.indexOf(playerId) > -1);\n\n        for (let convo of convos) {\n            convo.participants.splice(\n                convo.participants.indexOf(playerId),\n                1\n            );\n        }\n    }\n\n    getUnreadCount(game: Game, playerId: DBObjectId) {\n        return (game.conversations || [])\n            .filter(c => c.participants.find(p => p.toString() === playerId.toString()))\n            .reduce((sum, c) => {\n                return sum + (c.messages as ConversationMessage[]).filter(m => m.readBy.find(r => r.toString() === playerId.toString()) == null).length\n            }, 0);\n    }\n\n    async pinMessage(game: Game, conversationId: DBObjectId, messageId: DBObjectId) {\n        return await this.setPinnedMessage(game, conversationId, messageId, true);\n    }\n\n    async unpinMessage(game: Game, conversationId: DBObjectId, messageId: DBObjectId) {\n        return await this.setPinnedMessage(game, conversationId, messageId, false);\n    }\n\n    async setPinnedMessage(game: Game, conversationId: DBObjectId, messageId: DBObjectId, isPinned: boolean) {\n        return await this.gameRepo.updateOne({\n            _id: game._id\n        }, {\n            $set: {\n                'conversations.$[c].messages.$[m].pinned': isPinned\n            }\n        }, {\n            arrayFilters: [\n                {\n                    'c._id': conversationId,\n                    'c.createdBy': { $ne: null } // Not the global chat\n                },\n                {\n                    'm._id': messageId\n                }\n            ]\n        });\n    }\n\n    async mute(game: Game, playerId: DBObjectId, conversationId: DBObjectId) {\n        return await this.gameRepo.updateOne({\n            _id: game._id,\n            'conversations._id': conversationId\n        }, {\n            $addToSet: {\n                'conversations.$.mutedBy': playerId\n            }\n        });\n    }\n\n    async unmute(game: Game, playerId: DBObjectId, conversationId: DBObjectId) {\n        return await this.gameRepo.updateOne({\n            _id: game._id,\n            'conversations._id': conversationId\n        }, {\n            $pull: {\n                'conversations.$.mutedBy': playerId\n            }\n        });\n    }\n\n}"],
  "mappings": "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",
  "names": ["ValidationError"]
}
