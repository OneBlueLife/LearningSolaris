{
  "version": 3,
  "sources": ["../../../server/services/gameGalaxy.ts"],
  "sourcesContent": ["import { DBObjectId } from './types/DBObjectId';\nimport ValidationError from '../errors/validation';\nimport { Game } from './types/Game';\nimport { Player, PlayerDiplomaticState, PlayerReputation, PlayerResearch } from './types/Player';\nimport BattleRoyaleService from './battleRoyale';\nimport BroadcastService from './broadcast';\nimport CacheService from './cache';\nimport CarrierService from './carrier';\nimport DiplomacyService from './diplomacy';\nimport DistanceService from './distance';\nimport GameService from './game';\nimport GameStateService from './gameState';\nimport GameTypeService from './gameType';\nimport UserGuildService from './guildUser';\nimport HistoryService from './history';\nimport MapService from './map';\nimport StarMovementService from './starMovement';\nimport PlayerService from './player';\nimport ReputationService from './reputation';\nimport ResearchService from './research';\nimport SpecialistService from './specialist';\nimport StarService from './star';\nimport StarDistanceService from './starDistance';\nimport StarUpgradeService from './starUpgrade';\nimport TechnologyService from './technology';\nimport WaypointService from './waypoint';\nimport { Star } from './types/Star';\nimport { Guild, GuildUserWithTag } from './types/Guild';\nimport { CarrierWaypoint } from './types/CarrierWaypoint';\nimport { Carrier } from './types/Carrier';\nimport AvatarService from './avatar';\nimport PlayerStatisticsService from './playerStatistics';\nimport GameFluxService from './gameFlux';\nimport PlayerAfkService from './playerAfk';\nimport ShipService from './ship';\nimport SpectatorService from './spectator';\n\nexport default class GameGalaxyService {\n    cacheService: CacheService;\n    broadcastService: BroadcastService;\n    gameService: GameService;\n    mapService: MapService;\n    playerService: PlayerService;\n    playerAfkService: PlayerAfkService;\n    starService: StarService;\n    shipService: ShipService;\n    distanceService: DistanceService;\n    starDistanceService: StarDistanceService;\n    starUpgradeService: StarUpgradeService;\n    carrierService: CarrierService;\n    waypointService: WaypointService;\n    researchService: ResearchService;\n    specialistService: SpecialistService;\n    technologyService: TechnologyService;\n    reputationService: ReputationService;\n    guildUserService: UserGuildService;\n    historyService: HistoryService;\n    battleRoyaleService: BattleRoyaleService;\n    starMovementService: StarMovementService;\n    gameTypeService: GameTypeService;\n    gameStateService: GameStateService;\n    diplomacyService: DiplomacyService;\n    avatarService: AvatarService;\n    playerStatisticsService: PlayerStatisticsService;\n    gameFluxService: GameFluxService;\n    spectatorService: SpectatorService;\n\n    constructor(\n        cacheService: CacheService,\n        broadcastService: BroadcastService,\n        gameService: GameService,\n        mapService: MapService,\n        playerService: PlayerService,\n        playerAfkService: PlayerAfkService,\n        starService: StarService,\n        shipService: ShipService,\n        distanceService: DistanceService, \n        starDistanceService: StarDistanceService,\n        starUpgradeService: StarUpgradeService,\n        carrierService: CarrierService, \n        waypointService: WaypointService,\n        researchService: ResearchService,\n        specialistService: SpecialistService,\n        technologyService: TechnologyService,\n        reputationService: ReputationService,\n        guildUserService: UserGuildService,\n        historyService: HistoryService,\n        battleRoyaleService: BattleRoyaleService,\n        starMovementService: StarMovementService,\n        gameTypeService: GameTypeService,\n        gameStateService: GameStateService,\n        diplomacyService: DiplomacyService,\n        avatarService: AvatarService,\n        playerStatisticsService: PlayerStatisticsService,\n        gameFluxService: GameFluxService,\n        spectatorService: SpectatorService\n    ) {\n        this.cacheService = cacheService;\n        this.broadcastService = broadcastService;\n        this.gameService = gameService;\n        this.mapService = mapService;\n        this.playerService = playerService;\n        this.playerAfkService = playerAfkService;\n        this.starService = starService;\n        this.shipService = shipService;\n        this.distanceService = distanceService;\n        this.starDistanceService = starDistanceService;\n        this.starUpgradeService = starUpgradeService;\n        this.carrierService = carrierService;\n        this.waypointService = waypointService;\n        this.researchService = researchService;\n        this.specialistService = specialistService;\n        this.technologyService = technologyService;\n        this.reputationService = reputationService;\n        this.guildUserService = guildUserService;\n        this.historyService = historyService;\n        this.battleRoyaleService = battleRoyaleService;\n        this.starMovementService = starMovementService;\n        this.gameTypeService = gameTypeService;\n        this.gameStateService = gameStateService;\n        this.diplomacyService = diplomacyService;\n        this.avatarService = avatarService;\n        this.playerStatisticsService = playerStatisticsService;\n        this.gameFluxService = gameFluxService;\n        this.spectatorService = spectatorService;\n    }\n\n    async getGalaxy(gameId: DBObjectId, userId: DBObjectId | null, tick: number | null) {\n        // Try loading the game for the user from the cache for historical ticks.\n        let gameStateTick = await this.gameService.getGameStateTick(gameId);\n\n        if (gameStateTick == null) {\n            throw new ValidationError('Game not found.', 404);\n        }\n\n        let isHistorical = tick != null && tick !== gameStateTick; // Indicates whether we are requesting a specific tick and not the CURRENT state of the galaxy.\n\n        let cached;\n\n        if (!isHistorical) {\n            tick = gameStateTick;\n        } else {\n            cached = this._getCachedGalaxy(gameId, userId, tick, gameStateTick);\n\n            if (cached && cached.galaxy) {\n                return cached.galaxy;\n            }\n        }\n\n        let game: Game | null = await this.gameService.getByIdGalaxyLean(gameId);\n\n        if (!game) {\n            throw new ValidationError(`Game not found`, 404);\n        }\n\n        if (isHistorical && game.settings.general.timeMachine === 'disabled') {\n            throw new ValidationError(`The time machine is disabled in this game.`);\n        }\n\n        // Check if the user is playing in this game.\n        let userPlayer = this._getUserPlayer(game, userId);\n\n        // Remove who created the game.\n        delete game.settings.general.createdByUserId;\n        delete game.settings.general.password; // Don't really need to explain why this is removed.\n\n        await this._maskGalaxy(game, userPlayer, isHistorical, tick);\n\n        // Append the player stats to each player.\n        this._setPlayerStats(game);\n\n        // Append the destruction flag before doing any scanning culling because\n        // we need to ensure that the flag is set based on ALL stars in the galaxy instead\n        // of culled stars (for example dark galaxy star culling)\n        if (this.gameTypeService.isBattleRoyaleMode(game) && !this.gameStateService.isFinished(game)) {\n            this._appendStarsPendingDestructionFlag(game);\n        }\n\n        // Calculate what perspectives the user can see, i.e which players the user is spectating.\n        const perspectives = this._getPlayerPerspectives(game, userId);\n\n        // if the user isn't playing this game or spectating, then only return\n        // basic data about the stars, exclude any important info like ships.\n        // If the game has finished then everyone should be able to view the full game.\n        if (!perspectives && !this.gameStateService.isFinished(game)) {\n            this._setStarInfoBasic(game);\n            this._clearPlayerCarriers(game);\n        } else {\n            this._setCarrierInfoDetailed(game, perspectives!);\n            this._setStarInfoDetailed(game, userPlayer, perspectives!);\n        }\n\n        // We always need to filter the player data so that it's basic info only.\n        await this._setPlayerInfoBasic(game, userPlayer, perspectives);\n\n        // For extra dark mode games, overwrite the player stats as by this stage\n        // scanning range will have kicked in and filtered out stars and carriers the player\n        // can't see and therefore global stats should display what the current player can see\n        // instead of their actual values.\n        // TODO: Better to not overwrite, but just not do it above in the first place?\n        if (this.gameTypeService.isDarkModeExtra(game)) {\n            this._setPlayerStats(game);\n        }\n\n        // If any kind of dark mode, remove the galaxy center from the constants.\n        if (this.gameTypeService.isDarkMode(game)) {\n            delete game.constants.distances.galaxyCenterLocation;\n        }\n\n        // Add the flux object\n        game.settings.general.flux = this.gameFluxService.getFluxById(game.settings.general.fluxId);\n\n        if (isHistorical && cached) {\n            this.cacheService.put(cached.cacheKey!, game, 1200000); // 20 minutes.\n        }\n\n        return game;\n    }\n\n    _getCachedGalaxy(gameId: DBObjectId, userId: DBObjectId | null, requestedTick: number | null, currentTick: number) {\n        // Cache up to 24 ticks, any more and its too much memory.\n        // Note: If we limit how much history data is logged we will\n        // need to update this logic.\n        if (requestedTick && currentTick - requestedTick > 24) {\n            return {\n                cacheKey: null,\n                galaxy: null\n            };\n        }\n\n        if (!userId) {\n            return null;\n        }\n\n        let cacheKey = `galaxy_${gameId}_${userId}_${requestedTick}`;\n        let galaxy = null;\n\n        let cached = this.cacheService.get(cacheKey);\n\n        if (cached) {\n            galaxy = cached;\n        }\n\n        return {\n            cacheKey,\n            galaxy\n        };\n    }\n\n    _getUserPlayer(doc: Game, userId: DBObjectId | null) {\n        if (!userId) {\n            return null;\n        }\n\n        return doc.galaxy.players.find(x => x.userId && x.userId.toString() === userId.toString()) || null;\n    }\n\n    _setPlayerStats(doc: Game) {\n        const isKingOfTheHillMode = this.gameTypeService.isKingOfTheHillMode(doc);\n\n        let kingOfTheHillPlayer: Player | null = null;\n\n        if (isKingOfTheHillMode) {\n            kingOfTheHillPlayer = this.playerService.getKingOfTheHillPlayer(doc);\n        }\n\n        // Get all of the player's statistics.\n        doc.galaxy.players.forEach(p => {\n            p.stats = this.playerStatisticsService.getStats(doc, p);\n\n            if (isKingOfTheHillMode) {\n                p.isKingOfTheHill = kingOfTheHillPlayer != null && kingOfTheHillPlayer._id.toString() === p._id.toString();\n            }\n        });\n    }\n\n    _setStarInfoBasic(doc: Game) {\n        // Work out whether we are in dark galaxy mode.\n        // This is true if the dark galaxy setting is enabled,\n        // OR if its \"start only\" and the game has not yet started.\n        const isDarkStart = this.gameTypeService.isDarkStart(doc);\n        const isDarkMode = this.gameTypeService.isDarkMode(doc);\n        const isDarkFogged = this.gameTypeService.isDarkFogged(doc);\n        const isKingOfTheHillMode = this.gameTypeService.isKingOfTheHillMode(doc);\n\n        let kingOfTheHillStar: Star | null = null;\n\n        if (isKingOfTheHillMode) {\n            kingOfTheHillStar = this.starService.getKingOfTheHillStar(doc);\n        }\n\n        // If its a dark galaxy start then return no stars.\n        if (isDarkMode || isDarkFogged || (isDarkStart && !doc.state.startDate)) {\n            doc.galaxy.stars = [];\n        }\n\n        doc.galaxy.stars = doc.galaxy.stars\n        .map(s => {\n            let star = {\n                _id: s._id,\n                name: s.name,\n                ownedByPlayerId: s.ownedByPlayerId,\n                location: s.location,\n                warpGate: false,\n                isNebula: false,\n                isAsteroidField: false,\n                isBinaryStar: false,\n                isBlackHole: false,\n                isPulsar: false,\n                wormHoleToStarId: null\n            } as Star;\n\n            star.effectiveTechs = this.technologyService.getStarEffectiveTechnologyLevels(doc, star);\n\n            if (isKingOfTheHillMode) {\n                star.isKingOfTheHillStar = kingOfTheHillStar != null && kingOfTheHillStar._id.toString() === s._id.toString();\n            }\n\n            return star;\n        });\n    }\n\n    _setStarInfoDetailed(doc: Game, userPlayer: Player | null, perspectivePlayerIds: DBObjectId[]) { \n        const isFinished = this.gameStateService.isFinished(doc);\n        const isDarkStart = this.gameTypeService.isDarkStart(doc);\n        const isDarkMode = this.gameTypeService.isDarkMode(doc);\n        const isDarkFogged = this.gameTypeService.isDarkFogged(doc);\n        const isOrbital = this.gameTypeService.isOrbitalMode(doc);\n        const isKingOfTheHillMode = this.gameTypeService.isKingOfTheHillMode(doc);\n\n        let kingOfTheHillStar: Star | null = null;\n\n        if (isKingOfTheHillMode) {\n            kingOfTheHillStar = this.starService.getKingOfTheHillStar(doc);\n        }\n\n        // If dark start and game hasn't started yet OR is dark mode, then filter out\n        // any stars the player cannot see in scanning range.\n        if (!isFinished && (isDarkMode || (isDarkStart && !doc.state.startDate))) {\n            if (isDarkMode) {\n                doc.galaxy.stars = this.starService.filterStarsByScanningRangeAndWaypointDestinations(doc, perspectivePlayerIds);\n            } else {\n                doc.galaxy.stars = this.starService.filterStarsByScanningRange(doc, perspectivePlayerIds);\n            }\n        }\n\n        // Get all of the player's stars.\n        let playerStars: Star[] = [];\n        let playerScanningStars: Star[] = [];\n        let playerCarriersInOrbit: Carrier[] = [];\n\n        if (perspectivePlayerIds?.length) {\n            playerStars = this.starService.listStarsOwnedByPlayers(doc.galaxy.stars, perspectivePlayerIds);\n            playerScanningStars = this.starService.listStarsWithScanningRangeByPlayers(doc, perspectivePlayerIds);\n            playerCarriersInOrbit = this.carrierService.listCarriersOwnedByPlayersInOrbit(doc.galaxy.carriers, perspectivePlayerIds);\n        }\n\n        // Work out which ones are not in scanning range and clear their data.\n        doc.galaxy.stars = (doc.galaxy.stars as any[]) // TODO: Doing this to get around the whacky TS errors when deleting fields from the model\n            .map(s => {\n                delete s.shipsActual; // Don't need to send this back.\n\n                s.effectiveTechs = this.technologyService.getStarEffectiveTechnologyLevels(doc, s);\n\n                // Calculate the star's terraformed resources.\n                if (s.ownedByPlayerId) {\n                    s.terraformedResources = this.starService.calculateTerraformedResources(s, s.effectiveTechs.terraforming);\n                }\n\n                // Round the Natural Resources\n                s.naturalResources = this.starService.calculateActualNaturalResources(s);\n                s.manufacturing = this.shipService.calculateStarManufacturing(doc, s);\n\n                if (isOrbital) {\n                    s.locationNext = this.starMovementService.getNextLocation(doc, s);\n                }\n\n                // If the star is dead then it has no infrastructure.\n                if (this.starService.isDeadStar(s)) {\n                    delete s.infrastructure;\n                }\n\n                if (isKingOfTheHillMode) {\n                    s.isKingOfTheHillStar = kingOfTheHillStar != null && kingOfTheHillStar._id.toString() === s._id.toString();\n                }\n\n                // Ignore stars the player owns, they will always be visible.\n                let isOwnedByCurrentPlayer = playerStars.find(y => y._id.toString() === s._id.toString());\n\n                if (isOwnedByCurrentPlayer) {\n                    // Calculate infrastructure upgrades for the star.\n                    this.starUpgradeService.setUpgradeCosts(doc, s, s.terraformedResources!);\n\n                    if (s.specialistId) {\n                        s.specialist = this.specialistService.getByIdStar(s.specialistId);\n                    }\n\n                    // The player may be being spectated, so the ignore bulk upgrade stuff is only\n                    // relevant for the user player.\n                    if (userPlayer) {\n                        s.ignoreBulkUpgrade = (s.ignoreBulkUpgrade || null) || this.starService.resetIgnoreBulkUpgradeStatuses(s);\n                    } else {\n                        delete s.ignoreBulkUpgrade;\n                    }\n                    \n                    s.isInScanningRange = true;\n\n                    return s;\n                } else {\n                    // Remove fields that other users shouldn't see.\n                    delete s.ignoreBulkUpgrade;\n                }\n\n                s.isInScanningRange = isFinished ||                                                         // The game is finished\n                    this.starService.isStarWithinScanningRangeOfStars(doc, s, playerScanningStars) ||       // The star is within scanning range\n                    playerCarriersInOrbit.find(c => c.orbiting!.toString() === s._id.toString()) != null;   // The star has a friendly carrier in orbit\n\n                // If its in range then its all good, send the star back as is.\n                // Otherwise only return a subset of the data.\n                if (s.isInScanningRange) {\n                    if (s.specialistId) {\n                        s.specialist = this.specialistService.getByIdStar(s.specialistId);\n                    }\n\n                    if (isFinished) {\n                        return s;\n                    }\n\n                    if (s.isNebula) {\n                        delete s.infrastructure;\n                        delete s.naturalResources;\n                        delete s.terraformedResources;\n                        delete s.manufacturing;\n                    }\n\n                    let canSeeStarShips = perspectivePlayerIds?.length && this.starService.canPlayersSeeStarShips(s, perspectivePlayerIds);\n\n                    if (!canSeeStarShips) {\n                        s.ships = null;\n                    }\n\n                    return s;\n                } else {\n                    const mappedStar = {\n                        _id: s._id,\n                        name: s.name,\n                        ownedByPlayerId: s.ownedByPlayerId,\n                        location: s.location,\n                        locationNext: s.locationNext,\n                        warpGate: false, // Hide warp gates outside of scanning range\n                        isNebula: false, // Hide nebula outside of scanning range\n                        isAsteroidField: false, // Hide asteroid fields outside of scanning range\n                        isBinaryStar: false, // Hide outside of scanning range\n                        isBlackHole: false, // Hide outside of scanning range\n                        isPulsar: s.isPulsar,\n                        wormHoleToStarId: s.wormHoleToStarId,\n                        isKingOfTheHillStar: s.isKingOfTheHillStar,\n                        isInScanningRange: s.isInScanningRange,\n                        effectiveTechs: null\n                    } as any\n\n                    mappedStar.effectiveTechs = this.technologyService.getStarEffectiveTechnologyLevels(doc, mappedStar); // Redo effective techs\n\n                    if (isDarkFogged && !s.isInScanningRange) {\n                        mappedStar.ownedByPlayerId = null;\n                    }\n                    \n                    return mappedStar;\n                };\n            }) as any;\n    }\n\n    _setCarrierInfoDetailed(doc: Game, perspectivePlayerIds: DBObjectId[]) {\n        const isFinished = this.gameStateService.isFinished(doc);\n        const isOrbital = this.gameTypeService.isOrbitalMode(doc);\n\n        // If the game hasn't finished we need to filter and sanitize carriers.\n        if (!this.gameStateService.isFinished(doc)) {\n            doc.galaxy.carriers = this.carrierService.filterCarriersByScanningRange(doc, perspectivePlayerIds);\n\n            // Remove all waypoints (except those in transit) for all carriers that do not belong\n            // to the player.\n            doc.galaxy.carriers = this.carrierService.sanitizeCarriersByPlayers(doc, perspectivePlayerIds) as any;\n        }\n\n        // Populate the number of ticks it will take for all waypoints.\n        doc.galaxy.carriers\n            .forEach(c => {\n                c.effectiveTechs = this.technologyService.getCarrierEffectiveTechnologyLevels(doc, c);\n\n                this.waypointService.populateCarrierWaypointEta(doc, c);\n\n                if (c.specialistId) {\n                    c.specialist = this.specialistService.getByIdCarrier(c.specialistId)\n                }\n\n                let canSeeCarrierShips = isFinished || (perspectivePlayerIds?.length && this.carrierService.canPlayersSeeCarrierShips(doc, perspectivePlayerIds, c));\n\n                if (!canSeeCarrierShips) {\n                    c.ships = null;\n                }\n\n                if (isOrbital) {\n                    c.locationNext = this.starMovementService.getNextLocation(doc, c);\n                }\n            });\n    }\n\n    async _setPlayerInfoBasic(doc: Game, userPlayer: Player | null, perspectivePlayerIds: DBObjectId[] | null) {\n        const avatars = this.avatarService.listAllAvatars();\n\n        const isFinished = this.gameStateService.isFinished(doc);\n        const isDarkModeExtra = this.gameTypeService.isDarkModeExtra(doc);\n\n        let onlinePlayers = this.broadcastService.getOnlinePlayers(doc); // Need this for later.\n\n        // Get the list of all guilds associated to players, we'll need this later.\n        let guildUsers: GuildUserWithTag[] = [];\n\n        if (!this.gameTypeService.isAnonymousGame(doc)) {\n            let userIds: DBObjectId[] = doc.galaxy.players.filter(x => x.userId).map(x => x.userId!);\n            guildUsers = await this.guildUserService.listUsersWithGuildTags(userIds)\n        }\n\n        // Calculate which players are in scanning range.\n        let playersInRange: Player[] = [];\n\n        if (userPlayer) {\n            playersInRange = this.playerService.getPlayersWithinScanningRangeOfPlayer(doc, doc.galaxy.players, userPlayer);\n        }\n\n        let displayOnlineStatus = doc.settings.general.playerOnlineStatus === 'visible';\n\n        this._populatePlayerHasDuplicateIPs(doc);\n\n        // Sanitize other players by only returning basic info about them.\n        // We don't want players snooping on others via api responses containing sensitive info.\n        doc.galaxy.players = doc.galaxy.players.map(p => {\n            let isCurrentUserPlayer = userPlayer && p._id.toString() === userPlayer._id.toString();\n\n            // Set whether the user has the perspective of this player. This is used on the UI for spectator view.\n            p.hasPerspective = perspectivePlayerIds?.find(i => i.toString() === p._id.toString()) != null;\n\n            // Append the guild tag to the player alias.\n            let playerGuild: Guild | null = null;\n\n            if (p.userId) {\n                let guildUser = guildUsers.find(u => p.userId && u._id.toString() === p.userId.toString());\n\n                if (guildUser && guildUser.displayGuildTag === 'visible') {\n                    playerGuild = guildUser.guild;\n\n                    if (playerGuild) {\n                        p.alias += `[${playerGuild.tag}]`;\n                    }\n                }\n            }\n\n            // Calculate whether the user is AI controlled or not. If they are the current user\n            // then do not include psuedo afk. We only want to check that for other players.\n            p.isAIControlled = this.playerAfkService.isAIControlled(doc, p, !isCurrentUserPlayer);\n\n            p.isInScanningRange = playersInRange.find(x => x._id.toString() === p._id.toString()) != null;\n            p.shape = p.shape || 'circle'; // TODO: I don't know why the shape isn't being returned by mongoose defaults.\n            p.avatar = p.avatar ? avatars.find(a => a.id.toString() === p.avatar!.toString())!.file : null; // TODO: We should made the ID a number and not a string as it is an ID.\n\n            // If the user is in the game and it is the current\n            // player we are looking at then return everything.\n            if (isCurrentUserPlayer) {\n                userPlayer!.currentResearchTicksEta = this.researchService.calculateCurrentResearchETAInTicks(doc, userPlayer!);\n                userPlayer!.nextResearchTicksEta = this.researchService.calculateNextResearchETAInTicks(doc, userPlayer!);\n\n                delete p.notes; // Don't need to send this back.\n                delete p.lastSeenIP; // Super sensitive data.\n\n                p.isRealUser = true;\n                \n                return p;\n            }\n\n            // NOTE: From this point onwards, the player is NOT the current user.\n\n            if (!displayOnlineStatus) {\n                p.lastSeen = null;\n                p.isOnline = null;\n            } else {\n                // Work out whether the player is online.\n                p.isOnline = isCurrentUserPlayer || onlinePlayers.find(op => op._id.toString() === p._id.toString()) != null;\n            }\n\n            let reputation: PlayerReputation | null = null;\n\n            if (userPlayer) {\n                reputation = this.reputationService.getReputation(p, userPlayer)?.reputation;\n            }\n\n            let research: PlayerResearch | null = {\n                scanning: { \n                    level: p.research.scanning.level\n                },\n                hyperspace: { \n                    level: p.research.hyperspace.level\n                },\n                terraforming: { \n                    level: p.research.terraforming.level\n                },\n                experimentation: { \n                    level: p.research.experimentation.level\n                },\n                weapons: { \n                    level: p.research.weapons.level\n                },\n                banking: { \n                    level: p.research.banking.level\n                },\n                manufacturing: { \n                    level: p.research.manufacturing.level\n                },\n                specialists: { \n                    level: p.research.specialists.level\n                }\n            };\n\n            // In ultra dark mode games, research is visible \n            // only to players who are within scanning range.\n            if (!isFinished && isDarkModeExtra && !p.isInScanningRange) {\n                research = null;\n            }\n\n            let diplomacy: PlayerDiplomaticState[] = [];\n\n            if (userPlayer) {\n                diplomacy = this.diplomacyService.getFilteredDiplomacy(p, userPlayer);\n            }\n\n            // Return a subset of the user, key info only.\n            return {\n                _id: p._id,\n                isRealUser: p.userId != null,\n                isAIControlled: p.isAIControlled,\n                homeStarId: p.homeStarId,\n                colour: p.colour,\n                shape: p.shape,\n                research,\n                isOpenSlot: p.isOpenSlot,\n                isInScanningRange: p.isInScanningRange,\n                defeated: p.defeated,\n                defeatedDate: p.defeatedDate,\n                afk: p.afk,\n                ready: p.ready,\n                readyToQuit: p.readyToQuit,\n                missedTurns: p.missedTurns,\n                alias: p.alias,\n                avatar: p.avatar,\n                stats: p.stats,\n                reputation,\n                lastSeen: p.lastSeen,\n                isOnline: p.isOnline,\n                guild: playerGuild,\n                hasDuplicateIP: p.hasDuplicateIP,\n                hasFilledAfkSlot: p.hasFilledAfkSlot,\n                isKingOfTheHill: p.isKingOfTheHill,\n                hasPerspective: p.hasPerspective,\n                diplomacy,\n            };\n        }) as any;\n    }\n\n    _getPlayerPerspectives(game: Game, userId: DBObjectId | null) {\n        // Check if the user is playing in this game, if so they can only see from\n        // their own perspective.\n        let userPlayer = this._getUserPlayer(game, userId);\n\n        if (userPlayer) {\n            return [userPlayer._id];\n        }\n\n        // If the user is spectating then they can see from the perspectives of all\n        // players who they are spectating.\n        if (userId && this.spectatorService.isSpectatingEnabled(game)) {\n            let spectating = this.spectatorService.listSpectatingPlayers(game, userId);\n\n            if (spectating.length) {\n                return spectating.map(p => p._id);\n            }\n        }\n\n        return null;\n    }\n\n    _populatePlayerHasDuplicateIPs(game: Game) {\n        for (let player of game.galaxy.players) {\n            player.hasDuplicateIP = this.playerService.hasDuplicateLastSeenIP(game, player);\n        }\n    }\n\n    _hasGameStarted(doc: Game) {\n        return doc.state.startDate != null;\n    }\n\n    _clearPlayerCarriers(doc: Game) {\n        doc.galaxy.carriers = [];\n    }\n\n    async _maskGalaxy(game: Game, userPlayer: Player | null, isHistorical: boolean, tick: number | null) {\n        /*\n            Masking of galaxy data occurs here, it prevent players from seeing what other\n            players are doing until the tick has finished.\n\n            This will be a combination of the current state of the galaxy for the player and\n            the previous tick's galaxy data for other players.\n\n            The following logic will be applied to the galaxy:\n            1. Apply previous tick's data to all STARS the player does not own.\n                - Ships, specialist, warp gate and infrastructure needs to be reset.\n            2. Apply previous tick's data to all CARRIERS the player does not own.\n                - Remove any carriers that exist in the current tick but not in the previous tick.\n                - Ships, specialist and gift status needs to be reset.\n            3. Continue to run through current logic as we do today.\n        */\n\n        if (!this.gameStateService.isStarted(game) || tick === 0) {\n            return;\n        }\n\n        let history = await this.historyService.getHistoryByTick(game._id, tick);\n\n        if (!history) {\n            return;\n        }\n\n        // Support for legacy games, not all history for players/stars/carriers have been logged so\n        // bomb out if we're missing any of those.\n        if (!history.players.length || !history.stars.length || !history.carriers.length) {\n            return;\n        }\n\n        // If in historical mode, apply the previous tick's data for all players.\n        // If the user is requesting the current tick then we need to ensure that the\n        // data returned for players is based on the current state of the game because\n        // players can be defeated, afk'd, ready etc. Player data does not need to be\n        // masked if requesting the current tick.\n        if (isHistorical) {\n            for (let i = 0; i < game.galaxy.players.length; i++) {\n                let gamePlayer = game.galaxy.players[i];\n\n                let historyPlayer = history.players.find(x => x.playerId.toString() === gamePlayer._id.toString());\n\n                if (historyPlayer) {\n                    gamePlayer.userId = historyPlayer.userId;\n                    gamePlayer.alias = historyPlayer.alias;\n                    gamePlayer.avatar = historyPlayer.avatar;\n                    gamePlayer.researchingNow = historyPlayer.researchingNow;\n                    gamePlayer.researchingNext = historyPlayer.researchingNext;\n                    gamePlayer.credits = historyPlayer.credits;\n                    gamePlayer.creditsSpecialists = historyPlayer.creditsSpecialists;\n                    gamePlayer.isOpenSlot = historyPlayer.isOpenSlot;\n                    gamePlayer.defeated = historyPlayer.defeated;\n                    gamePlayer.defeatedDate = historyPlayer.defeatedDate;\n                    gamePlayer.afk = historyPlayer.afk;\n                    gamePlayer.research = historyPlayer.research;\n                    gamePlayer.ready = historyPlayer.ready;\n                    gamePlayer.readyToQuit = historyPlayer.readyToQuit;\n                }\n            }\n        }\n\n        // Apply previous tick's data to all STARS the player does not own.\n        // If historical mode, then its all star data in the requested tick.\n        // If not historical mode, then replace non-player owned star data.\n        for (let i = 0; i < game.galaxy.stars.length; i++) {\n            let gameStar = game.galaxy.stars[i];\n\n            if (!isHistorical && userPlayer && gameStar.ownedByPlayerId && gameStar.ownedByPlayerId.toString() === userPlayer._id.toString()) {\n                continue;\n            }\n\n            let historyStar = history.stars.find(x => x.starId.toString() === gameStar._id.toString());\n\n            if (historyStar) {\n                // If the player has abandoned the star in the current tick, then display that representation of the star\n                // instead of the historical version.\n                if (!isHistorical && userPlayer && historyStar.ownedByPlayerId && gameStar.ownedByPlayerId == null && historyStar.ownedByPlayerId.toString() === userPlayer._id.toString()) {\n                    continue;\n                }\n\n                gameStar.ownedByPlayerId = historyStar.ownedByPlayerId;\n                gameStar.naturalResources = historyStar.naturalResources;\n                gameStar.ships = historyStar.ships;\n                gameStar.shipsActual = historyStar.shipsActual;\n                gameStar.specialistId = historyStar.specialistId;\n                gameStar.homeStar = historyStar.homeStar;\n                gameStar.warpGate = historyStar.warpGate;\n                gameStar.ignoreBulkUpgrade = historyStar.ignoreBulkUpgrade;\n                gameStar.infrastructure = historyStar.infrastructure;\n                gameStar.location = historyStar.location == null || (historyStar.location.x == null || historyStar.location.y == null) ? gameStar.location : historyStar.location; // TODO: May not have history for the star (BR Mode). Can delete this in a few months after the history is cleaned.\n            }\n        }\n\n        // Apply previous tick's data to all CARRIERS the player does not own.\n        // If historical mode, then its all carrier data in the requested tick.\n        // If not historical mode, then replace non-player owned carrier data.\n        for (let i = 0; i < game.galaxy.carriers.length; i++) {\n            let gameCarrier = game.galaxy.carriers[i];\n\n            if (!isHistorical && userPlayer && gameCarrier.ownedByPlayerId!.toString() === userPlayer._id.toString()) {\n                continue;\n            }\n\n            let historyCarrier = history.carriers.find(x => x.carrierId.toString() === gameCarrier._id.toString());\n\n            // Remove any carriers that exist in the current tick but not in the previous tick.\n            if (!historyCarrier) {\n                game.galaxy.carriers.splice(i, 1);\n                i--;\n                continue;\n            }\n\n            gameCarrier.ownedByPlayerId = historyCarrier.ownedByPlayerId;\n            gameCarrier.name = historyCarrier.name;\n            gameCarrier.orbiting = historyCarrier.orbiting;\n            gameCarrier.ships = historyCarrier.ships;\n            gameCarrier.specialistId = historyCarrier.specialistId;\n            gameCarrier.isGift = historyCarrier.isGift;\n            gameCarrier.location = historyCarrier.location;\n            gameCarrier.waypoints = historyCarrier.waypoints as CarrierWaypoint[];\n        }\n\n        // Add any carriers that were in the previous tick that do not exist in the current tick\n        // This is only applicable when requesting a historical tick as the current tick may have\n        // destroyed carriers.\n        if (isHistorical) {\n            for (let historyCarrier of history.carriers) {\n                let gameCarrier = game.galaxy.carriers.find(x => x._id.toString() === historyCarrier.carrierId.toString());\n                \n                if (!gameCarrier) {\n                    game.galaxy.carriers.push(historyCarrier as any);\n                }\n            }\n        }\n\n        // Add any carriers that were destroyed in orbit in the current tick.\n        // This is to account for abandoned stars where carriers are destroyed.\n        if (!isHistorical) {\n            const carrierInOrbitToAdd = history.carriers.filter(c => c.orbiting && (!userPlayer || c.ownedByPlayerId!.toString() !== userPlayer._id.toString()))\n\n            for (let historyCarrier of carrierInOrbitToAdd) {\n                let gameCarrier = game.galaxy.carriers.find(x => x._id.toString() === historyCarrier.carrierId.toString());\n                \n                if (!gameCarrier) {\n                    game.galaxy.carriers.push(historyCarrier as any);\n                }\n            }\n        }\n\n        // If the user is requesting a specific tick then we also need to update the game state to match\n        if (isHistorical) {\n            game.state.tick = history.tick\n            game.state.productionTick = history.productionTick\n        }\n    }\n\n    _appendStarsPendingDestructionFlag(game: Game) {\n        let pendingStars = this.battleRoyaleService.getStarsToDestroy(game);\n\n        for (let pendingStar of pendingStars) {\n            pendingStar.targeted = true;\n        }\n    }\n\n};\n"],
  "mappings": "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",
  "names": ["ValidationError"]
}
