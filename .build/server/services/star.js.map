{
  "version": 3,
  "sources": ["../../../server/services/star.ts"],
  "sourcesContent": ["const EventEmitter = require('events');\nconst mongoose = require('mongoose');\nimport { DBObjectId } from './types/DBObjectId';\nimport ValidationError from '../errors/validation';\nimport Repository from './repository';\nimport { Carrier } from './types/Carrier';\nimport { Game, GameSettings } from './types/Game';\nimport { Location } from './types/Location';\nimport { MapObject, MapObjectWithVisibility } from './types/Map';\nimport { Player } from './types/Player';\nimport { InfrastructureType, NaturalResources, Star, StarCaptureResult, TerraformedResources } from './types/Star';\nimport { User } from './types/User';\nimport DistanceService from './distance';\nimport GameStateService from './gameState';\nimport GameTypeService from './gameType';\nimport NameService from './name';\nimport RandomService from './random';\nimport SpecialistService from './specialist';\nimport StarDistanceService from './starDistance';\nimport TechnologyService from './technology';\nimport UserService from './user';\nconst RNG = require('random-seed');\n\nexport const StarServiceEvents = {\n    onPlayerStarAbandoned: 'onPlayerStarAbandoned',\n    onPlayerStarDied: 'onPlayerStarDied',\n    onPlayerStarReignited: 'onPlayerStarReignited'\n}\n\nexport default class StarService extends EventEmitter {\n\n    gameRepo: Repository<Game>;\n    randomService: RandomService;\n    nameService: NameService;\n    distanceService: DistanceService;\n    starDistanceService: StarDistanceService;\n    technologyService: TechnologyService;\n    specialistService: SpecialistService;\n    userService: UserService;\n    gameTypeService: GameTypeService;\n    gameStateService: GameStateService;\n\n    constructor(\n        gameRepo: Repository<Game>,\n        randomService: RandomService,\n        nameService: NameService,\n        distanceService: DistanceService,\n        starDistanceService: StarDistanceService,\n        technologyService: TechnologyService,\n        specialistService: SpecialistService,\n        userService: UserService,\n        gameTypeService: GameTypeService,\n        gameStateService: GameStateService\n    ) {\n        super();\n\n        this.gameRepo = gameRepo;\n        this.randomService = randomService;\n        this.nameService = nameService;\n        this.distanceService = distanceService;\n        this.starDistanceService = starDistanceService;\n        this.technologyService = technologyService;\n        this.specialistService = specialistService;\n        this.userService = userService;\n        this.gameTypeService = gameTypeService;\n        this.gameStateService = gameStateService;\n    }\n\n    generateUnownedStar(name: string, location: Location, naturalResources: NaturalResources) {\n        naturalResources = naturalResources || {\n            economy: 0,\n            industry: 0,\n            science: 0\n        };\n\n        return {\n            _id: mongoose.Types.ObjectId(),\n            name,\n            location,\n            naturalResources,\n            infrastructure: {\n                economy: 0,\n                industry: 0,\n                science: 0\n            }\n        };\n    }\n\n    generateCustomGalaxyStar(name: string, star: Star) {\n      return {\n        _id: star._id,\n        name: name,\n        naturalResources: star.naturalResources,\n        location: star.location,\n        infrastructure: star.infrastructure,\n        homeStar: star.homeStar,\n        warpGate: star.warpGate,\n        isNebula: star.isNebula,\n        isAsteroidField: star.isAsteroidField,\n        isBinaryStar: star.isBinaryStar,\n        isBlackHole: star.isBlackHole,\n        isPulsar: star.isPulsar,\n        wormHoleToStarId: star.wormHoleToStarId,\n        specialistId: star.specialistId\n      }\n    }\n\n    generateStarPosition(game: Game, originX: number, originY: number, radius: number) {\n        if (radius == null) {\n            radius = game.constants.distances.maxDistanceBetweenStars;\n        }\n\n        return this.randomService.getRandomPositionInCircleFromOrigin(originX, originY, radius);\n    }\n\n    getById(game: Game, id: DBObjectId | string) {\n        return this.getByIdBS(game, id); // Experimental\n    }\n\n    getByIdBS(game: Game, id: DBObjectId | string) {\n        let start = 0;\n        let end = game.galaxy.stars.length - 1;\n\n        while (start <= end) {\n            let middle = Math.floor((start + end) / 2);\n            let star = game.galaxy.stars[middle];\n\n            if (star._id.toString() === id.toString()) {\n                // found the id\n                return star;\n            } else if (star._id.toString() < id.toString()) {\n                // continue searching to the right\n                start = middle + 1;\n            } else {\n                // search searching to the left\n                end = middle - 1;\n            }\n        }\n\n        // id wasn't found\n        // Return the old way\n        return game.galaxy.stars.find(s => s._id.toString() === id.toString())!;\n    }\n\n    setupHomeStar(game: Game, homeStar: Star, player: Player, gameSettings: GameSettings) {\n        // Set up the home star\n        player.homeStarId = homeStar._id;\n        homeStar.ownedByPlayerId = player._id;\n        homeStar.shipsActual = Math.max(gameSettings.player.startingShips, 1); // Must be at least 1 star at the home star so that a carrier can be built there.\n        homeStar.ships = homeStar.shipsActual;\n        homeStar.homeStar = true;\n        homeStar.warpGate = false;\n        homeStar.specialistId = null;\n\n        this.resetIgnoreBulkUpgradeStatuses(homeStar);\n\n        if (gameSettings.galaxy.galaxyType !== 'custom') { \n            homeStar.naturalResources.economy = game.constants.star.resources.maxNaturalResources;\n            homeStar.naturalResources.industry = game.constants.star.resources.maxNaturalResources;\n            homeStar.naturalResources.science = game.constants.star.resources.maxNaturalResources;\n        }\n\n        // Seed the home star with the starting infrastructure.\n        homeStar.infrastructure.economy = gameSettings.player.startingInfrastructure.economy;\n        homeStar.infrastructure.industry = gameSettings.player.startingInfrastructure.industry;\n        homeStar.infrastructure.science = gameSettings.player.startingInfrastructure.science;\n    }\n\n    getPlayerHomeStar(stars: Star[], player: Player) {\n        return this.listStarsOwnedByPlayer(stars, player._id).find(s => s._id.toString() === player.homeStarId!.toString());\n    }\n\n    listStarsOwnedByPlayer(stars: Star[], playerId: DBObjectId) {\n        return stars.filter(s => s.ownedByPlayerId && s.ownedByPlayerId.toString() === playerId.toString());\n    }\n\n    listStarsOwnedByPlayers(stars: Star[], playerIds: DBObjectId[]) {\n        const ids = playerIds.map(p => p.toString());\n\n        return stars.filter(s => s.ownedByPlayerId && ids.includes(s.ownedByPlayerId.toString()));\n    }\n\n    isOwnedByPlayer(star: Star, player: Player) {\n        return star.ownedByPlayerId && star.ownedByPlayerId.toString() === player._id.toString();\n    }\n\n    listStarsAliveOwnedByPlayer(stars: Star[], playerId: DBObjectId) {\n        return this.listStarsOwnedByPlayer(stars, playerId).filter(s => !this.isDeadStar(s));\n    }\n\n    listStarIdsWithPlayerCarriersInOrbit(game: Game, playerId: DBObjectId): string[] {\n        return game.galaxy.carriers\n            .filter(c => c.orbiting)\n            .filter(c => c.ownedByPlayerId!.toString() === playerId.toString())\n            .map(c => c.orbiting!.toString());\n    }\n\n    listStarIdsWithPlayersCarriersInOrbit(game: Game, playerIds: DBObjectId[]): string[] {\n        const ids = playerIds.map(p => p.toString());\n\n        return game.galaxy.carriers\n            .filter(c => c.orbiting)\n            .filter(c => ids.includes(c.ownedByPlayerId!.toString()))\n            .map(c => c.orbiting!.toString());\n    }\n\n    listStarsWithScanningRangeByPlayer(game: Game, playerId: DBObjectId): Star[] {\n        let starIds: string[] = this.listStarsOwnedByPlayer(game.galaxy.stars, playerId).map(s => s._id.toString());\n\n        if (game.settings.diplomacy.enabled === 'enabled') { // This never occurs when alliances is disabled.\n            starIds = starIds.concat(this.listStarIdsWithPlayerCarriersInOrbit(game, playerId));\n        }\n\n        starIds = [...new Set(starIds)];\n\n        return starIds\n            .map(id => this.getById(game, id))\n            .filter(s => !this.isDeadStar(s));\n    }\n\n    listStarsWithScanningRangeByPlayers(game: Game, playerIds: DBObjectId[]): Star[] {\n        let starIds: string[] = this.listStarsOwnedByPlayers(game.galaxy.stars, playerIds).map(s => s._id.toString());\n\n        if (game.settings.diplomacy.enabled === 'enabled') { // This never occurs when alliances is disabled.\n            starIds = starIds.concat(this.listStarIdsWithPlayersCarriersInOrbit(game, playerIds));\n        }\n\n        starIds = [...new Set(starIds)];\n\n        return starIds\n            .map(id => this.getById(game, id))\n            .filter(s => !this.isDeadStar(s));\n    }\n\n    listStarsOwnedOrInOrbitByPlayers(game: Game, playerIds: DBObjectId[]): Star[] {\n        let starIds: string[] = this.listStarsOwnedByPlayers(game.galaxy.stars, playerIds).map(s => s._id.toString());\n\n        if (game.settings.diplomacy.enabled === 'enabled') { // Don't need to check in orbit carriers if alliances is disabled\n            starIds = starIds.concat(this.listStarIdsWithPlayersCarriersInOrbit(game, playerIds));\n        }\n\n        starIds = [...new Set(starIds)];\n\n        return starIds\n            .map(id => this.getById(game, id));\n    }\n\n    listStarsOwnedByPlayerBulkIgnored(stars: Star[], playerId: DBObjectId, infrastructureType: InfrastructureType) {\n        return this.listStarsOwnedByPlayer(stars, playerId)\n            .filter(s => s.ignoreBulkUpgrade![infrastructureType]);\n    }\n\n    isStarWithinScanningRangeOfStars(game: Game, star: Star, stars: Star[]) {\n        // Pulsars are considered to be always in scanning range.\n        // Note: They are not visible until the game starts to prevent pre-teaming.\n        if (star.isPulsar && this.gameStateService.isStarted(game)) {\n            return true;\n        }\n\n        // Go through all of the stars one by one and calculate\n        // whether any one of them is within scanning range.\n        for (let otherStar of stars) {\n            if (otherStar.ownedByPlayerId == null) {\n                continue;\n            }\n\n            // Use the effective scanning range of the other star to check if it can \"see\" the given star.\n            let effectiveTechs = this.technologyService.getStarEffectiveTechnologyLevels(game, otherStar);\n            let scanningRangeDistance = this.distanceService.getScanningDistance(game, effectiveTechs.scanning);\n            let distance = this.starDistanceService.getDistanceBetweenStars(star, otherStar);\n\n            if (distance <= scanningRangeDistance) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    filterStarsByScanningRange(game: Game, playerIds: DBObjectId[]) {\n        // Stars may have different scanning ranges independently so we need to check\n        // each star to check what is within its scanning range.\n        let starsOwnedOrInOrbit = this.listStarsOwnedOrInOrbitByPlayers(game, playerIds);\n        let starsWithScanning = starsOwnedOrInOrbit.filter(s => !this.isDeadStar(s));\n\n        // Seed the stars that are in range to be the stars owned or are in orbit of.\n        let starsInRange: MapObjectWithVisibility[] = starsOwnedOrInOrbit.map(s => {\n            return {\n                _id: s._id,\n                location: s.location,\n                ownedByPlayerId: s.ownedByPlayerId\n            }\n        });\n\n        // Calculate which stars need to be checked excluding the ones that the player can definitely see.\n        let starsToCheck: MapObjectWithVisibility[] = game.galaxy.stars\n            .filter(s => starsInRange.find(r => r._id.toString() === s._id.toString()) == null)\n            .map(s => {\n                return {\n                    _id: s._id,\n                    location: s.location,\n                    ownedByPlayerId: s.ownedByPlayerId,\n                    isAlwaysVisible: s.isPulsar\n                }\n            });\n\n        for (let star of starsWithScanning) {\n            let starIds = this.getStarsWithinScanningRangeOfStarByStarIds(game, star, starsToCheck);\n\n            for (let starId of starIds) {\n                if (starsInRange.find(x => x._id.toString() === starId._id.toString()) == null) {\n                    starsInRange.push(starId);\n                    starsToCheck.splice(starsToCheck.indexOf(starId), 1);\n                }\n            }\n\n            // If we've checked all stars then no need to continue.\n            if (!starsToCheck.length) {\n                break;\n            }\n        }\n\n        // If worm holes are present, then ensure that any owned star OR star in orbit\n        // also has its paired star visible.\n        if (game.settings.specialGalaxy.randomWormHoles) {\n            let wormHoleStars = starsOwnedOrInOrbit\n                .filter(s => s.wormHoleToStarId)\n                .map(s => {\n                    return {\n                        source: s,\n                        destination: this.getById(game, s.wormHoleToStarId!)\n                    };\n                });\n                \n            for (let wormHoleStar of wormHoleStars) {\n                if (starsInRange.find(s => s._id.toString() === wormHoleStar.destination._id.toString()) == null) {\n                    starsInRange.push({\n                        _id: wormHoleStar.destination._id,\n                        location: wormHoleStar.destination.location,\n                        ownedByPlayerId: wormHoleStar.destination.ownedByPlayerId\n                    });\n                }\n            }\n        }\n\n        return starsInRange.map(s => this.getById(game, s._id));\n    }\n\n    filterStarsByScanningRangeAndWaypointDestinations(game: Game, playerIds: DBObjectId[]) {\n        // Get all stars within the player's normal scanning vision.\n        let starsInScanningRange = this.filterStarsByScanningRange(game, playerIds);\n\n        const ids = playerIds.map(p => p.toString());\n\n        // If in dark mode then we need to also include any stars that are \n        // being travelled to by carriers in transit for the current player.\n        let inTransitStars = game.galaxy.carriers\n            .filter(c => !c.orbiting)\n            .filter(c => ids.includes(c.ownedByPlayerId!.toString()))\n            .map(c => c.waypoints[0].destination)\n            .map(d => this.getById(game, d));\n\n        for (let transitStar of inTransitStars) {\n            if (starsInScanningRange.indexOf(transitStar) < 0) {\n                starsInScanningRange.push(transitStar);\n            }\n        }\n\n        return starsInScanningRange;\n    }\n\n    getStarsWithinScanningRangeOfStarByStarIds(game: Game, star: Star, stars: MapObjectWithVisibility[]) {\n        // If the star isn't owned then it cannot have a scanning range\n        if (star.ownedByPlayerId == null) {\n            return [];\n        }\n\n        // Calculate the scanning distance of the given star.\n        let effectiveTechs = this.technologyService.getStarEffectiveTechnologyLevels(game, star, true);\n        let scanningRangeDistance = this.distanceService.getScanningDistance(game, effectiveTechs.scanning);\n\n        // Go through all stars and find each star that is in scanning range.\n        let starsInRange = stars.filter(s => {\n            return s.isAlwaysVisible || this.starDistanceService.getDistanceBetweenStars(s, star) <= scanningRangeDistance;\n        });\n\n        return starsInRange;\n    }\n\n    calculateActualNaturalResources(star: Star): NaturalResources {\n        return {\n            economy: Math.max(Math.floor(star.naturalResources.economy), 0),\n            industry: Math.max(Math.floor(star.naturalResources.industry), 0),\n            science: Math.max(Math.floor(star.naturalResources.science), 0)\n        }\n    }\n\n    calculateTerraformedResources(star: Star, terraforming: number): TerraformedResources {\n        return {\n            economy: this.calculateTerraformedResource(star.naturalResources.economy, terraforming),\n            industry: this.calculateTerraformedResource(star.naturalResources.industry, terraforming),\n            science: this.calculateTerraformedResource(star.naturalResources.science, terraforming)\n        }\n    }\n\n    calculateTerraformedResource(naturalResource: number, terraforming: number) {        \n        return Math.floor(naturalResource + (5 * terraforming));\n    }\n\n    async abandonStar(game: Game, player: Player, starId: DBObjectId) {\n        // Get the star.\n        let star = game.galaxy.stars.find(x => x._id.toString() === starId.toString())!;\n\n        // Check whether the star is owned by the player\n        if ((star.ownedByPlayerId || '').toString() !== player._id.toString()) {\n            throw new ValidationError(`Cannot abandon a star that is not owned by the player.`);\n        }\n\n        this.resetIgnoreBulkUpgradeStatuses(star);\n\n        // Destroy the carriers owned by the player who abandoned the star.\n        // Note: If an ally is currently in orbit then they will capture the star on the next tick.\n        let playerCarriers = game.galaxy.carriers\n            .filter(x => \n                x.orbiting\n                && x.orbiting.toString() === star._id.toString()\n                && x.ownedByPlayerId!.toString() === player._id.toString()\n            );\n\n        for (let playerCarrier of playerCarriers) {\n            game.galaxy.carriers.splice(game.galaxy.carriers.indexOf(playerCarrier), 1);\n        }\n\n        star.ownedByPlayerId = null;\n        star.shipsActual = 0;\n        star.ships = star.shipsActual;\n\n        await game.save();\n\n        this.emit(StarServiceEvents.onPlayerStarAbandoned, {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            player,\n            star\n        });\n    }\n\n    isStarPairWormHole(sourceStar: Star, destinationStar: Star) {\n        return sourceStar\n            && destinationStar\n            && sourceStar.wormHoleToStarId\n            && destinationStar.wormHoleToStarId\n            && sourceStar.wormHoleToStarId.toString() === destinationStar._id.toString()\n            && destinationStar.wormHoleToStarId.toString() === sourceStar._id.toString();\n    }\n\n    canPlayersSeeStarShips(star: Star, playerIds: DBObjectId[]) {\n        const ids = playerIds.map(p => p.toString());\n        const isOwnedByPlayer = ids.includes((star.ownedByPlayerId || '').toString());\n\n        if (isOwnedByPlayer) {\n            return true;\n        }\n\n        // Nebula always hides ships for other players\n        if (star.isNebula) {\n            return false;\n        }\n\n        if (star.specialistId) {\n            let specialist = this.specialistService.getByIdStar(star.specialistId);\n\n            // If the star has a hideShips spec and is not owned by the given player\n            // then that player cannot see the carrier's ships.\n            if (specialist && specialist.modifiers.special && specialist.modifiers.special.hideShips) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    async claimUnownedStar(game: Game, gameUsers: User[], star: Star, carrier: Carrier) {\n        if (star.ownedByPlayerId) {\n            throw new ValidationError(`Cannot claim an owned star`);\n        }\n\n        star.ownedByPlayerId = carrier.ownedByPlayerId;\n\n        this.resetIgnoreBulkUpgradeStatuses(star);\n\n        // Weird scenario, but could happen.\n        if (carrier.isGift) {\n            carrier.isGift = false;\n        }\n\n        let carrierPlayer = game.galaxy.players.find(p => p._id.toString() === carrier.ownedByPlayerId!.toString())!;\n        let carrierUser = gameUsers.find(u => carrierPlayer.userId && u._id.toString() === carrierPlayer.userId.toString()) || null;\n\n        if (carrierUser && !carrierPlayer.defeated && !this.gameTypeService.isTutorialGame(game)) {\n            carrierUser.achievements.combat.stars.captured++;\n\n            if (star.homeStar) {\n                carrierUser.achievements.combat.homeStars.captured++;\n            }\n        }\n    }\n\n    applyStarSpecialistSpecialModifiers(game: Game) {\n        // NOTE: Specialist modifiers that affect stars on tick only apply\n        // to stars that are owned by players. i.e NOT abandoned stars.\n        for (let i = 0; i < game.galaxy.stars.length; i++) {\n            let star = game.galaxy.stars[i];\n\n            if (star.ownedByPlayerId) {\n                if (star.specialistId) {\n                    let specialist = this.specialistService.getByIdStar(star.specialistId);\n\n                    if (specialist && specialist.modifiers.special) {\n                        if (specialist.modifiers.special.addNaturalResourcesOnTick) {\n                            this.addNaturalResources(game, star, specialist.modifiers.special.addNaturalResourcesOnTick);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    isDeadStar(star: Star) {\n        if (!star.naturalResources) {\n            return true;\n        }\n        \n        return star.naturalResources.economy <= 0 && star.naturalResources.industry <= 0 && star.naturalResources.science <= 0;\n    }\n\n    addNaturalResources(game: Game, star: Star, amount: number) {\n        let wasDeadStar = this.isDeadStar(star);\n\n        if (this.gameTypeService.isSplitResources(game)) {\n            let total = star.naturalResources.economy + star.naturalResources.industry + star.naturalResources.science;\n\n            star.naturalResources.economy += 3 * amount * (star.naturalResources.economy / total);\n            star.naturalResources.industry += 3 * amount * (star.naturalResources.industry / total);\n            star.naturalResources.science += 3 * amount * (star.naturalResources.science / total);\n        } else {\n            star.naturalResources.economy += amount;\n            star.naturalResources.industry += amount;\n            star.naturalResources.science += amount;\n        }\n\n        // TODO: Allow negative values here so we can keep the ratio.\n        if (Math.floor(star.naturalResources.economy) <= 0) {\n            star.naturalResources.economy = 0;\n        }\n\n        if (Math.floor(star.naturalResources.industry) <= 0) {\n            star.naturalResources.industry = 0;\n        }\n\n        if (Math.floor(star.naturalResources.science) <= 0) {\n            star.naturalResources.science = 0;\n        }\n        \n        // if the star reaches 0 of all resources then reduce the star to a dead hunk.\n        if(this.isDeadStar(star)) {\n            star.specialistId = null;\n            star.warpGate = false;\n            star.infrastructure.economy = 0;\n            star.infrastructure.industry = 0;\n            star.infrastructure.science = 0;\n\n            if (star.ownedByPlayerId) {\n                this.emit(StarServiceEvents.onPlayerStarDied, {\n                    gameId: game._id,\n                    gameTick: game.state.tick,\n                    playerId: star.ownedByPlayerId,\n                    starId: star._id,\n                    starName: star.name\n                });\n            }\n        }\n        // If it was a dead star but is now not a dead star then it has been reignited.\n        else if (wasDeadStar && star.ownedByPlayerId) {\n            this.emit(StarServiceEvents.onPlayerStarReignited, {\n                gameId: game._id,\n                gameTick: game.state.tick,\n                playerId: star.ownedByPlayerId,\n                starId: star._id,\n                starName: star.name\n            });\n        }\n    }\n\n    reigniteDeadStar(game: Game, star: Star, naturalResources: NaturalResources) {\n        if (!this.isDeadStar(star)) {\n            throw new Error('The star cannot be reignited, it is not dead.');\n        }\n\n        star.naturalResources = naturalResources;\n\n        if (star.ownedByPlayerId) {\n            this.emit(StarServiceEvents.onPlayerStarReignited, {\n                gameId: game._id,\n                gameTick: game.state.tick,\n                playerId: star.ownedByPlayerId,\n                starId: star._id,\n                starName: star.name\n            });\n        }\n    }\n\n    destroyStar(game: Game, star: Star) {\n        game.galaxy.stars.splice(game.galaxy.stars.indexOf(star), 1);\n\n        game.state.stars--;\n\n        // If the star was paired with a worm hole, then clear the other side.\n        if (star.wormHoleToStarId) {\n            const wormHolePairStar = this.getById(game, star.wormHoleToStarId);\n\n            if (wormHolePairStar) {\n                wormHolePairStar.wormHoleToStarId = null;\n            }\n        }\n\n        // Recalculate how many stars are needed for victory in conquest mode.\n        if (game.settings.general.mode === 'conquest') {\n            // TODO: Find a better place for this as its shared in the gameCreate service.\n            switch (game.settings.conquest.victoryCondition) {\n                case 'starPercentage':\n                    game.state.starsForVictory = Math.ceil((game.state.stars / 100) * game.settings.conquest.victoryPercentage);\n                    break;\n                case 'homeStarPercentage':\n                    game.state.starsForVictory = Math.ceil((game.settings.general.playerLimit / 100) * game.settings.conquest.victoryPercentage);\n                    break;\n                default:\n                    throw new Error(`Unsupported conquest victory condition: ${game.settings.conquest.victoryCondition}`)\n            }\n        }\n    }\n\n    async toggleIgnoreBulkUpgrade(game: Game, player: Player, starId: DBObjectId, infrastructureType: InfrastructureType) {\n        let star = this.getById(game, starId);\n\n        if (!star.ownedByPlayerId || star.ownedByPlayerId.toString() !== player._id.toString()) {\n            throw new ValidationError(`You do not own this star.`);\n        }\n\n        let newValue = star.ignoreBulkUpgrade![infrastructureType] ? false : true;\n\n        let updateObject = {\n            $set: {}\n        };\n\n        updateObject['$set'][`galaxy.stars.$.ignoreBulkUpgrade.${infrastructureType}`] = newValue\n\n        await this.gameRepo.updateOne({\n            _id: game._id,\n            'galaxy.stars._id': starId\n        }, updateObject);\n    }\n\n    async toggleIgnoreBulkUpgradeAll(game: Game, player: Player, starId: DBObjectId, ignoreStatus: boolean) {\n        let star = this.getById(game, starId);\n\n        if (!star.ownedByPlayerId || star.ownedByPlayerId.toString() !== player._id.toString()) {\n            throw new ValidationError(`You do not own this star.`);\n        }\n\n        await this.gameRepo.updateOne({\n            _id: game._id,\n            'galaxy.stars._id': starId\n        }, {\n            $set: {\n                'galaxy.stars.$.ignoreBulkUpgrade.economy': ignoreStatus,\n                'galaxy.stars.$.ignoreBulkUpgrade.industry': ignoreStatus,\n                'galaxy.stars.$.ignoreBulkUpgrade.science': ignoreStatus\n            }\n        });\n    }\n\n    captureStar(game: Game, star: Star, owner: Player, defenders: Player[], defenderUsers: User[], attackers: Player[], attackerUsers: User[], attackerCarriers: Carrier[]): StarCaptureResult {\n        const isTutorialGame = this.gameTypeService.isTutorialGame(game);\n\n        let specialist = this.specialistService.getByIdStar(star.specialistId);\n\n        // If the star had a specialist that destroys infrastructure then perform demolition.\n        if (specialist && specialist.modifiers.special && specialist.modifiers.special.destroyInfrastructureOnLoss) {\n            star.specialistId = null;\n            star.infrastructure.economy = 0;\n            star.infrastructure.industry = 0;\n            star.infrastructure.science = 0;\n            star.warpGate = false;\n        }\n\n        // If multiple players are capturing the star, then the player who owns the carrier with the most\n        // ships will capture it, otherwise the closest carrier gets it.\n        let capturePlayerId = attackerCarriers.sort((a, b) => {\n            // Sort by ship count (highest ships first)\n            if (a.ships! > b.ships!) return -1;\n            if (a.ships! < b.ships!) return 1;\n\n            // Then by distance (closest carrier first)\n            return (a.distanceToDestination || 0) - (b.distanceToDestination || 0);\n        })[0].ownedByPlayerId!;\n\n        // Capture the star.\n        let newStarPlayer = attackers.find(p => p._id.toString() === capturePlayerId.toString())!;\n        let newStarUser = attackerUsers.find(u => newStarPlayer.userId && u._id.toString() === newStarPlayer.userId.toString());\n        let newStarPlayerCarriers = attackerCarriers.filter(c => c.ownedByPlayerId!.toString() === newStarPlayer._id.toString());\n\n        star.ownedByPlayerId = newStarPlayer._id;\n        star.shipsActual = 0;\n        star.ships = 0;\n\n        // If star capture reward is enabled, destroy the economic infrastructure\n        // and add the capture amount to the attacker\n        let captureReward = 0;\n\n        if (game.settings.specialGalaxy.starCaptureReward === 'enabled') {\n            captureReward = star.infrastructure.economy! * game.constants.star.captureRewardMultiplier; // Attacker gets X credits for every eco destroyed.\n    \n            // Check to see whether to double the capture reward.\n            let captureRewardMultiplier = this.specialistService.hasAwardDoubleCaptureRewardSpecialist(newStarPlayerCarriers);\n    \n            captureReward = Math.floor(captureReward * captureRewardMultiplier);\n\n            newStarPlayer.credits += captureReward;\n\n            star.infrastructure.economy = 0;\n        }\n\n        // Reset the ignore bulk upgrade statuses as it has been captured by a new player.\n        this.resetIgnoreBulkUpgradeStatuses(star);\n\n        const oldStarUser = defenderUsers.find(u => owner.userId && u._id.toString() === owner.userId.toString()) || null;\n\n        if (!isTutorialGame) {\n            if (oldStarUser && !owner.defeated) {\n                oldStarUser.achievements.combat.stars.lost++;\n    \n                if (star.homeStar) {\n                    oldStarUser.achievements.combat.homeStars.lost++;\n                }\n            }\n            \n            if (newStarUser && !newStarPlayer.defeated) {\n                newStarUser.achievements.combat.stars.captured++;\n    \n                if (star.homeStar) {\n                    newStarUser.achievements.combat.homeStars.captured++;\n                }\n            }\n        }\n\n        if (this.gameTypeService.isKingOfTheHillMode(game) && \n            this.gameStateService.isCountingDownToEndInLastCycle(game) &&\n            this.isKingOfTheHillStar(star)) {\n            this.gameStateService.setCountdownToEndToOneCycle(game);\n        }\n\n        return {\n            capturedById: newStarPlayer._id,\n            capturedByAlias: newStarPlayer.alias!,\n            captureReward\n        };\n    }\n\n    resetIgnoreBulkUpgradeStatuses(star: Star) {\n        star.ignoreBulkUpgrade = {\n            economy: false,\n            industry: false,\n            science: false\n        }\n\n        return star.ignoreBulkUpgrade;\n    }\n\n    listHomeStars(game: Game) {\n        return game.galaxy.stars.filter(s => s.homeStar);\n    }\n\n    getKingOfTheHillStar(game: Game) {\n        const center = this.starDistanceService.getGalacticCenter();\n\n        return game.galaxy.stars.find(s => s.location.x === center.x && s.location.y === center.y)!;\n    }\n\n    isKingOfTheHillStar(star: Star) {\n        const center = this.starDistanceService.getGalacticCenter();\n\n        return star.location.x === center.x && star.location.y === center.y;\n    }\n\n    setupPlayerStarForGameStart(game: Game, star: Star, player: Player) {\n        if (player.homeStarId!.toString() === star._id.toString()) {\n            this.setupHomeStar(game, star, player, game.settings);\n        } else {\n            star.ownedByPlayerId = player._id;\n            star.shipsActual = game.settings.player.startingShips;\n            star.ships = star.shipsActual;\n            star.warpGate = false; // TODO: BUG - This resets warp gates generated by map terrain.\n            star.specialistId = null;\n\n            if (game.settings.player.developmentCost.economy !== 'none') {\n                star.infrastructure.economy = 0;\n            }\n\n            if (game.settings.player.developmentCost.industry !== 'none') {\n                star.infrastructure.industry = 0;\n            }\n\n            if (game.settings.player.developmentCost.science !== 'none') {\n                star.infrastructure.science = 0;\n            }\n\n            this.resetIgnoreBulkUpgradeStatuses(star);\n        }\n    }\n\n    setupStarsForGameStart(game: Game) {\n        // If any of the development costs are set to null then we need to randomly\n        // assign a portion of stars for each type to be seeded with the starting infrastructure.\n        // For example, if eco is disabled then each star in the galaxy will have a 1 in 3 chance of being seeded with eco.\n        // Note that we will not allow a mix of seeds, a star can only be seeded with one infrastructure type.\n        if (game.settings.player.developmentCost.economy !== 'none' &&\n            game.settings.player.developmentCost.industry !== 'none' &&\n            game.settings.player.developmentCost.science !== 'none') {\n                return\n            }\n        \n        // Note: Because each setting is independent, we only want to seed the\n        // ones where the development cost is set to none.\n        const types: (InfrastructureType | null)[] = [\n            game.settings.player.developmentCost.economy === 'none' ? 'economy' : null,\n            game.settings.player.developmentCost.industry === 'none' ? 'industry' : null,\n            game.settings.player.developmentCost.science === 'none' ? 'science' : null,\n        ]\n\n        const rng = RNG.create(game._id.toString());\n\n        for (let star of game.galaxy.stars) {\n            const i = rng(types.length);\n            const type = types[i];\n\n            if (type == null) {\n                continue;\n            }\n\n            star.infrastructure[type] = game.settings.player.startingInfrastructure[type];\n        }\n    }\n\n    pairWormHoleConstructors(game: Game) {\n        const constructors = game.galaxy.stars\n            .filter(s => s.specialistId && this.specialistService.getByIdStar(s.specialistId)?.modifiers.special?.wormHoleConstructor);\n\n        let pairs = Math.floor(constructors.length / 2);\n\n        if (pairs < 1) {\n            return;\n        }\n\n        while (pairs--) {\n            const starA = constructors[this.randomService.getRandomNumber(constructors.length)];\n            const starB = constructors[this.randomService.getRandomNumber(constructors.length)];\n\n            if (starA._id.toString() === starB._id.toString() || starA.wormHoleToStarId || starB.wormHoleToStarId) {\n                pairs++;\n                continue;\n            }\n\n            starA.wormHoleToStarId = starB._id;\n            starB.wormHoleToStarId = starA._id;\n\n            starA.specialistId = null;\n            starB.specialistId = null;\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["ValidationError"]
}
