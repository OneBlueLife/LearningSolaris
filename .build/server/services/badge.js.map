{
  "version": 3,
  "sources": ["../../../server/services/badge.ts"],
  "sourcesContent": ["import { DBObjectId } from './types/DBObjectId';\nimport ValidationError from '../errors/validation';\nimport Repository from './repository';\nimport { Badge, UserBadge } from './types/Badge';\nimport { Game } from './types/Game';\nimport { User } from './types/User';\nimport PlayerService from './player';\nimport UserService from './user';\nimport GamePlayerBadgePurchasedEvent from './types/events/GamePlayerBadgePurchased';\nconst EventEmitter = require('events');\n\nexport const BadgeServiceEvents = {\n    onGamePlayerBadgePurchased: 'onGamePlayerBadgePurchased'\n}\n\nexport default class BadgeService extends EventEmitter {\n    userRepo: Repository<User>;\n    userService: UserService;\n    playerService: PlayerService;\n\n    constructor(\n        userRepo: Repository<User>,\n        userService: UserService,\n        playerService: PlayerService\n    ) {\n        super();\n\n        this.userRepo = userRepo;\n        this.userService = userService;\n        this.playerService = playerService;\n    }\n\n    listBadges(): Badge[] {\n        return require('../config/game/badges').slice();\n    }\n\n    listPurchasableBadges(): Badge[] {\n        return this.listBadges().filter(b => b.price);\n    }\n\n    async listBadgesByUser(userId: DBObjectId): Promise<UserBadge[]> {\n        const badges = this.listBadges();\n\n        const user = await this.userService.getById(userId, {\n            'achievements.badges': 1\n        });\n\n        if (!user) {\n            return [];\n        }\n\n        const userBadges: UserBadge[] = [];\n\n        for (let badge of badges) {\n            userBadges.push({\n                ...badge,\n                awarded: user.achievements.badges[badge.key] || 0\n            });\n        }\n\n        return userBadges.filter(b => b.awarded);\n    }\n\n    async listBadgesByPlayer(game: Game, playerId: DBObjectId) {\n        let player = this.playerService.getById(game, playerId);\n\n        if (!player) {\n            throw new ValidationError(`Could not find the player in this game.`);\n        }\n\n        if (!player.userId) {\n            return null;\n        }\n\n        // Do not reveal badges for anon games.\n        if (game.settings.general.anonymity === 'extra') {\n            return []\n        }\n\n        return await this.listBadgesByUser(player.userId);\n    }\n\n    async purchaseBadgeForUser(purchasedByUserId: DBObjectId, purchasedForUserId: DBObjectId, badgeKey: string) {\n        if (purchasedByUserId.toString() === purchasedForUserId.toString()) {\n            throw new ValidationError(`Cannot purchased a badge for yourself.`);\n        }\n\n        const badge = this.listPurchasableBadges().find(b => b.key === badgeKey);\n\n        if (!badge) {\n            throw new ValidationError(`Badge ${badgeKey} does not exist.`);\n        }\n\n        const recipient = await this.userService.getById(purchasedForUserId, { _id: 1 });\n        \n        if (!recipient) {\n            throw new ValidationError(`Recipient user ${purchasedForUserId} does not exist.`);\n        }\n\n        // Check if the buyer can afford the badge.\n        const creditsOwned = await this.userService.getCredits(purchasedByUserId);\n\n        if (!creditsOwned || creditsOwned < badge.price) {\n            throw new ValidationError(`You cannot afford to purchase this badge.`);\n        }\n\n        // TODO: This would be better in a bulk update.\n        await this.userService.incrementCredits(purchasedByUserId, -1);\n\n        let updateQuery = {\n            $inc: {}\n        };\n\n        updateQuery.$inc['achievements.badges.' + badgeKey] = 1;\n\n        await this.userRepo.updateOne({\n            _id: purchasedForUserId\n        }, updateQuery);\n\n        return badge;\n    }\n\n    async purchaseBadgeForPlayer(game: Game, purchasedByUserId: DBObjectId, purchasedForPlayerId: DBObjectId, badgeKey: string) {\n        let buyer = this.playerService.getByUserId(game, purchasedByUserId)!;\n        let recipient = this.playerService.getById(game, purchasedForPlayerId);\n\n        if (!recipient) {\n            throw new ValidationError(`Could not find the player in this game.`);\n        }\n\n        if (!recipient.userId) {\n            throw new ValidationError(`The player slot has not been filled by a user.`);\n        }\n\n        const badge = await this.purchaseBadgeForUser(purchasedByUserId, recipient.userId, badgeKey);\n\n        let e: GamePlayerBadgePurchasedEvent = {\n            gameId: game._id,\n            gameTick: game.state.tick,\n            purchasedByPlayerId: buyer._id,\n            purchasedByPlayerAlias: buyer.alias,\n            purchasedForPlayerId: recipient._id,\n            purchasedForPlayerAlias: recipient.alias,\n            badgeKey,\n            badgeName: badge.name\n        };\n\n        this.emit(BadgeServiceEvents.onGamePlayerBadgePurchased, e);\n    }\n\n    awardBadgeForUser(user: User, badgeKey: string): void {\n        const badge = this.listBadges().find(b => b.key === badgeKey);\n\n        if (!badge) {\n            throw new ValidationError(`Badge ${badgeKey} does not exist.`);\n        }\n\n        user.achievements.badges[badgeKey]++;\n    }\n\n    awardBadgeForUserVictor32PlayerGame(user: User): void {\n        this.awardBadgeForUser(user, 'victor32');\n    }\n\n    awardBadgeForUserVictorySpecialGame(user: User, game: Game): void {\n        this.awardBadgeForUser(user, game.settings.general.type);\n    }\n};\n"],
  "mappings": "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",
  "names": ["ValidationError"]
}
