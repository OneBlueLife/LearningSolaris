{
  "version": 3,
  "sources": ["../../../server/services/carrier.ts"],
  "sourcesContent": ["const mongoose = require('mongoose');\nimport { DBObjectId } from './types/DBObjectId';\nimport ValidationError from '../errors/validation';\nimport Repository from './repository';\nimport { Carrier } from './types/Carrier';\nimport { CarrierWaypoint } from './types/CarrierWaypoint';\nimport { Game } from './types/Game';\nimport { MapObject } from './types/Map';\nimport { Player } from './types/Player';\nimport { Star } from './types/Star';\nimport DistanceService from './distance';\nimport SpecialistService from './specialist';\nimport StarService from './star';\nimport TechnologyService from './technology';\nconst EventEmitter = require('events');\n\nexport default class CarrierService extends EventEmitter {\n    gameRepo: Repository<Game>;\n    distanceService: DistanceService;\n    starService: StarService;\n    technologyService: TechnologyService;\n    specialistService: SpecialistService;\n\n    constructor(\n        gameRepo: Repository<Game>,\n        distanceService: DistanceService,\n        starService: StarService,\n        technologyService: TechnologyService,\n        specialistService: SpecialistService\n    ) {\n        super();\n\n        this.gameRepo = gameRepo;\n        this.distanceService = distanceService;\n        this.starService = starService;\n        this.technologyService = technologyService;\n        this.specialistService = specialistService;\n    }\n\n    getById(game: Game, id: DBObjectId) {\n        return this.getByIdBS(game, id); // Experimental\n    }\n\n    getByIdBS(game: Game, id: DBObjectId) {\n        let start = 0;\n        let end = game.galaxy.carriers.length - 1;\n    \n        while (start <= end) {\n            let middle = Math.floor((start + end) / 2);\n            let carrier = game.galaxy.carriers[middle];\n\n            if (carrier._id.toString() === id.toString()) {\n                // found the id\n                return carrier;\n            } else if (carrier._id.toString() < id.toString()) {\n                // continue searching to the right\n                start = middle + 1;\n            } else {\n                // search searching to the left\n                end = middle - 1;\n            }\n        }\n\n        // id wasn't found\n        // Return the old way\n        return game.galaxy.carriers.find(s => s._id.toString() === id.toString())!;\n    }\n\n    getCarriersAtStar(game: Game, starId: DBObjectId) {\n      return game.galaxy.carriers.filter(carrier => carrier.orbiting && carrier.orbiting.toString() === starId.toString())\n    }\n\n    createAtStar(star: Star, carriers: Carrier[], ships: number = 1): Carrier {\n        if (!Math.floor(star.shipsActual!)) {\n            throw new ValidationError('Star must have at least 1 ship to build a carrier.');\n        }\n\n        // Generate a name for the new carrier based on the star name but make sure\n        // this name isn't already taken by another carrier.\n        let name = this.generateCarrierName(star, carriers);\n\n        let carrier: Carrier = {\n            _id: mongoose.Types.ObjectId(),\n            ownedByPlayerId: star.ownedByPlayerId,\n            ships: ships,\n            orbiting: star._id,\n            location: star.location,\n            name,\n            waypoints: [],\n            waypointsLooped: false,\n            specialistId: null,\n            specialistExpireTick: null,\n            specialist: null,\n            isGift: false,\n            locationNext: null,\n            toObject(): Carrier {\n                return this\n            }\n        };\n\n        // Reduce the star ships by how many we have added to the carrier.\n        star.shipsActual! -= ships;\n        star.ships! -= ships;\n\n        // Check to see if the carrier should be auto-assigned a specialist.\n        if (star.specialistId) {\n            let starSpecialist = this.specialistService.getByIdStar(star.specialistId);\n    \n            if (starSpecialist?.modifiers.special?.autoCarrierSpecialistAssign) {\n                carrier.specialistId = starSpecialist.modifiers.special!.autoCarrierSpecialistAssign!;\n                carrier.specialist = this.specialistService.getByIdCarrier(carrier.specialistId)\n            }\n        }\n\n        return carrier;\n    }\n\n    listCarriersOwnedByPlayer(carriers: Carrier[], playerId: DBObjectId) {\n        return carriers.filter(s => s.ownedByPlayerId && s.ownedByPlayerId.toString() === playerId.toString());\n    }\n\n    listCarriersOwnedByPlayers(carriers: Carrier[], playerIds: DBObjectId[]) {\n        const ids = playerIds.map(p => p.toString());\n\n        return carriers.filter(s => s.ownedByPlayerId && ids.includes(s.ownedByPlayerId.toString()));\n    }\n\n    listCarriersOwnedByPlayerInOrbit(carriers: Carrier[], playerId: DBObjectId) {\n        return this.listCarriersOwnedByPlayer(carriers, playerId).filter(c => c.orbiting);\n    }\n\n    listCarriersOwnedByPlayersInOrbit(carriers: Carrier[], playerIds: DBObjectId[]) {\n        return this.listCarriersOwnedByPlayers(carriers, playerIds).filter(c => c.orbiting);\n    }\n\n    generateCarrierName(star: Star, carriers: Carrier[]) {\n        let i = 1;\n        let name = `${star.name} ${i++}`;\n        \n        while (carriers.find(c => c.name == name)) {\n            name = `${star.name} ${i++}`;\n        }\n\n        return name;\n    }\n\n    getCarriersWithinScanningRangeOfStarByCarrierIds(game: Game, star: Star, carriers: MapObject[]): MapObject[] {\n        // If the star isn't owned then it cannot have a scanning range\n        if (star.ownedByPlayerId == null) {\n            return [];\n        }\n\n        // Calculate the scanning distance of the given star.\n        let effectiveTechs = this.technologyService.getStarEffectiveTechnologyLevels(game, star);\n        let scanningRangeDistance = this.distanceService.getScanningDistance(game, effectiveTechs.scanning);\n\n        // Go through all carriers and the ones that are within the star's scanning range.\n        let carriersInRange = carriers.filter(c => {\n            return this.distanceService.getDistanceBetweenLocations(c.location, star.location) <= scanningRangeDistance;\n        });\n\n        return carriersInRange;\n    }\n\n    filterCarriersByScanningRange(game: Game, playerIds: DBObjectId[]) {\n        const ids = playerIds.map(p => p.toString());\n\n        // Stars may have different scanning ranges independently so we need to check\n        // each star to check what is within its scanning range.\n        let playerStars = this.starService.listStarsWithScanningRangeByPlayers(game, playerIds);\n\n        // Start with all of the carriers that the player owns as\n        // the player can always see those carriers.\n        let carriersInRange: DBObjectId[] = game.galaxy.carriers\n            .filter(c => ids.includes(c.ownedByPlayerId!.toString()))\n            .map(c => c._id);\n\n        // We need to check all carriers NOT owned by the player.\n        let carriersToCheck = game.galaxy.carriers\n            .filter(c => !ids.includes(c.ownedByPlayerId!.toString()))\n            .map(c => {\n                return {\n                    _id: c._id,\n                    ownedByPlayerId: c.ownedByPlayerId,\n                    location: c.location\n                };\n            });\n\n        for (let star of playerStars) {\n            let carrierIds = this.getCarriersWithinScanningRangeOfStarByCarrierIds(game, star, carriersToCheck);\n\n            for (let carrierId of carrierIds) {\n                if (carriersInRange.indexOf(carrierId._id) === -1) {\n                    carriersInRange.push(carrierId._id);\n                    carriersToCheck.splice(carriersToCheck.indexOf(carrierId), 1);\n                }\n            }\n\n            // If we've checked all carriers then no need to continue.\n            if (!carriersToCheck.length) {\n                break;\n            }\n        }\n\n        return carriersInRange.map(c => this.getById(game, c));\n    }\n\n    sanitizeCarriersByPlayers(game: Game, playerIds: DBObjectId[]) {\n        const ids = playerIds.map(p => p.toString());\n\n        // Filter all waypoints (except those in transit) for all carriers that do not belong\n        // to the player.\n        return game.galaxy.carriers\n        .map(c => {\n            if (ids.includes(c.ownedByPlayerId!.toString())) {\n                return c;\n            }\n\n            // Return only key data about the carrier and the waypoints\n            // if the carrier does not belong to the given player.\n            let carrierData = {\n                _id: c._id,\n                ownedByPlayerId: c.ownedByPlayerId,\n                orbiting: c.orbiting,\n                name: c.name,\n                ships: c.ships,\n                location: c.location,\n                waypoints: c.waypoints,\n                isGift: c.isGift,\n                specialistId: c.specialistId,\n                specialistExpireTick: c.specialistExpireTick,\n                specialist: null\n            };\n\n            carrierData.waypoints = this.clearCarrierWaypointsNonTransit(c, true);\n\n            return carrierData;\n        });\n    }\n\n    clearCarrierWaypointsNonTransit(carrier: Carrier, obfuscateFirstWaypoint: boolean = false) {\n        let waypoints: CarrierWaypoint[] = [];\n\n        if (!carrier.orbiting) {\n            waypoints = carrier.waypoints.slice(0, 1);\n\n            if (obfuscateFirstWaypoint) {\n                // Hide any sensitive info about the waypoint.\n                let wp = waypoints[0];\n\n                if (wp) {\n                    wp.action = 'nothing';\n                    wp.actionShips = 0;\n                    wp.delayTicks = 0;\n                }\n\n                carrier.waypointsLooped = false;\n            }\n        }\n\n        return waypoints;\n    }\n    \n    clearPlayerCarrierWaypointsNonTransit(game: Game, player: Player) {\n        let carriers = this.listCarriersOwnedByPlayer(game.galaxy.carriers, player._id);\n\n        for (let carrier of carriers) {\n            carrier.waypoints = this.clearCarrierWaypointsNonTransit(carrier);\n        }\n    }\n    \n    clearPlayerCarrierWaypointsLooped(game: Game, player: Player) {\n        let carriers = this.listCarriersOwnedByPlayer(game.galaxy.carriers, player._id);\n\n        for (let carrier of carriers) {\n            carrier.waypointsLooped = false;\n        }\n    }\n\n    clearPlayerCarriers(game: Game, player: Player) {\n        game.galaxy.carriers = game.galaxy.carriers.filter(c => !c.ownedByPlayerId\n            || c.ownedByPlayerId.toString() !== player._id.toString());\n    }\n\n    async rename(game: Game, player: Player, carrierId: DBObjectId, name: string) {\n        let carrier = this.getById(game, carrierId);\n\n        if (!carrier) {\n            throw new ValidationError('Carrier does not exist');\n        }\n\n        if (!name) {\n            throw new ValidationError('Name is required.');\n        }\n\n        if (name.length < 4 || name.length > 30) {\n            throw new ValidationError('Name must be between greater than 3 and less than or equal to 30 characters long.');\n        }\n\n        if (carrier.ownedByPlayerId!.toString() !== player._id.toString()) {\n            throw new ValidationError(`Cannot rename carrier, you are not its owner.`);\n        }\n\n        let carrierName = name.trim().replace(/\\w\\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});\n        \n        await this.gameRepo.updateOne({\n            _id: game._id,\n            'galaxy.carriers._id': carrierId\n        }, {\n            $set: {\n                'galaxy.carriers.$.name': carrierName\n            }\n        });\n    }\n\n    async scuttle(game: Game, player: Player, carrierId: DBObjectId) {\n        let carrier = this.getById(game, carrierId);\n\n        if (!carrier) {\n            throw new ValidationError('Carrier does not exist');\n        }\n\n        if (carrier.ownedByPlayerId!.toString() !== player._id.toString()) {\n            throw new ValidationError(`Cannot scuttle carrier, you are not its owner.`);\n        }\n\n        if (carrier.isGift) {\n            throw new ValidationError(`Cannot scuttle a gift.`);\n        }\n\n        await this.gameRepo.updateOne({\n            _id: game._id\n        }, {\n            $pull: {\n                'galaxy.carriers': {\n                    _id: carrierId\n                }\n            }\n        });\n\n        // TODO: Event?\n    }\n\n    canPlayersSeeCarrierShips(game: Game, playerIds: DBObjectId[], carrier: Carrier) {\n        const ids = playerIds.map(p => p.toString());\n        const isOwnedByPlayer = ids.includes(carrier.ownedByPlayerId!.toString());\n\n        if (isOwnedByPlayer) {\n            return true;\n        }\n\n        // Check if the carrier is in orbit of a nebula as nebula always hides ships for other players.\n        if (this.isInOrbitOfNebula(game, carrier)) {\n            return false;\n        }\n\n        if (carrier.specialistId) {\n            let specialist = this.specialistService.getByIdCarrier(carrier.specialistId);\n\n            // If the carrier has a hideShips spec and is not owned by the given player\n            // then that player cannot see the carrier's ships.\n            if (specialist && specialist.modifiers.special && specialist.modifiers.special.hideShips) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    isInOrbitOfNebula(game: Game, carrier: Carrier) {\n        if (carrier.orbiting) {\n            const orbitStar = this.starService.getById(game, carrier.orbiting);\n\n            return orbitStar.isNebula;\n        }\n\n        return false;\n    }\n\n    destroyCarrier(game: Game, carrier: Carrier) {\n        game.galaxy.carriers.splice(game.galaxy.carriers.indexOf(carrier), 1);\n    }\n    \n    listGiftCarriersInOrbit(game: Game) {\n        return game.galaxy.carriers.filter(c => c.isGift && c.orbiting);\n    }\n\n};\n"],
  "mappings": "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",
  "names": ["ValidationError"]
}
