{
  "version": 3,
  "sources": ["../../../server/services/ai.ts"],
  "sourcesContent": ["import {Game} from \"./types/Game\";\nimport {Player} from \"./types/Player\";\nimport {KnownAttack} from \"./types/Ai\";\nimport CarrierService from \"./carrier\";\nimport CombatService from \"./combat\";\nimport DistanceService from \"./distance\";\nimport PlayerService from \"./player\";\nimport ShipTransferService from \"./shipTransfer\";\nimport StarService from \"./star\";\nimport StarUpgradeService from \"./starUpgrade\";\nimport TechnologyService from \"./technology\";\nimport WaypointService from \"./waypoint\";\nimport {Star} from \"./types/Star\";\nimport {Carrier} from \"./types/Carrier\";\nimport {getOrInsert, maxBy, minBy, notNull, reverseSort} from \"./utils\";\nimport {CarrierWaypoint, CarrierWaypointActionType} from \"./types/CarrierWaypoint\";\nimport ReputationService from \"./reputation\";\nimport DiplomacyService from \"./diplomacy\";\nimport PlayerStatisticsService from \"./playerStatistics\";\nimport {DBObjectId} from \"./types/DBObjectId\";\nimport PlayerAfkService from \"./playerAfk\";\nimport ShipService from \"./ship\";\n\nconst Heap = require('qheap');\nconst mongoose = require(\"mongoose\");\n\nconst FIRST_TICK_BULK_UPGRADE_SCI_PERCENTAGE = 20;\nconst FIRST_TICK_BULK_UPGRADE_IND_PERCENTAGE = 30;\nconst LAST_TICK_BULK_UPGRADE_ECO_PERCENTAGE = 100;\n\nconst EMPTY_STAR_SCORE_MULTIPLIER = 1;\nconst ENEMY_STAR_SCORE_MULTIPLIER = 5;\n\nconst REINFORCEMENT_MIN_CYCLES = 1.5;\nconst REINFORCEMENT_MIN_FACTOR = 1.4;\n\nconst INVASION_ATTACK_FACTOR = 1.5;\n\nenum AiAction {\n    DefendStar,\n    ClaimStar,\n    ReinforceStar,\n    InvadeStar\n};\n\ninterface DefendStarOrder {\n    type: AiAction.DefendStar;\n    score: number;\n    star: string;\n    ticksUntil: number;\n    incomingCarriers: Carrier[];\n};\n\ninterface ClaimStarOrder {\n    type: AiAction.ClaimStar;\n    star: string;\n    score: number;\n};\n\ninterface ReinforceStarOrder {\n    type: AiAction.ReinforceStar;\n    score: number;\n    star: string;\n    source: string;\n};\n\ninterface InvadeStarOrder {\n    type: AiAction.InvadeStar;\n    star: string;\n    score: number;\n};\n\ninterface TracePoint {\n    starId: string;\n    action?: CarrierWaypointActionType;\n};\n\ntype Order = DefendStarOrder | ClaimStarOrder | ReinforceStarOrder | InvadeStarOrder;\n\ntype StarGraph = Map<string, Set<string>>;\n\ninterface Context {\n    playerStars: Star[];\n    playerCarriers: Carrier[];\n    starsById: Map<string, Star>;\n    allReachableFromPlayerStars: StarGraph;\n    freelyReachableFromPlayerStars: StarGraph;\n    reachablePlayerStars: StarGraph;\n    freelyReachableStars: StarGraph;\n    allCanReachPlayerStars: StarGraph;\n    starsInGlobalRange: StarGraph;\n    borderStars: Set<string>;\n    carriersOrbiting: Map<string, Carrier[]>;\n    carriersById: Map<string, Carrier>;\n    attacksByStarId: Map<string, Map<number, Carrier[]>>;\n    attackedStarIds: Set<string>;\n    playerEconomy: number;\n    playerIndustry: number;\n    playerScience: number;\n    transitFromCarriers: Map<string, Carrier[]>,\n    arrivingAtCarriers: Map<string, Carrier[]>\n}\n\ninterface Assignment {\n    carriers: Carrier[];\n    star: Star;\n    totalShips: number;\n};\n\ninterface FoundAssignment {\n    assignment: Assignment;\n    trace: TracePoint[];\n};\n\n// IMPORTANT IMPLEMENTATION NOTES\n// During AI tick, care must be taken to NEVER write any changes to the database.\n// This is performed automatically by mongoose (when calling game.save()).\n// Use the writeToDB parameters to skip (or introduce them where needed).\n// Otherwise, changes will get duplicated.\nexport default class AIService {\n    starUpgradeService: StarUpgradeService;\n    carrierService: CarrierService;\n    starService: StarService;\n    distanceService: DistanceService;\n    waypointService: WaypointService;\n    combatService: CombatService;\n    shipTransferService: ShipTransferService;\n    technologyService: TechnologyService;\n    playerService: PlayerService;\n    playerAfkService: PlayerAfkService;\n    reputationService: ReputationService;\n    diplomacyService: DiplomacyService;\n    playerStatisticsService: PlayerStatisticsService;\n    shipService: ShipService;\n\n    constructor(\n        starUpgradeService: StarUpgradeService,\n        carrierService: CarrierService,\n        starService: StarService,\n        distanceService: DistanceService,\n        waypointService: WaypointService,\n        combatService: CombatService,\n        shipTransferService: ShipTransferService,\n        technologyService: TechnologyService,\n        playerService: PlayerService,\n        playerAfkService: PlayerAfkService,\n        reputationService: ReputationService,\n        diplomacyService: DiplomacyService,\n        playerStatisticsService: PlayerStatisticsService,\n        shipService: ShipService\n    ) {\n        this.starUpgradeService = starUpgradeService;\n        this.carrierService = carrierService;\n        this.starService = starService;\n        this.distanceService = distanceService;\n        this.waypointService = waypointService;\n        this.combatService = combatService;\n        this.shipTransferService = shipTransferService;\n        this.technologyService = technologyService;\n        this.playerService = playerService;\n        this.playerAfkService = playerAfkService;\n        this.reputationService = reputationService;\n        this.diplomacyService = diplomacyService;\n        this.playerStatisticsService = playerStatisticsService;\n        this.shipService = shipService;\n    }\n\n    async play(game: Game, player: Player) {\n        if (!this.playerAfkService.isAIControlled(game, player, true)) {\n            throw new Error('The player is not under AI control.');\n        }\n\n        const isFirstTickOfCycle = game.state.tick % game.settings.galaxy.productionTicks === 1;\n        const isLastTickOfCycle = game.state.tick % game.settings.galaxy.productionTicks === game.settings.galaxy.productionTicks - 1;\n\n        // Considering the growing complexity of AI logic,\n        // it's better to catch any possible errors and have the game continue with disfunctional AI than to break the game tick logic.\n        try {\n            if (game.settings.general.advancedAI === 'enabled') {\n                await this._doAdvancedLogic(game, player, isFirstTickOfCycle, isLastTickOfCycle);\n            }\n\n            await this._doBasicLogic(game, player, isFirstTickOfCycle, isLastTickOfCycle);\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    async _doBasicLogic(game: Game, player: Player, isFirstTickOfCycle: boolean, isLastTickOfCycle: boolean) {\n        if (isFirstTickOfCycle) {\n            await this._playFirstTick(game, player);\n        } else if (isLastTickOfCycle) {\n            await this._playLastTick(game, player);\n        }\n\n        // TODO: Not sure if this is an issue but there was an occassion during debugging\n        // where the player credits amount was less than 0, I assume its the AI spending too much somehow\n        // so adding this here just in case but need to investigate.\n        player.credits = Math.max(0, player.credits);\n    }\n\n    async _doAdvancedLogic(game: Game, player: Player, isFirstTickOfCycle: boolean, isLastTickOfCycle: boolean) {\n        const context = this._createContext(game, player);\n\n        if (context == null) {\n            this._clearState(player);\n            return;\n        }\n\n        if (!player.aiState) {\n            this._setInitialState(game, player);\n        }\n\n        this._sanitizeState(game, player, context);\n\n        const orders = this._gatherOrders(game, player, context);\n        const assignments = await this._gatherAssignments(game, player, context);\n\n        await this._evaluateOrders(game, player, context, orders, assignments);\n\n        // Mongoose method that cannot be typechecked\n        // @ts-ignore\n        player.markModified('aiState');\n    }\n\n    _setInitialState(game: Game, player: Player): void {\n        player.aiState = {\n            knownAttacks: [],\n            startedClaims: [],\n            invasionsInProgress: []\n        };\n    }\n\n    _sanitizeState(game: Game, player: Player, context: Context) {\n        if (!player.aiState) {\n            return;\n        }\n\n        if (player.aiState.knownAttacks) {\n            player.aiState.knownAttacks = player.aiState.knownAttacks.filter(attack => attack.arrivalTick > game.state.tick);\n        }\n\n        if (player.aiState.invasionsInProgress) {\n            player.aiState.invasionsInProgress = player.aiState.invasionsInProgress.filter(invasion => invasion.arrivalTick > game.state.tick);\n        }\n    }\n\n    _clearState(player: Player) {\n        if (player.aiState) {\n            player.aiState = null;\n            // @ts-ignore\n            player.markModified('aiState');\n        }\n    }\n\n    _createContext(game: Game, player: Player): Context | null {\n        const playerStars = this.starService.listStarsOwnedByPlayer(game.galaxy.stars, player._id);\n\n        // The AI can't do shit if they don't have any stars.\n        if (!playerStars.length) {\n            return null;\n        }\n\n        const playerId = player._id.toString();\n\n        const starsById = new Map<string, Star>()\n\n        for (const star of game.galaxy.stars) {\n            starsById.set(star._id.toString(), star);\n        }\n\n        const traversableStars = game.galaxy.stars.filter(star => !star.ownedByPlayerId || star.ownedByPlayerId.toString() === playerId);\n        // All stars (belonging to anyone) that can be reached directly from a player star\n        const allReachableFromPlayerStars = this._computeStarGraph(starsById, game, player, playerStars, game.galaxy.stars, this._getHyperspaceRangeExternal(game, player));\n        // All stars (belonging to anyone) that can reach a player star (with our players range)\n        const allCanReachPlayerStars = this._computeStarGraph(starsById, game, player, game.galaxy.stars, playerStars, this._getHyperspaceRangeExternal(game, player));\n        // All stars (unowned or owned by this player) that can be reached from player stars\n        const freelyReachableFromPlayerStars = this._computeStarGraph(starsById, game, player, playerStars, traversableStars, this._getHyperspaceRangeExternal(game, player));\n        // Player stars reachable from player stars\n        const reachablePlayerStars = this._computeStarGraph(starsById, game, player, playerStars, playerStars, this._getHyperspaceRangeInternal(game, player));\n        // All free stars that can be reached from other free stars\n        const freelyReachableStars = this._computeStarGraph(starsById, game, player, traversableStars, traversableStars, this._getHyperspaceRangeExternal(game, player));\n        // All stars that can be reached from player stars with globally highest range tech\n        const starsInGlobalRange = this._computeStarGraph(starsById, game, player, playerStars, game.galaxy.stars, this._getGlobalHighestHyperspaceRange(game));\n\n        const borderStars = new Set<string>();\n\n        for (const [from, reachables] of starsInGlobalRange) {\n            for (const reachableId of reachables) {\n                const reachable = starsById.get(reachableId)!;\n\n                if (!reachable.ownedByPlayerId || reachable.ownedByPlayerId.toString() !== playerId) {\n                    borderStars.add(from);\n                }\n            }\n        }\n\n        const playerCarriers = this.carrierService.listCarriersOwnedByPlayer(game.galaxy.carriers, player._id);\n\n        const carriersOrbiting = new Map<string, Carrier[]>();\n\n        for (const carrier of game.galaxy.carriers) {\n            if ((!carrier.waypoints || carrier.waypoints.length === 0) && carrier.orbiting) {\n                const carriersInOrbit = getOrInsert(carriersOrbiting, carrier.orbiting.toString(), () => []);\n                carriersInOrbit.push(carrier);\n            }\n        }\n\n        const carriersById = new Map<string, Carrier>();\n\n        for (const carrier of game.galaxy.carriers) {\n            carriersById.set(carrier._id.toString(), carrier);\n        }\n\n        // Enemy carriers that are in transition to one of our stars\n        const incomingCarriers = game.galaxy.carriers\n            .filter(carrier => this._isEnemyPlayer(game, player, carrier.ownedByPlayerId!) && carrier.orbiting == null)\n            .map(carrier => {\n                const waypoint = carrier.waypoints[0];\n                const destinationId = waypoint.destination;\n                const destinationStar = starsById.get(destinationId.toString())!;\n\n                if (destinationStar.ownedByPlayerId && destinationStar.ownedByPlayerId.toString() === playerId) {\n                    return {\n                        carrier,\n                        waypoint\n                    };\n                }\n\n                return null;\n            })\n            .filter(notNull);\n\n        const attacksByStarId = new Map<string, Map<number, Carrier[]>>();\n        const attackedStarIds = new Set<string>();\n\n        for (const { carrier: incomingCarrier, waypoint: incomingWaypoint } of incomingCarriers) {\n            const targetStar = incomingWaypoint.destination.toString();\n            const attacks = getOrInsert(attacksByStarId, targetStar, () => new Map<number, Carrier[]>());\n\n            attackedStarIds.add(targetStar);\n\n            const attackInTicks = this.waypointService.calculateWaypointTicksEta(game, incomingCarrier, incomingWaypoint);\n            const simultaneousAttacks = getOrInsert(attacks, attackInTicks, () => []);\n\n            simultaneousAttacks.push(incomingCarrier);\n        }\n\n        const transitFromCarriers = new Map<string, Carrier[]>();\n        const arrivingAtCarriers = new Map<string, Carrier[]>();\n\n        for (const carrier of playerCarriers) {\n            if (carrier.waypoints.length !== 0) {\n                const fromId = carrier.waypoints[0].source.toString();\n\n                const fromCarriers = getOrInsert(transitFromCarriers, fromId, () => []);\n                fromCarriers.push(carrier);\n\n                if (carrier.waypoints.length === 1) {\n                    const toId = carrier.waypoints[0].destination.toString();\n                    const toCarriers = getOrInsert(arrivingAtCarriers, toId, () => []);\n                    toCarriers.push(carrier);\n                }\n            }\n        }\n\n        return {\n            playerStars,\n            playerCarriers,\n            starsById,\n            allReachableFromPlayerStars,\n            freelyReachableFromPlayerStars,\n            allCanReachPlayerStars,\n            freelyReachableStars,\n            reachablePlayerStars,\n            starsInGlobalRange,\n            borderStars,\n            carriersOrbiting,\n            carriersById,\n            attacksByStarId,\n            attackedStarIds,\n            playerEconomy: this.playerStatisticsService.calculateTotalEconomy(playerStars),\n            playerIndustry: this.playerStatisticsService.calculateTotalIndustry(playerStars),\n            playerScience: this.playerStatisticsService.calculateTotalScience(playerStars),\n            transitFromCarriers,\n            arrivingAtCarriers\n        };\n    }\n\n    async _evaluateOrders(game: Game, player: Player, context: Context, orders: Order[], assignments: Map<string, Assignment>) {\n        const sorter = (o1, o2) => {\n            const categoryPriority = this.priorityFromOrderCategory(o1.type) - this.priorityFromOrderCategory(o2.type);\n            if (categoryPriority !== 0) {\n                return categoryPriority;\n            } else {\n                return o1.score - o2.score;\n            }\n        };\n\n        orders.sort(reverseSort(sorter));\n\n        // This is a hack to ensure that ships are never assigned from a star where they are needed for defense.\n        // Later, with an improved scoring system, this should not be necessary\n        for (const order of orders) {\n            if (order.type === AiAction.DefendStar) {\n                assignments.delete(order.star);\n            }\n        }\n\n        const newKnownAttacks: KnownAttack[] = [];\n        const newClaimedStars = new Set(player.aiState!.startedClaims);\n\n        // For now, process orders in order of importance and try to find the best assignment possible for each order.\n        // Later, a different scoring process could be used to maximize overall scores.\n\n        for (const order of orders) {\n            if (order.type === AiAction.DefendStar) {\n                // Later, take weapons level and specialists into account\n                const attackData = this._getAttackData(game, player, order.star, order.ticksUntil) || this._createDefaultAttackData(game, order.star, order.ticksUntil);\n                const defendingStar = context.starsById.get(order.star)!;\n                const requiredAdditionallyForDefense = this._calculateRequiredShipsForDefense(game, player, context, attackData, order.incomingCarriers, defendingStar);\n\n                newKnownAttacks.push(attackData);\n\n                const allPossibleAssignments: FoundAssignment[] = this._findAssignmentsWithTickLimit(game, player, context, context.reachablePlayerStars, assignments, order.star, order.ticksUntil, this._canAffordCarrier(context, game, player, true));\n\n                let shipsNeeded = requiredAdditionallyForDefense;\n\n                for (const {assignment, trace} of allPossibleAssignments) {\n                    if (shipsNeeded <= 0 || assignment.totalShips === 1) {\n                        break;\n                    }\n\n                    // Skip assignments that we cannot afford to fulfill\n                    if ((!assignment.carriers || assignment.carriers.length === 0) && !this._canAffordCarrier(context, game, player, true)) {\n                        continue;\n                    }\n\n                    let shipsUsed;\n\n                    if (shipsNeeded <= assignment.totalShips) {\n                        shipsUsed = shipsNeeded;\n                        shipsNeeded = 0;\n                    } else {\n                        shipsUsed = assignment.totalShips;\n                        shipsNeeded -= assignment.totalShips;\n                    }\n\n                    // We'll wait until the last possible moment to launch the defense to avoid wasting carriers\n                    const timeLeftUntilSchedule =  order.ticksUntil - this._calculateTraceDuration(context, game, trace);\n                    if (timeLeftUntilSchedule > 0) {\n                        assignments.delete(assignment.star._id.toString());\n                    } else {\n                        await this._useAssignment(context, game, player, assignments, assignment, this._createWaypointsDropAndReturn(trace), shipsUsed, (carrier) => attackData.carriersOnTheWay.push(carrier._id.toString()));\n                    }\n                }\n            } else if (order.type === AiAction.InvadeStar) {\n                if (player.aiState && player.aiState.invasionsInProgress && player.aiState.invasionsInProgress.find(iv => order.star === iv.star)) {\n                    continue;\n                }\n\n                const starToInvade = context.starsById.get(order.star)!;\n                const ticksLimit = game.settings.galaxy.productionTicks * 2;\n                const fittingAssignments = this._findAssignmentsWithTickLimit(game, player, context, context.allCanReachPlayerStars, assignments, order.star, ticksLimit,  this._canAffordCarrier(context, game, player, false), false);\n\n                if (!fittingAssignments || !fittingAssignments.length) {\n                    continue;\n                }\n\n                for (const {assignment, trace} of fittingAssignments) {\n                    const ticksUntilArrival = this._calculateTraceDuration(context, game, trace);\n                    const requiredShips = Math.floor(this._calculateRequiredShipsForAttack(game, player, context, starToInvade, ticksUntilArrival) * INVASION_ATTACK_FACTOR);\n\n                    if (assignment.totalShips >= requiredShips) {\n                        const carrierResult = await this._useAssignment(context, game, player, assignments, assignment, this._createWaypointsFromTrace(trace), requiredShips);\n\n                        player.aiState!.invasionsInProgress.push({\n                            star: order.star,\n                            arrivalTick: game.state.tick + carrierResult.ticksEtaTotal!\n                        });\n\n                        break;\n                    }\n                }\n            } else if (order.type === AiAction.ClaimStar) {\n                // Skip double claiming stars that might have been claimed by an earlier action\n                if (newClaimedStars.has(order.star)) {\n                    continue;\n                }\n\n                const ticksLimit = game.settings.galaxy.productionTicks * 2; // If star is not reachable in that time, try again next cycle\n                const fittingAssignments = this._findAssignmentsWithTickLimit(game, player, context, context.freelyReachableStars, assignments, order.star, ticksLimit, this._canAffordCarrier(context, game, player, false), true)\n                const found: FoundAssignment = fittingAssignments && fittingAssignments[0];\n\n                if (!found) {\n                    continue;\n                }\n\n                const waypoints = this._createWaypointsFromTrace(found.trace);\n\n                await this._useAssignment(context, game, player, assignments, found.assignment, waypoints, found.assignment.totalShips);\n\n                for (const visitedStar of found.trace) {\n                    newClaimedStars.add(visitedStar.starId);\n                }\n            } else if (order.type === AiAction.ReinforceStar) {\n                const assignment = assignments.get(order.source);\n\n                if (!assignment || assignment.totalShips <= 1) {\n                    continue;\n                }\n\n                const hasIdleCarrier = assignment.carriers && assignment.carriers.length > 0;\n\n                const reinforce = async () => {\n                    const waypoints: CarrierWaypoint[] = [\n                        {\n                            _id: new mongoose.Types.ObjectId(),\n                            source: new mongoose.Types.ObjectId(order.source),\n                            destination: new mongoose.Types.ObjectId(order.star),\n                            action: 'dropAll',\n                            actionShips: 0,\n                            delayTicks: 0\n                        },\n                        {\n                            _id: new mongoose.Types.ObjectId(),\n                            source: new mongoose.Types.ObjectId(order.star),\n                            destination: new mongoose.Types.ObjectId(order.source),\n                            action: 'nothing',\n                            actionShips: 0,\n                            delayTicks: 0\n                        }\n                    ];\n\n                    await this._useAssignment(context, game, player, assignments, assignment, waypoints, assignment.totalShips);\n                }\n\n                if (hasIdleCarrier) {\n                    // Since a carrier is standing around, we might as well use it\n                    await reinforce();\n                } else if (this._canAffordCarrier(context, game, player, false)) {\n                    const routeCarrier = this._logisticRouteExists(context, order.source, order.star);\n\n                    // Only allow one carrier per route\n                    if (!routeCarrier) {\n                        const nextReturning = this._nextArrivingCarrierIn(context, game, order.source);\n                        if (!nextReturning)  {\n                            await reinforce();\n                        }\n                    }\n                }\n            }\n        }\n\n        player.aiState!.knownAttacks = newKnownAttacks;\n\n        const claimsInProgress: string[] = [];\n\n        for (const claim of newClaimedStars) {\n            const star = context.starsById.get(claim)!;\n\n            if (!star.ownedByPlayerId) {\n                claimsInProgress.push(claim);\n            }\n        }\n\n        player.aiState!.startedClaims = claimsInProgress;\n    }\n\n    _nextArrivingCarrierIn(context: Context, game: Game, starId: string): number | undefined {\n        const carriers = context.arrivingAtCarriers.get(starId);\n        return carriers && minBy(c => this.waypointService.calculateWaypointTicks(game, c, c.waypoints[0]), carriers)\n    }\n\n    async _useAssignment(context: Context, game: Game, player: Player, assignments: Map<string, Assignment>, assignment: Assignment, waypoints: CarrierWaypoint[], ships: number, onCarrierUsed: ((Carrier) => void) | null = null) {\n        let shipsToTransfer = ships;\n        const starId = assignment.star._id;\n        let carrier: Carrier = assignment.carriers && assignment.carriers[0];\n\n        if (carrier) {\n            assignment.carriers.shift();\n        } else {\n            const buildResult = await this.starUpgradeService.buildCarrier(game, player, starId, 1, false);\n            carrier = this.carrierService.getById(game, buildResult.carrier._id);\n            shipsToTransfer -= 1;\n            assignment.totalShips -= 1;\n        }\n\n        if (shipsToTransfer > 0) {\n            const remaining = Math.max(assignment.star.ships! - shipsToTransfer, 0);\n            await this.shipTransferService.transfer(game, player, carrier._id, shipsToTransfer + 1, starId, remaining, false);\n            assignment.totalShips = assignment.star.ships!;\n        }\n\n        const carrierResult = await this.waypointService.saveWaypointsForCarrier(game, player, carrier, waypoints, false, false);\n        const carrierRemaining = assignment.carriers && assignment.carriers.length > 0;\n\n        if (!carrierRemaining && assignment.totalShips === 0) {\n            assignments.delete(starId.toString());\n        }\n\n        if (onCarrierUsed) {\n            onCarrierUsed(carrier);\n        }\n\n        return carrierResult;\n    }\n\n    _createWaypointsDropAndReturn(trace: TracePoint[]): CarrierWaypoint[] {\n        const newTrace: TracePoint[] = trace.slice(0, trace.length - 1);\n\n        newTrace.push({\n            starId: trace[trace.length - 1].starId,\n            action: \"dropAll\"\n        });\n\n        const backTrace = (trace.slice(0, trace.length - 1).reverse());\n\n        return this._createWaypointsFromTrace(newTrace.concat(backTrace));\n    }\n\n    _createWaypointsFromTrace(trace: TracePoint[]): CarrierWaypoint[] {\n        const waypoints: CarrierWaypoint[] = [];\n        let last = trace[0].starId;\n\n        for (let i = 1; i < trace.length; i++) {\n            const id = trace[i].starId;\n\n            waypoints.push({\n                _id: new mongoose.Types.ObjectId(),\n                source: new mongoose.Types.ObjectId(last),\n                destination: new mongoose.Types.ObjectId(id),\n                action: trace[i].action || 'nothing',\n                actionShips: 0,\n                delayTicks: 0\n            });\n\n            last = id;\n        }\n\n        return waypoints;\n    }\n\n    _logisticRouteExists(context: Context, fromStarId: string, toStarId: string): Carrier | undefined {\n        const movingFrom = context.transitFromCarriers.get(fromStarId) ?? [];\n        const hasCarrierOutbound = movingFrom.find((c) => c.waypoints[0].destination.toString() === toStarId);\n        if (hasCarrierOutbound) {\n            return hasCarrierOutbound;\n        }\n\n        const movingTo = context.arrivingAtCarriers.get(fromStarId) ?? [];\n        return movingTo.find((c) => c.waypoints[0].source.toString() === toStarId);\n    }\n\n    _canAffordCarrier(context: Context, game: Game, player: Player, highPriority: boolean): boolean {\n        // Keep 50% of budget for upgrades\n        const leaveOver = highPriority ? 0 : context.playerEconomy * 5;\n        const availableFunds = player.credits - leaveOver;\n        const carrierExpenseConfig = game.constants.star.infrastructureExpenseMultipliers[game.settings.specialGalaxy.carrierCost];\n\n        return availableFunds >= this.starUpgradeService.calculateCarrierCost(game, carrierExpenseConfig);\n    }\n\n    _searchAssignments(context: Context, starGraph: StarGraph, assignments: Map<string, Assignment>, nextFilter: (trace: TracePoint[], nextStarId: string) => boolean, onAssignment: (assignment: Assignment, trace: TracePoint[]) => boolean, startStarId: string) {\n        const queue = new Heap({\n            comparBefore: (b1, b2) => b1.totalDistance > b2.totalDistance,\n            compar: (b1, b2) => b2.totalDistance - b1.totalDistance\n        });\n\n        const init = {\n            trace: [{starId: startStarId}],\n            starId: startStarId,\n            totalDistance: 0\n        };\n\n        queue.push(init);\n\n        const visited = new Set();\n\n        while (queue.length > 0) {\n            const {starId, trace, totalDistance} = queue.shift();\n\n            visited.add(starId);\n\n            const currentStarAssignment = assignments.get(starId);\n\n            if (currentStarAssignment) {\n                if (!onAssignment(currentStarAssignment, trace)) {\n                    return;\n                }\n            }\n\n            const nextCandidates = starGraph.get(starId);\n\n            if (nextCandidates) {\n                const star = context.starsById.get(starId)!;\n                const fittingCandidates = Array.from(nextCandidates).filter(candidate => nextFilter(trace, candidate));\n\n                for (const fittingCandidate of fittingCandidates) {\n                    if (!visited.has(fittingCandidate)) {\n                        visited.add(fittingCandidate);\n\n                        const distToNext = this._calculateTravelDistance(star, context.starsById.get(fittingCandidate)!)\n                        const newTotalDist = totalDistance + distToNext;\n\n                        queue.push({\n                            starId: fittingCandidate,\n                            trace: [{starId: fittingCandidate}].concat(trace),\n                            totalDistance: newTotalDist\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    _filterAssignmentByCarrierPurchase(assignment: Assignment, allowCarrierPurchase: boolean) {\n        const hasCarriers = assignment.carriers && assignment.carriers.length > 0;\n\n        return allowCarrierPurchase || hasCarriers;\n    }\n\n    _calculateTravelDistance(star1: Star, star2: Star): number {\n        if (this.starService.isStarPairWormHole(star1, star2)) {\n            return 0;\n        } else {\n            return this.distanceService.getDistanceBetweenLocations(star1.location, star2.location);\n        }\n    }\n\n    _calculateTraceDistance(context: Context, game: Game, trace: TracePoint[]): number {\n        if (trace.length < 2) {\n            return 0;\n        }\n\n        let last = trace[0];\n        let distance = 0;\n\n        for (let i = 1; i < trace.length; i++) {\n            const lastStar = context.starsById.get(last.starId)!;\n            const thisStar = context.starsById.get(trace[i].starId)!;\n\n            distance += this._calculateTravelDistance(lastStar, thisStar);\n\n            last = trace[i];\n        }\n\n        return distance;\n    }\n\n    _calculateTraceDuration(context: Context, game: Game, trace: TracePoint[]): number {\n        const distancePerTick = game.settings.specialGalaxy.carrierSpeed;\n        const entireDistance = this._calculateTraceDistance(context, game, trace);\n        return Math.ceil(entireDistance / distancePerTick);\n    }\n\n    _findAssignmentsWithTickLimit(game: Game, player: Player, context: Context, starGraph: StarGraph, assignments: Map<string, Assignment>, destinationId: string, ticksLimit: number, allowCarrierPurchase: boolean, onlyOne = false, filterNext: ((trace: TracePoint[], nextStarId: string) => boolean) | null = null): FoundAssignment[] {\n        const nextFilter = (trace: TracePoint[], nextStarId: string) => {\n            const entireTrace = trace.concat([{starId: nextStarId}]);\n            const ticksRequired = this._calculateTraceDuration(context, game, entireTrace);\n            const withinLimit = ticksRequired <= ticksLimit;\n\n            if (filterNext) {\n                return withinLimit && filterNext(trace, nextStarId);\n            }\n\n            return withinLimit;\n        }\n\n        const fittingAssignments: FoundAssignment[] = [];\n\n        const onAssignment = (assignment: Assignment, trace: TracePoint[]) => {\n            if (this._filterAssignmentByCarrierPurchase(assignment, allowCarrierPurchase)) {\n                fittingAssignments.push({\n                    assignment,\n                    trace\n                });\n            }\n\n            return !onlyOne;\n        }\n\n        this._searchAssignments(context, starGraph, assignments, nextFilter, onAssignment, destinationId)\n\n        return fittingAssignments;\n    }\n\n    _createDefaultAttackData(game: Game, starId: string, ticksUntil: number): KnownAttack {\n        const arrivalTick = game.state.tick + ticksUntil;\n\n        return {\n            starId,\n            arrivalTick,\n            carriersOnTheWay: []\n        };\n    }\n\n    _calculateRequiredShipsForAttack(game: Game, player: Player, context: Context, starToInvade: Star, ticksToArrival: number) {\n        const invadedPlayer = starToInvade.ownedByPlayerId!;\n\n        const starId = starToInvade._id.toString();\n        const defendingPlayer = this.playerService.getById(game, invadedPlayer)!;\n        const defendingCarriers = context.carriersOrbiting.get(starId) || [];\n\n        const techLevel = this.technologyService.getStarEffectiveTechnologyLevels(game, starToInvade, false);\n        const shipsOnCarriers = defendingCarriers.reduce((sum, c) => sum + (c.ships || 0), 0);\n        const shipsProduced = this.shipService.calculateStarShipsByTicks(techLevel.manufacturing, starToInvade.infrastructure.industry || 0, ticksToArrival, game.settings.galaxy.productionTicks);\n        const shipsAtArrival = (starToInvade.shipsActual || 0) + shipsOnCarriers + shipsProduced;\n\n        const defender = {\n            ships: Math.ceil(shipsAtArrival),\n            weaponsLevel: this.technologyService.getStarEffectiveWeaponsLevel(game, [defendingPlayer], starToInvade, defendingCarriers)\n        };\n\n        const attacker = {\n            ships: 0,\n            weaponsLevel: player.research.weapons.level\n        };\n\n        const result = this.combatService.calculate(defender, attacker, true, true);\n\n        return result.needed!.attacker;\n    }\n\n    _calculateRequiredShipsForDefense(game: Game, player: Player, context: Context, attackData: KnownAttack, attackingCarriers, defendingStar) {\n        const attackerIds = new Set();\n        const attackers: Player[] = [];\n\n        for (const attackingCarrier of attackingCarriers) {\n            const attacker = this.playerService.getById(game, attackingCarrier.ownedByPlayerId)!;\n            const attackerId = attacker._id.toString();\n            \n            if (!attackerIds.has(attackerId)) {\n                attackerIds.add(attackerId);\n                attackers.push(attacker);\n            }\n        }\n\n        const defenseCarriersAtStar = context.carriersOrbiting.get(defendingStar._id.toString()) || [];\n        let defenseCarriersOnTheWay: Carrier[] = [];\n        if (attackData) {\n            defenseCarriersOnTheWay = attackData.carriersOnTheWay.map(carrierId => context.carriersById.get(carrierId.toString())!);\n        }\n        const defenseCarriers = defenseCarriersAtStar.concat(defenseCarriersOnTheWay);\n        const result = this.combatService.calculateStar(game, defendingStar, [player], attackers, defenseCarriers, attackingCarriers, true);\n\n        if (result.after.defender <= 0) {\n            return result.needed!.defender - result.before.defender;\n        }\n\n        return 0;\n    }\n\n    priorityFromOrderCategory(category: AiAction) {\n        switch (category) {\n            case AiAction.DefendStar:\n                return 4;\n            case AiAction.InvadeStar:\n                return 3\n            case AiAction.ClaimStar:\n                return 2;\n            case AiAction.ReinforceStar:\n                return 1;\n            default:\n                return 0;\n        }\n    }\n\n    async _gatherAssignments(game: Game, player: Player, context: Context): Promise<Map<string, Assignment>> {\n        const assignments = new Map<string, Assignment>();\n\n        for (const playerStar of context.playerStars) {\n            const carriersHere = context.carriersOrbiting.get(playerStar._id.toString()) || [];\n            const carriersOwned = carriersHere.filter(c => c.ownedByPlayerId!.toString() === player._id.toString());\n\n            for (const carrier of carriersOwned) {\n                if (carrier.ships! > 1) {\n                    const newStarShips = playerStar.ships! + carrier.ships! - 1;\n                    await this.shipTransferService.transfer(game, player, carrier._id, 1, playerStar._id, newStarShips, false);\n                }\n            }\n\n            if (playerStar.ships! < 1 && carriersOwned.length === 0) {\n                continue;\n            }\n\n            assignments.set(playerStar._id.toString(), {\n                carriers: carriersOwned,\n                star: playerStar,\n                totalShips: playerStar.ships!\n            });\n        }\n\n        return assignments;\n    }\n\n    _gatherOrders(game: Game, player: Player, context: Context): Order[] {\n        const defenseOrders = this._gatherDefenseOrders(game, player, context);\n        const invasionOrders = this._gatherInvasionOrders(game, player, context);\n        const expansionOrders = this._gatherExpansionOrders(game, player, context);\n        const movementOrders = this._gatherMovementOrders(game, player, context);\n\n        return defenseOrders.concat(invasionOrders, expansionOrders, movementOrders);\n    }\n\n    _isEnemyPlayer(game: Game, player: Player, otherPlayerId: DBObjectId): boolean {\n        return player._id !== otherPlayerId\n            && this.diplomacyService.getDiplomaticStatusToPlayer(game, player._id, otherPlayerId).actualStatus !== 'allies';\n    }\n\n    _isEnemyStar(game: Game, player: Player, context: Context, star: Star): boolean {\n        if (star.ownedByPlayerId) {\n            return this._isEnemyPlayer(game, player, star.ownedByPlayerId);\n        }\n\n        return false;\n    }\n\n    _getStarScore(star: Star): number {\n        return (star.infrastructure.economy || 0) + (2 * (star.infrastructure.industry || 0)) + (3 * (star.infrastructure.science || 0));\n    }\n\n    _gatherInvasionOrders(game: Game, player: Player, context: Context): Order[] {\n        const orders: Order[] = [];\n        const visited = new Set<string>();\n\n        for (const [fromId, reachables] of context.allReachableFromPlayerStars) {\n            for (const reachable of reachables) {\n                if (!visited.has(reachable)) {\n                    visited.add(reachable);\n\n                    const star = context.starsById.get(reachable)!;\n\n                    if (this._isEnemyStar(game, player, context, star)) {\n                        const score = this._getStarScore(star);\n\n                        orders.push({\n                            type: AiAction.InvadeStar,\n                            star: reachable,\n                            score\n                        });\n                    }\n                }\n            }\n        }\n\n        return orders;\n    }\n\n    _claimInProgress(player: Player, starId: string): boolean {\n        return Boolean(player.aiState!.startedClaims && player.aiState!.startedClaims.find(claim => claim === starId));\n    }\n\n    _gatherExpansionOrders(game: Game, player: Player, context: Context): Order[] {\n        const orders: Order[] = [];\n        const used = new Set<string>();\n\n        for (const [fromId, reachables] of context.freelyReachableFromPlayerStars) {\n            const claimCandidates = Array.from(reachables).map(starId => context.starsById.get(starId)!).filter(star => !star.ownedByPlayerId);\n            for (const candidate of claimCandidates) {\n                const candidateId = candidate._id.toString();\n                if (!this._claimInProgress(player, candidateId) && !used.has(candidateId)) {\n                    used.add(candidateId);\n\n                    let score = 1;\n                    if (candidate.naturalResources) {\n                        score = candidate.naturalResources.economy + candidate.naturalResources.industry + candidate.naturalResources.science;\n                    }\n\n                    orders.push({\n                        type: AiAction.ClaimStar,\n                        star: candidateId,\n                        score\n                    });\n                }\n            }\n        }\n\n        return orders;\n    }\n\n    _getAttackData(game: Game, player: Player, attackedStarId: string, attackInTicks: number): KnownAttack | undefined {\n        const attackAbsoluteTick = game.state.tick + attackInTicks;\n\n        return player.aiState!.knownAttacks.find(attack => attack.starId === attackedStarId.toString() && attack.arrivalTick === attackAbsoluteTick);\n    }\n\n    _gatherDefenseOrders(game: Game, player: Player, context: Context): Order[] {\n        const orders: Order[] = [];\n\n        for (const [attackedStarId, attacks] of context.attacksByStarId) {\n            for (const [attackInTicks, incomingCarriers] of attacks) {\n                const attackedStar = context.starsById.get(attackedStarId)!;\n                const starScore = this._getStarScore(attackedStar);\n\n                orders.push({\n                    type: AiAction.DefendStar,\n                    score: starScore,\n                    star: attackedStarId,\n                    ticksUntil: attackInTicks,\n                    incomingCarriers\n                });\n            }\n        }\n\n        return orders;\n    }\n\n    _isUnderAttack(context: Context, starId: string): boolean {\n        return context.attackedStarIds.has(starId);\n    }\n\n    _gatherMovementOrders(game: Game, player: Player, context: Context): Order[] {\n        const orders: Order[] = [];\n        const starPriorities = this._computeStarPriorities(game, player, context);\n\n        for (const [starId, priority] of starPriorities) {\n\n            const neighbors = context.reachablePlayerStars.get(starId)!;\n            for (const neighbor of neighbors) {\n                if (this._isUnderAttack(context, neighbor)) {\n                    continue;\n                }\n\n                const neighborPriority = starPriorities.get(neighbor)!;\n                if (neighborPriority * REINFORCEMENT_MIN_FACTOR < priority) {\n                    orders.push({\n                        type: AiAction.ReinforceStar,\n                        score: priority - neighborPriority,\n                        star: starId,\n                        source: neighbor\n                    });\n                }\n            }\n        }\n\n        return orders;\n    }\n\n    _computeStarPriorities(game: Game, player: Player, context: Context): Map<string, number> {\n        const hyperspaceRange = this._getGlobalHighestHyperspaceRange(game);\n        const borderStarPriorities = new Map<string, number>();\n\n        for (const borderStarId of context.borderStars) {\n            const borderStar = context.starsById.get(borderStarId)!;\n            const reachables = context.starsInGlobalRange.get(borderStarId)!;\n\n            let score = 0;\n\n            for (const reachableId of reachables) {\n                const reachableStar = context.starsById.get(reachableId)!;\n\n                if (!reachableStar.ownedByPlayerId) {\n                    const distance = this.distanceService.getDistanceBetweenLocations(borderStar.location, reachableStar.location);\n                    const distanceScore = (distance / hyperspaceRange) * EMPTY_STAR_SCORE_MULTIPLIER;\n\n                    score += distanceScore;\n                } else if (reachableStar.ownedByPlayerId.toString() !== player._id.toString()) {\n                    const distance = this.distanceService.getDistanceBetweenLocations(borderStar.location, reachableStar.location);\n                    const distanceScore = distance / hyperspaceRange * ENEMY_STAR_SCORE_MULTIPLIER;\n\n                    score += distanceScore;\n                }\n            }\n\n            borderStarPriorities.set(borderStarId, score);\n        }\n\n        const visited = new Set();\n        const starPriorities = new Map(borderStarPriorities);\n\n        while (true) {\n            let changed = false;\n\n            for (const [starId, priority] of starPriorities) {\n                if (!visited.has(starId)) {\n                    visited.add(starId);\n\n                    const reachables = context.reachablePlayerStars.get(starId)!;\n\n                    for (const reachableId of reachables) {\n                        const oldPriority = starPriorities.get(reachableId) || 0;\n                        const transitivePriority = priority * 0.5;\n                        const newPriority = Math.max(oldPriority, transitivePriority);\n\n                        starPriorities.set(reachableId, newPriority);\n\n                        changed = true;\n                    }\n                }\n            }\n\n            if (!changed) {\n                break;\n            }\n        }\n\n        return starPriorities;\n    }\n\n    _getGlobalHighestHyperspaceRange(game: Game): number {\n        const highestLevel = maxBy((p: Player) => p.research.hyperspace.level, game.galaxy.players);\n\n        return this.distanceService.getHyperspaceDistance(game, highestLevel);\n    }\n\n    _getHyperspaceRangeExternal(game: Game, player: Player): number {\n        const scanningRange = this.distanceService.getScanningDistance(game, player.research.scanning.level);\n        const hyperspaceRange = this.distanceService.getHyperspaceDistance(game, player.research.hyperspace.level);\n        return Math.min(scanningRange, hyperspaceRange);\n    }\n\n    _getHyperspaceRangeInternal(game: Game, player: Player): number {\n        return this.distanceService.getHyperspaceDistance(game, player.research.hyperspace.level);\n    }\n\n    _computeStarGraph(starsById: Map<string, Star>, game: Game, player: Player, traverseStars: Star[], reachStars: Star[], hyperspaceRange: number): StarGraph {\n        const starGraph = new Map<string, Set<string>>();\n\n        traverseStars.forEach(star => {\n            const reachableFromPlayerStars = new Set<string>();\n\n            reachStars.forEach(otherStar => {\n                if (star._id !== otherStar._id && this._calculateTravelDistance(star, otherStar) <= hyperspaceRange) {\n                    reachableFromPlayerStars.add(otherStar._id.toString());\n                }\n            });\n\n            starGraph.set(star._id.toString(), reachableFromPlayerStars);\n        });\n\n        return starGraph;\n    }\n\n    async _playFirstTick(game: Game, player: Player) {\n        if (!player.credits || player.credits < 0) {\n            return\n        }\n\n        // On the first tick after production:\n        // 1. Bulk upgrade X% of credits to ind and sci.\n        let creditsToSpendSci = Math.floor(player.credits / 100 * FIRST_TICK_BULK_UPGRADE_SCI_PERCENTAGE);\n        let creditsToSpendInd = Math.floor(player.credits / 100 * FIRST_TICK_BULK_UPGRADE_IND_PERCENTAGE);\n\n        if (creditsToSpendSci) {\n            await this.starUpgradeService.upgradeBulk(game, player, 'totalCredits', 'science', creditsToSpendSci, false);\n        }\n\n        if (creditsToSpendInd) {\n            await this.starUpgradeService.upgradeBulk(game, player, 'totalCredits', 'industry', creditsToSpendInd, false);\n        }\n    }\n\n    async _playLastTick(game: Game, player: Player) {\n        if (!player.credits || player.credits <= 0) {\n            return\n        }\n\n        // On the last tick of the cycle:\n        // 1. Spend remaining credits upgrading economy.\n        let creditsToSpendEco = Math.floor(player.credits / 100 * LAST_TICK_BULK_UPGRADE_ECO_PERCENTAGE);\n\n        if (creditsToSpendEco) {\n            await this.starUpgradeService.upgradeBulk(game, player, 'totalCredits', 'economy', creditsToSpendEco, false);\n        }\n    }\n\n    getStarName(context: Context, starId: string) {\n        return context.starsById.get(starId)!.name;\n    }\n\n    cleanupState(player: Player) {\n        player.aiState = null;\n    }\n};\n"],
  "mappings": "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",
  "names": ["AiAction"]
}
