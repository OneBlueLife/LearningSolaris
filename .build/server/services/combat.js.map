{
  "version": 3,
  "sources": ["../../../server/services/combat.ts"],
  "sourcesContent": ["import { Carrier } from \"./types/Carrier\";\nimport { Attacker, CombatCarrier, CombatPart, CombatResult, CombatResultShips, CombatStar, Defender } from \"./types/Combat\";\nimport { Game } from \"./types/Game\";\nimport { Player } from \"./types/Player\";\nimport { Star, StarCaptureResult } from \"./types/Star\";\nimport { User } from \"./types/User\";\nimport DiplomacyService from \"./diplomacy\";\nimport GameTypeService from \"./gameType\";\nimport PlayerService from \"./player\";\nimport ReputationService from \"./reputation\";\nimport SpecialistService from \"./specialist\";\nimport StarService from \"./star\";\nimport TechnologyService from \"./technology\";\n\nconst EventEmitter = require('events');\n\nexport const CombatServiceEvents = {\n    onPlayerCombatStar: 'onPlayerCombatStar',\n    onPlayerCombatCarrier: 'onPlayerCombatCarrier'\n}\n\nexport default class CombatService extends EventEmitter {\n    technologyService: TechnologyService;\n    specialistService: SpecialistService;\n    playerService: PlayerService;\n    starService: StarService;\n    reputationService: ReputationService;\n    diplomacyService: DiplomacyService;\n    gameTypeService: GameTypeService;\n    \n    constructor(\n        technologyService: TechnologyService,\n        specialistService: SpecialistService,\n        playerService: PlayerService,\n        starService: StarService,\n        reputationService: ReputationService,\n        diplomacyService: DiplomacyService,\n        gameTypeService: GameTypeService\n    ) {\n        super();\n\n        this.technologyService = technologyService;\n        this.specialistService = specialistService;\n        this.playerService = playerService;\n        this.starService = starService;\n        this.reputationService = reputationService;\n        this.diplomacyService = diplomacyService;\n        this.gameTypeService = gameTypeService;\n    }\n\n    calculate(defender: Defender, attacker: Attacker, isTurnBased: boolean = true, calculateNeeded: boolean = false): CombatResultShips {\n        let defenderShipsRemaining = defender.ships;\n        let attackerShipsRemaining = attacker.ships;\n\n        let defendPowerBase = defender.weaponsLevel;\n        let attackPowerBase = attacker.weaponsLevel;\n        let defendPower = defender.weaponsLevel;\n        let attackPower = attacker.weaponsLevel;\n\n        // If in non-turn based mode the attacker/defender cannot survive a single blow\n        // then they should outright be destroyed without delivering a blow to the opposition.\n        // Note: This addresses an exploit where players can send out 1 ship carriers to chip away \n        // at incoming carriers.\n        if (!isTurnBased) {\n            if (defender.ships <= attacker.weaponsLevel) {\n                defendPower = 1;\n            }\n            \n            if (attacker.ships <= defender.weaponsLevel) {\n                attackPower = 1;\n            }\n        }\n\n        const defenderAdditionalTurns = isTurnBased ? 1 : 0;\n\n        const defenderTurns = Math.ceil(attacker.ships / defendPower);\n        const attackerTurns = Math.ceil(defender.ships / attackPower);\n\n        let needed: CombatPart | null = null;\n\n        if (defenderTurns <= attackerTurns)  {\n            attackerShipsRemaining = 0;\n            defenderShipsRemaining = defender.ships - (defenderTurns - defenderAdditionalTurns) * attackPower;\n\n            if (calculateNeeded) {\n                needed = {\n                    defender: 0,\n                    attacker: attackerTurns * defendPower + 1\n                };\n            }\n        } else {\n            defenderShipsRemaining = 0;\n            attackerShipsRemaining = attacker.ships - attackerTurns * defendPower;\n\n            if (calculateNeeded) {\n                needed = {\n                    attacker: 0,\n                    defender: (defenderTurns - defenderAdditionalTurns) * attackPower + defenderAdditionalTurns\n                };\n            }\n        }\n\n        attackerShipsRemaining = Math.max(0, attackerShipsRemaining);\n        defenderShipsRemaining = Math.max(0, defenderShipsRemaining);\n        \n        let result: CombatResultShips = {\n            weapons: {\n                defender: defendPower,\n                defenderBase: defendPowerBase,\n                attacker: attackPower,\n                attackerBase: attackPowerBase\n            },\n            before: {\n                defender: defender.ships,\n                attacker: attacker.ships\n            },\n            after: {\n                defender: defenderShipsRemaining,\n                attacker: attackerShipsRemaining\n            },\n            lost: {\n                defender: defender.ships - defenderShipsRemaining,\n                attacker: attacker.ships - attackerShipsRemaining\n            }\n        };\n\n        if (calculateNeeded) {\n            result.needed = needed;\n        }\n\n        return result;\n    }\n\n    calculateStar(game: Game, star: Star, defenders: Player[], attackers: Player[], defenderCarriers: Carrier[], attackerCarriers: Carrier[], calculateNeeded: boolean = false) {\n        let combatWeapons = this._calculateEffectiveWeaponsLevels(game, star, defenders, attackers, defenderCarriers, attackerCarriers);\n\n        let combatResult = this.calculate({\n            weaponsLevel: combatWeapons.defenderWeaponsTechLevel,\n            ships: combatWeapons.totalDefenders\n        }, {\n            weaponsLevel: combatWeapons.attackerWeaponsTechLevel,\n            ships: combatWeapons.totalAttackers\n        }, true, calculateNeeded);\n\n        return combatResult;\n    }\n\n    calculateCarrier(game: Game, defenders: Player[], attackers: Player[], defenderCarriers: Carrier[], attackerCarriers: Carrier[]) {\n        let combatWeapons = this._calculateEffectiveWeaponsLevels(game, null, defenders, attackers, defenderCarriers, attackerCarriers);\n\n        let combatResult = this.calculate({\n            weaponsLevel: combatWeapons.defenderWeaponsTechLevel,\n            ships: combatWeapons.totalDefenders\n        }, {\n            weaponsLevel: combatWeapons.attackerWeaponsTechLevel,\n            ships: combatWeapons.totalAttackers\n        }, false);\n\n        return combatResult;\n    }\n\n    _calculateEffectiveWeaponsLevels(game: Game, star: Star | null, defenders: Player[], attackers: Player[], defenderCarriers: Carrier[], attackerCarriers: Carrier[]) {\n        let isCarrierToStarCombat = star != null;\n\n        // Calculate the total number of defending ships\n        let totalDefenders = defenderCarriers.reduce((sum, c) => sum + c.ships!, 0);\n\n        if (isCarrierToStarCombat) {\n            totalDefenders += Math.floor(star!.shipsActual!);\n        }\n        \n        // Calculate the total number of attacking ships\n        let totalAttackers = attackerCarriers.reduce((sum, c) => sum + c.ships!, 0);\n\n        // Calculate the defender weapons tech level based on any specialists present at stars or carriers.\n        let defenderWeaponsTechLevel: number;\n\n        if (isCarrierToStarCombat) {\n            defenderWeaponsTechLevel = this.technologyService.getStarEffectiveWeaponsLevel(game, defenders, star!, defenderCarriers);\n        } else {\n            defenderWeaponsTechLevel = this.technologyService.getCarriersEffectiveWeaponsLevel(game, defenders, defenderCarriers, isCarrierToStarCombat, false);\n        }\n        \n        // Calculate the weapons tech level for the attacker\n        let attackerWeaponsTechLevel = this.technologyService.getCarriersEffectiveWeaponsLevel(game, attackers, attackerCarriers, isCarrierToStarCombat, true);\n\n        // Check for deductions to weapons to either side\n        let defenderWeaponsDeduction = this.technologyService.getCarriersWeaponsDebuff(attackerCarriers);\n        let attackerWeaponsDeduction = this.technologyService.getCarriersWeaponsDebuff(defenderCarriers);\n\n        // Ensure that both sides fight with AT LEAST level 1 weapons\n        defenderWeaponsTechLevel = Math.max(defenderWeaponsTechLevel - defenderWeaponsDeduction, 1);\n        attackerWeaponsTechLevel = Math.max(attackerWeaponsTechLevel - attackerWeaponsDeduction, 1);\n\n        // Check to see if weapons tech should be swapped (joker specialist)\n        let defenderSwapWeapons = this._shouldSwapWeaponsTech(defenderCarriers);\n        let attackerSwapWeapons = this._shouldSwapWeaponsTech(attackerCarriers);\n\n        let shouldSwapWeaponsTech = (isCarrierToStarCombat && attackerSwapWeapons && !defenderSwapWeapons) ||   // Attacker controls controls the weapon swap in c2s combat unless both have jokers\n                                    (!isCarrierToStarCombat && attackerSwapWeapons !== defenderSwapWeapons);    // In c2c combat, swap weapons unless both have jokers\n\n        if (shouldSwapWeaponsTech) {\n            let oldDefenderWeaponsTechLevel = defenderWeaponsTechLevel;\n            let oldAttackerWeaponsTechLevel = attackerWeaponsTechLevel;\n\n            defenderWeaponsTechLevel = oldAttackerWeaponsTechLevel;\n            attackerWeaponsTechLevel = oldDefenderWeaponsTechLevel;\n        }\n\n        return {\n            totalDefenders,\n            totalAttackers,\n            defenderWeaponsTechLevel,\n            attackerWeaponsTechLevel\n        };\n    }\n\n    async performCombat(game: Game, gameUsers: User[], defender: Player, star: Star | null, carriers: Carrier[]) {\n        const isFormalAlliancesEnabled = this.diplomacyService.isFormalAlliancesEnabled(game);\n\n        // NOTE: If star is null then the combat mode is carrier-to-carrier.\n\n        // Allies of the defender will be on the defending side.\n        let defenderAllies: Player[] = [];\n\n        if (isFormalAlliancesEnabled) {\n            defenderAllies = this.diplomacyService.getAlliesOfPlayer(game, defender);\n        }\n\n        // Get all defender carriers ordered by most carriers present descending.\n        // Carriers who have the most ships will be target first in combat.\n        let defenderCarriers = carriers\n            .filter(c => \n                c.ships! > 0\n                && !c.isGift\n                && (c.ownedByPlayerId!.toString() === defender._id.toString()) || defenderAllies.find(a => a._id.toString() === c.ownedByPlayerId!.toString())  // Either owned by the defender or owned by an ally\n            )\n            .sort((a, b) => b.ships! - a.ships!);\n\n        // If in carrier-to-carrier combat, verify that there are carriers that can fight.\n        if (!star && !defenderCarriers.length) {\n            return;\n        }\n\n        // Get all attacker carriers.\n        let attackerCarriers = carriers\n            .filter(c => \n                c.ships! > 0 \n                && !c.isGift \n                && c.ownedByPlayerId!.toString() !== defender._id.toString()    // Not owned by the player and\n                && !defenderAllies.find(a => a._id.toString() === c.ownedByPlayerId!.toString())   // Not owned by an ally\n            )\n            .sort((a, b) => b.ships! - a.ships!);\n\n        // Double check that the attacking carriers can fight.\n        if (!attackerCarriers.length) {\n            return;\n        }\n\n        // Get the players for the defender and all attackers.\n        let defenderPlayerIds = defenderCarriers.map(c => c.ownedByPlayerId!.toString());\n        defenderPlayerIds.push(defender._id.toString());\n        defenderPlayerIds = [...new Set(defenderPlayerIds)];\n\n        let attackerPlayerIds = [...new Set(attackerCarriers.map(c => c.ownedByPlayerId!.toString()))];\n\n        let defenders: Player[] = defenderPlayerIds.map(playerId => this.playerService.getById(game, playerId as any)!);\n        let attackers: Player[] = attackerPlayerIds.map(playerId => this.playerService.getById(game, playerId as any)!);\n\n        let defenderUsers: User[] = [];\n        let attackerUsers: User[] = [];\n        \n        for (let defender of defenders) {\n            let user = gameUsers.find(u => defender.userId && u._id.toString() === defender.userId.toString());\n            \n            if (user) {\n                defenderUsers.push(user);\n            }\n        }\n        \n        for (let attacker of attackers) {\n            let user = gameUsers.find(u => attacker.userId && u._id.toString() === attacker.userId.toString());\n            \n            if (user) {\n                attackerUsers.push(user);\n            }\n        }\n\n        // Perform combat at the star.\n        let combatResultShips: CombatResultShips;\n        \n        if (star) {\n            combatResultShips = this.calculateStar(game, star, defenders, attackers, defenderCarriers, attackerCarriers);\n        } else {\n            combatResultShips = this.calculateCarrier(game, defenders, attackers, defenderCarriers, attackerCarriers);\n        }\n\n        let combatResult: CombatResult = {\n            ...combatResultShips,\n            star: null,\n            carriers: []\n        };\n\n        // Add all of the carriers to the combat result with a snapshot of\n        // how many ships they had before combat occurs.\n        // We will update this as we go along with combat.\n        combatResult.carriers = carriers.map(c => {\n            let specialist = this.specialistService.getByIdCarrierTrim(c.specialistId);\n            let scrambled = (star && star.isNebula && defenderPlayerIds.includes(c.ownedByPlayerId!.toString())) || this.specialistService.getCarrierHideShips(c); \n\n            return {\n                _id: c._id,\n                name: c.name,\n                ownedByPlayerId: c.ownedByPlayerId!,\n                specialist,\n                before: c.ships!,\n                lost: 0,\n                after: c.ships!,\n                scrambled\n            };\n        });\n\n        if (star) {\n            let specialist = this.specialistService.getByIdStarTrim(star.specialistId);\n            let scrambled = star.isNebula || this.specialistService.getStarHideShips(star);\n\n            // Do the same with the star.\n            combatResult.star = {\n                _id: star._id,\n                ownedByPlayerId: star.ownedByPlayerId,\n                specialist,\n                before: Math.floor(star.shipsActual!),\n                lost: 0,\n                after: Math.floor(star.shipsActual!),\n                scrambled\n            };\n        }\n\n        let defenderObjects: (Star | Carrier)[] = [...defenderCarriers];\n\n        if (star) {\n            defenderObjects.push(star);\n        }\n\n        // Distribute damage evenly across all objects that are involved in combat.\n        this._distributeDamage(combatResult, attackerCarriers, combatResult.lost.attacker, true);\n        this._distributeDamage(combatResult, defenderObjects, combatResult.lost.defender, true);\n\n        if (!this.gameTypeService.isTutorialGame(game)) {\n            this._updatePlayersCombatAchievements(combatResult, defenders, defenderUsers, defenderCarriers, attackers, attackerUsers, attackerCarriers);\n        }\n\n        // Remove any carriers from the game that have been destroyed.\n        let destroyedCarriers = game.galaxy.carriers.filter(c => !c.ships);\n\n        for (let carrier of destroyedCarriers) {\n            game.galaxy.carriers.splice(game.galaxy.carriers.indexOf(carrier), 1);\n\n            if (attackerCarriers.indexOf(carrier) > -1) {\n                attackerCarriers.splice(attackerCarriers.indexOf(carrier), 1);\n            }\n\n            if (defenderCarriers.indexOf(carrier) > -1) {\n                defenderCarriers.splice(defenderCarriers.indexOf(carrier), 1);\n            }\n        }\n\n        // If the defender has been eliminated at the star then the attacker who travelled the shortest distance in the last tick\n        // captures the star. Repeat star combat until there is only one player remaining.\n        let captureResult: StarCaptureResult | null = null;\n\n        if (star) {\n            captureResult = this._starDefeatedCheck(game, star, defender, defenders, defenderUsers, defenderCarriers, attackers, attackerUsers, attackerCarriers);\n        }\n\n        // Deduct reputation for all attackers that the defender is fighting and vice versa.\n        for (let defenderPlayer of defenders) {\n            for (let attackerPlayer of attackers) {\n                await this.reputationService.decreaseReputation(game, attackerPlayer, defenderPlayer, false);\n                await this.reputationService.decreaseReputation(game, defenderPlayer, attackerPlayer, false);\n            }\n        }\n\n        // Log the combat event\n        if (star) {\n            this.emit(CombatServiceEvents.onPlayerCombatStar, {\n                gameId: game._id,\n                gameTick: game.state.tick,\n                owner: defender,\n                defenders,\n                attackers,\n                star,\n                combatResult,\n                captureResult\n            });\n        } else {\n            this.emit(CombatServiceEvents.onPlayerCombatCarrier, {\n                gameId: game._id,\n                gameTick: game.state.tick,\n                defenders,\n                attackers,\n                combatResult\n            });\n        }\n\n        // If there are still attackers remaining, recurse.\n        attackerPlayerIds = [...new Set(attackerCarriers.map(c => c.ownedByPlayerId!.toString()))];\n\n        if (attackerPlayerIds.length > 1) {\n            // Get the next player to act as the defender.\n            if (star) {\n                defender = this.playerService.getById(game, star.ownedByPlayerId!)!;\n            } else {\n                defender = this.playerService.getById(game, attackerPlayerIds[0] as any)!;\n            }\n\n            await this.performCombat(game, gameUsers, defender, star, attackerCarriers);\n        }\n\n        return combatResultShips;\n    }\n\n    _starDefeatedCheck(game: Game, star: Star, owner: Player, defenders: Player[], defenderUsers: User[], defenderCarriers: Carrier[], attackers: Player[], attackerUsers: User[], attackerCarriers: Carrier[]) {\n        let starDefenderDefeated = star && !Math.floor(star.shipsActual!) && !defenderCarriers.length;\n        let hasAttackersRemaining = attackerCarriers.reduce((sum, c) => sum + c.ships!, 0) > 0;\n        let hasCapturedStar = starDefenderDefeated && hasAttackersRemaining;\n\n        if (hasCapturedStar) {\n            return this.starService.captureStar(game, star, owner, defenders, defenderUsers, attackers, attackerUsers, attackerCarriers);\n        }\n\n        return null;\n    }\n\n    _distributeDamage(combatResult: CombatResult, damageObjects, shipsToKill: number, destroyCarriers: boolean = true) {\n        while (shipsToKill) {\n            let objectsToDeduct = damageObjects\n                .filter(c => \n                    c.ships > 0 &&\n                    // Is the star \n                    // OR allow destroying carriers\n                    // OR if NOT destroying carriers then carriers that have more than 1 ship.\n                    (c.shipsActual != null || destroyCarriers || c.ships > 1)\n                )\n                .sort((a, b) => {\n                    // Sort by specialist (kill objects without specialists first)\n                    if (a.specialistId == null && b.specialistId != null) {\n                        return -1;\n                    } else if (a.specialistId != null && b.specialistId == null) {\n                        return 1;\n                    }\n\n                    // Sort by ships descending (kill objects with the most ships first)\n                    if (a.ships > b.ships) return -1;\n                    if (a.ships < b.ships) return 1;\n\n                    return 0; // Both are the same.\n                });\n            \n            if (!objectsToDeduct.length) {\n                return shipsToKill;\n            }\n\n            // Try to distribute damage evenly across all objects, minimum of 1.\n            let shipsPerObject = Math.max(1, Math.floor(shipsToKill / objectsToDeduct.length));\n\n            for (let obj of objectsToDeduct) {\n                let isCarrier = obj.shipsActual == null;\n                let combatObject: CombatCarrier | CombatStar = (combatResult.carriers.find(c => c._id.toString() === obj._id.toString()) || combatResult.star)!;\n\n                // Calculate how many ships to kill, capped to however many ships the object has.\n                let killed: number;\n\n                // If we are not destroying carriers then we need to keep\n                // at least 1 ship on the carrier, otherwise just kill them all.\n                if (!destroyCarriers && isCarrier) {\n                    killed = Math.min(obj.ships - 1, shipsPerObject);\n                } else {\n                    killed = Math.min(obj.ships, shipsPerObject);\n                }\n\n                killed = Math.max(0, killed); // Just in case.\n\n                combatObject.after = (combatObject.after as number) - killed;\n                combatObject.lost = (combatObject.lost as number) + killed;\n                shipsToKill -= killed;\n\n                // Apply damage to the carrier or star.\n                if (isCarrier) {\n                    obj.ships -= killed;\n                } else {\n                    obj.shipsActual -= killed;\n                    obj.ships = Math.floor(obj.shipsActual);\n                }\n\n                // If there's no more ships to kill then break out early\n                // so we don't deduct too many ships from the objects.\n                if (!shipsToKill) {\n                    break;\n                }\n            }\n        }\n\n        return shipsToKill;\n    }\n\n    _updatePlayersCombatAchievements(combatResult: CombatResult, defenders: Player[], defenderUsers: User[], defenderCarriers: Carrier[], attackers: Player[], attackerUsers: User[], attackerCarriers: Carrier[]) {\n        let defenderCarriersDestroyed = defenderCarriers.filter(c => !c.ships).length;\n        let defenderSpecialistsDestroyed = defenderCarriers.filter(c => !c.ships && c.specialistId).length;\n\n        let attackerCarriersDestroyed = attackerCarriers.filter(c => !c.ships).length;\n        let attackerSpecialistsDestroyed = attackerCarriers.filter(c => !c.ships && c.specialistId).length;\n\n        // Add combat result stats to defender achievements.\n        for (let defenderUser of defenderUsers) {\n            let defender = defenders.find(u => u.userId && u.userId.toString() === defenderUser._id.toString())!;\n\n            if (defender && !defender.defeated) {\n                let playerCarriers = defenderCarriers.filter(c => c.ownedByPlayerId!.toString() === defender._id.toString());\n\n                defenderUser.achievements.combat.kills.ships += combatResult.lost.attacker;\n                defenderUser.achievements.combat.kills.carriers += attackerCarriersDestroyed;\n                defenderUser.achievements.combat.kills.specialists += attackerSpecialistsDestroyed;\n                \n                defenderUser.achievements.combat.losses.ships += combatResult.lost.defender; // TODO: This will not be correct in combat where its more than 2 players.\n                defenderUser.achievements.combat.losses.carriers += playerCarriers.filter(c => !c.ships).length;\n                defenderUser.achievements.combat.losses.specialists += playerCarriers.filter(c => !c.ships && c.specialistId).length;\n            }\n        }\n\n        // Add combat result stats to attacker achievements.\n        for (let attackerUser of attackerUsers) {\n            let attacker = attackers.find(u => u.userId && u.userId.toString() === attackerUser._id.toString())!;\n\n            if (attacker && !attacker.defeated) {\n                let playerCarriers = attackerCarriers.filter(c => c.ownedByPlayerId!.toString() === attacker._id.toString());\n\n                attackerUser.achievements.combat.kills.ships += combatResult.lost.defender;\n                attackerUser.achievements.combat.kills.carriers += defenderCarriersDestroyed;\n                attackerUser.achievements.combat.kills.specialists += defenderSpecialistsDestroyed;\n                \n                attackerUser.achievements.combat.losses.ships += combatResult.lost.attacker; // TODO: This will not be correct in combat where its more than 2 players.\n                attackerUser.achievements.combat.losses.carriers += playerCarriers.filter(c => !c.ships).length;\n                attackerUser.achievements.combat.losses.specialists += playerCarriers.filter(c => !c.ships && c.specialistId).length;\n            }\n        }\n    }\n\n    _shouldSwapWeaponsTech(carriers: Carrier[]) {\n        return carriers\n            .filter(c => c.specialistId)\n            .find(c => this.specialistService.getByIdCarrier(c.specialistId)?.modifiers.special?.combatSwapWeaponsTechnology) != null;\n    }\n\n    sanitiseCombatResult(combatResult: CombatResult, player: Player) {\n        let result: CombatResult = Object.assign({}, combatResult);\n\n        if (result.star) {\n            result.star = this.tryMaskObjectShips(combatResult.star, player) as CombatStar;\n        }\n\n        result.carriers = combatResult.carriers.map(c => this.tryMaskObjectShips(c, player)) as CombatCarrier[];\n\n        return result;\n    }\n\n    tryMaskObjectShips(carrierOrStar: CombatStar | CombatCarrier | null, player: Player) {\n        if (!carrierOrStar) {\n            return carrierOrStar;\n        }\n\n        // If the player doesn't own the object and the object is a scrambler then we need\n        // to mask the before and lost amounts.\n        if (carrierOrStar.scrambled && carrierOrStar.ownedByPlayerId && player._id.toString() !== carrierOrStar.ownedByPlayerId.toString()) {\n            let clone: CombatStar | CombatCarrier = Object.assign({}, carrierOrStar);\n\n            clone.before = '???';\n            clone.lost = '???';\n\n            // If the object lost ships and is now dead, then we need to mask the after value too.\n            // Note: Stars can have a 0 ship garrison and be a scrambler so we want to ensure that the 0 ships is still scrambled.\n            if (carrierOrStar.before === 0 || carrierOrStar.after > 0) {\n                clone.after = '???';\n            }\n\n            return clone;\n        }\n\n        return carrierOrStar;\n    }\n\n}\n"],
  "mappings": "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",
  "names": ["defender"]
}
